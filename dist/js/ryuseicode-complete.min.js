/*!
 * RyuseiCode.js
 * Version  : 0.1.3
 * License  : MIT
 * Copyright: 2021 Naotoshi Fujita
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.RyuseiCode = factory());
}(this, (function () { 'use strict';

  /**
   * The collection of i18n strings.
   *
   * @since 0.1.0
   */
  const I18N$4 = {
      copy: 'Copy',
      cut: 'Cut',
      paste: 'Paste',
      selectAll: 'Select All',
      close: 'Close',
      confirm: 'OK',
      activate: 'Activate',
      notice: 'Notice',
      cancel: 'Cancel',
      failedToCopy: 'Can not copy on your environment.',
      scrollbar: 'Drag to Scroll',
      inputLabel: 'Edit the code.',
      location: 'Line: %s, Column: %s',
  };

  /**
   * Icon settings as [ path, stroke?, linecap? ].
   *
   * @since 0.1.0
   */
  const ICONS$1 = {
      arrowUp: [
          'm18.6 10.3c-6.59-6.85-6.59-6.85-6.59-6.85m-6.59 6.85 6.59-6.85m0 17v-17',
          3,
      ],
      arrowDown: [
          'm5.41 13.7 6.59 6.85m6.59-6.85c-6.59 6.85-6.59 6.85-6.59 6.85m0-17v17',
          3,
      ],
      close: [
          'm19 18-14-13m0 13 14-13',
          3,
      ],
  };

  /**
   * The map for kay bindings (`[ key, ctrl, shift, alt ]`).
   *
   * @since 0.1.0
   */
  const KEYMAP$6 = {
      selectAll: ['A', true],
  };
  /**
   * The collection of modifier keys.
   *
   * @since 0.1.0
   */
  const MODIFIER_KEYS = {
      default: ['Ctrl', 'Shift', 'Alt'],
      mac: ['⌘', '⇧', '⌥'],
  };

  /**
   * Default values for the editor options.
   *
   * @since 0.1.0
   */
  const DEFAULT_OPTIONS$6 = {
      language: 'javascript',
      placeholder: 'Enter code here…',
      minWidth: '200px',
      maxWidth: '100%',
      minHeight: '16em',
      maxHeight: '40em',
      indent: '  ',
      tabSize: 2,
      tabIndex: 0,
      keymap: KEYMAP$6,
      maxInitialLines: 200,
      icons: ICONS$1,
      i18n: I18N$4,
  };

  /**
   * Checks if the array includes the value or not.
   * `Array#includes` is not supported by IE.
   *
   * @param array - An array.
   * @param value - A value to search for.
   *
   * @return `true` if the array includes the value, or otherwise `false`.
   */
  function includes(array, value) {
      return array.indexOf(value) > -1;
  }

  /**
   * Checks if the given subject is an object or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is an object, or otherwise `false`.
   */
  function isObject$1(subject) {
      return subject !== null && typeof subject === 'object';
  }
  /**
   * Checks if the given subject is an array or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is an array, or otherwise `false`.
   */
  function isArray(subject) {
      return Array.isArray(subject);
  }
  /**
   * Checks if the given subject is a function or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is a function, or otherwise `false`.
   */
  function isFunction(subject) {
      return typeof subject === 'function';
  }
  /**
   * Checks if the given subject is a string or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is a string, or otherwise `false`.
   */
  function isString(subject) {
      return typeof subject === 'string';
  }
  /**
   * Checks if the given subject is `undefined` or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is `undefined`, or otherwise `false`.
   */
  function isUndefined$1(subject) {
      return typeof subject === 'undefined';
  }
  /**
   * Checks if the given subject is a Text node or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is a Text node, or otherwise `false`.
   */
  function isText(subject) {
      return subject instanceof Text;
  }
  /**
   * Checks if the given subject is a HTMLElement instance or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is a HTMLElement instance, or otherwise `false`.
   */
  function isHTMLElement(subject) {
      return subject instanceof HTMLElement;
  }
  /**
   * Checks if the given subject is a BR element or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is a BR element, or otherwise `false`.
   */
  function isBr(subject) {
      return subject instanceof HTMLBRElement;
  }

  /**
   * Push the provided value to an array if the value is not an array.
   *
   * @param value - A value to push.
   * @param nest  - Optional. Whether to push the value to an array if the value is already an array.
   *
   * @return An array containing the value, or the value itself if it is already an array.
   *         If the `nest` is `true` and the first child of the array is not an array,
   *         this returns an array with the provided array.
   */
  function toArray(value, nest = false) {
      if (isArray(value)) {
          if (nest && !isArray(value[0])) {
              return [value];
          }
          return value;
      }
      return [value];
  }

  const arrayProto = Array.prototype;

  /**
   * The slice method for an array-like object.
   *
   * @param arrayLike - An array-like object.
   * @param start     - Optional. A start index.
   * @param end       - Optional. A end index.
   *
   * @return An array with sliced elements.
   */
  function slice(arrayLike, start, end) {
      return arrayProto.slice.call(arrayLike, start, end);
  }

  /**
   * The splice method for an array-like object.
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
   *
   * @param arrayLike   - An array-like object.
   * @param start       - A start index.
   * @param deleteCount - Optional. A number of elements to remove from the `start` index.
   * @param args        - Optional. Any number of items to add.
   *
   * @return An array with deleted items.
   */
  function splice(arrayLike, start, deleteCount, ...args) {
      return arrayProto.splice.call(arrayLike, start, deleteCount, ...args);
  }

  /**
   * Returns the active element.
   * This is just an alias of `document.activeElement`.
   *
   * @return An active element.
   */
  function activeElement() {
      return document.activeElement;
  }

  /**
   * Toggles the provided class or classes by following the `add` boolean.
   *
   * @param elm     - An element whose classes are toggled.
   * @param classes - A class or class names.
   * @param add     - Whether to add or remove a class.
   */
  function toggleClass(elm, classes, add) {
      if (elm) {
          toArray(classes).forEach(name => {
              if (name) {
                  elm.classList[add ? 'add' : 'remove'](name);
              }
          });
      }
  }

  /**
   * Adds classes to the element.
   *
   * @param elm     - An element to add classes to.
   * @param classes - Classes to add.
   */
  function addClass(elm, classes) {
      toggleClass(elm, classes, true);
  }

  /**
   * Appends children to the parent element.
   *
   * @param parent   - A parent element.
   * @param children - A child or children to append to the parent.
   */
  function append(parent, children) {
      toArray(children).forEach(parent.appendChild.bind(parent));
  }

  /**
   * Iterates over the provided object by own enumerable keys with calling the iteratee function.
   *
   * @param object   - An object to iterate over.
   * @param iteratee - An iteratee function that takes the value and key as arguments.
   *
   * @return A provided object itself.
   */
  function forOwn$1(object, iteratee) {
      if (object) {
          const keys = Object.keys(object);
          for (let i = 0; i < keys.length; i++) {
              if (iteratee(object[keys[i]], keys[i]) === false) {
                  break;
              }
          }
      }
      return object;
  }

  /**
   * Assigns all own enumerable properties of all source objects to the provided object.
   * `undefined` in source objects will be skipped.
   *
   * @param object  - An object to assign properties to.
   * @param sources - Objects to assign properties from.
   *
   * @return An object assigned properties of the sources to.
   */
  function assign$1(object, ...sources) {
      sources.forEach(source => {
          if (isObject$1(source)) {
              forOwn$1(source, (value, key) => {
                  if (!isUndefined$1(source[key])) {
                      object[key] = source[key];
                  }
              });
          }
      });
      return object;
  }

  /**
   * Sets new attributes to the passed element if the `attrs` is an object literal,
   * or gets an attribute value from it if the `attrs` is a string.
   *
   * @param elm   - An element to set or get an attribute.
   * @param attrs - An attribute name as a string or new attributes as an object literal.
   */
  function attr(elm, attrs) {
      if (elm) {
          if (isString(attrs)) {
              return elm.getAttribute(attrs) || '';
          }
          if (isObject$1(attrs)) {
              forOwn$1(attrs, (value, key) => {
                  if (value === null) {
                      elm.removeAttribute(key);
                  }
                  else {
                      elm.setAttribute(key, String(value));
                  }
              });
          }
      }
  }

  /**
   * Inserts a node or nodes before the specified reference node.
   *
   * @param nodes - A node or nodes to insert.
   * @param ref   - A reference node.
   */
  function before$1(nodes, ref) {
      toArray(nodes).forEach(node => {
          if (node) {
              const parent = node.parentNode || (ref && ref.parentNode);
              if (parent) {
                  parent.insertBefore(node, ref);
              }
          }
      });
  }

  /**
   * Checks if the element matches the provided selector, or passes the predicate function.
   *
   * @since 0.1.0
   *
   * @param elm      - An element to test.
   * @param selector - A selector string to match.
   *
   * @return `true` if the element matches the selector.
   */
  function matches(elm, selector) {
      Element.prototype.matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
      return elm.matches(selector);
  }

  /**
   * With starting at the given element,
   * finds the closest parent element that matches the selector.
   *
   * @since 0.1.0
   *
   * @param elm      - A start element.
   * @param selector - A selector to search for.
   *
   * @return The closest element if found, or `null` if not.
   *
   * @throws TypeError
   */
  function closest(elm, selector) {
      if (isFunction(elm.closest)) {
          return elm.closest(selector);
      }
      while (elm) {
          if (matches(elm, selector)) {
              return elm;
          }
          elm = elm.parentElement;
      }
      return null;
  }

  /**
   * Creates a HTML element.
   *
   * @param tag    - A tag name.
   * @param attrs  - Optional. An object with attributes to apply the created element to, or a string with classes.
   * @param parent - Optional. A parent element where the created element is appended.
   */
  function create(tag, attrs, parent) {
      const elm = document.createElement(tag);
      if (attrs) {
          if (isString(attrs) || isArray(attrs)) {
              addClass(elm, attrs);
          }
          else {
              attr(elm, attrs);
          }
      }
      if (parent) {
          append(parent, elm);
      }
      return elm;
  }

  /**
   * The `create` function whose tag argument is fixed to `div`.
   *
   * @param attrs  - Optional. An object with attributes to apply the created element to, or a string with classes.
   * @param parent - Optional. A parent element where the created element is appended.
   */
  function div(attrs, parent) {
      return create('div', attrs, parent);
  }

  /**
   * Focuses the provided element without scrolling the ascendant element.
   *
   * @param elm - An element to focus.
   */
  function focus(elm) {
      if (isFunction(elm['setActive'])) {
          elm['setActive']();
      }
      else {
          elm.focus({ preventScroll: true });
      }
  }

  /**
   * Checks if the element contains the specified class or not.
   *
   * @param elm       - An element to check.
   * @param className - A class name that may be contained by the element.
   *
   * @return `true` if the element contains the class, or otherwise `false`.
   */
  function hasClass(elm, className) {
      return elm && elm.classList.contains(className);
  }

  /**
   * Returns client height of the element.
   *
   * @param elm - An element to get height.
   */
  function height(elm) {
      return elm.clientHeight;
  }

  /**
   * Sets or gets HTML of the provided element.
   *
   * @param elm - A element to get or set HTML.
   * @param html - Optional. HTML to set.
   */
  function html$2(elm, html) {
      if (elm) {
          if (isUndefined$1(html)) {
              return elm.innerHTML;
          }
          if (elm.innerHTML !== html) {
              elm.innerHTML = html;
          }
      }
  }

  /**
   * Checks if the default action of the event is prevented or not.
   *
   * @param e - An Event object.
   *
   * @return `true` if the default action is prevented, or otherwise `false`.
   */
  function isPrevented(e) {
      return e && e.defaultPrevented;
  }

  /**
   * Joins the provided object as a single line for DOM attributes.
   *
   * @param attrs - An object literal for attributes.
   *
   * @return A single string containing all attributes.
   */
  function joinAttrs(attrs) {
      let result = '';
      forOwn$1(attrs, (value, prop) => {
          if (prop && (value || value === false || value === 0)) {
              result += ` ${prop}="${value}"`;
          }
      });
      return result.trim();
  }

  /**
   * Stores registered handlers which has a key.
   *
   * @since 0.1.0
   */
  const handlerMap = new WeakMap();
  /**
   * Attaches a handler to the event.
   *
   * @param elm      - An element, a window or a document.
   * @param events   - An event name or names.
   * @param callback - A handler to attach.
   * @param key      - Optional. The key for identifying the registered handler.
   */
  function on(elm, events, callback, key) {
      events.split(' ').forEach(event => {
          elm.addEventListener(event, callback);
          if (key) {
              const handlers = handlerMap.get(key) || [];
              handlers.push({ elm, events, callback });
              handlerMap.set(key, handlers);
          }
      });
  }

  /**
   * Detaches a handler from the event or events.
   *
   * @param elm           - An element where events are removed.
   * @param events        - Optional. An event name or names.
   * @param callbackOrKey - Optional. A handler to remove or an object key.
   */
  function off(elm, events, callbackOrKey) {
      if (isFunction(callbackOrKey)) {
          events.split(' ').forEach(event => {
              elm.removeEventListener(event, callbackOrKey);
          });
      }
      else {
          const handlers = handlerMap.get(callbackOrKey);
          if (handlers) {
              handlers.forEach(handler => {
                  off(handler.elm, handler.events, handler.callback);
              });
              handlerMap.delete(callbackOrKey);
          }
      }
  }

  /**
   * Prepends children to the specified parent node.
   *
   * @param parent   - A parent node.
   * @param children - A child or children to prepend to the parent.
   */
  function prepend(parent, children) {
      toArray(children).forEach(child => {
          parent.insertBefore(child, parent.firstChild);
      });
  }

  /**
   * Call the `preventDefault()` of the provided event.
   *
   * @param e               - An Event object.
   * @param stopPropagation - Optional. Whether to stop the event propergation or not.
   */
  function prevent(e, stopPropagation) {
      if (e) {
          if (e.cancelable) {
              e.preventDefault();
          }
          if (stopPropagation) {
              e.stopPropagation();
          }
      }
  }

  /**
   * Returns an element that matches the provided selector.
   *
   * @param parent   - A parent element to start searching from.
   * @param selector - A selector to query.
   *
   * @return A found element or `null`.
   */
  function query(parent, selector) {
      return parent.querySelector(selector);
  }

  /**
   * Returns elements that match the provided selector.
   *
   * @param parent   - A parent element to start searching from.
   * @param selector - A selector to query.
   *
   * @return The NodeList object that contains matched elements.
   */
  function queryAll(parent, selector) {
      return parent.querySelectorAll(selector);
  }

  /**
   * Returns a DOMRect object of the provided element or the selection range.
   *
   * @param target - An element or a range instance.
   */
  function rect(target) {
      return target.getBoundingClientRect();
  }

  /**
   * Removes the provided node from its parent.
   *
   * @param nodes - A node or nodes to remove.
   */
  function remove(nodes) {
      toArray(nodes).forEach(node => {
          if (node && node.parentNode) {
              node.parentNode.removeChild(node);
          }
      });
  }

  /**
   * Removes classes from the element.
   *
   * @param elm     - An element to remove classes from.
   * @param classes - Classes to remove.
   */
  function removeClass(elm, classes) {
      toggleClass(elm, classes, false);
  }

  /**
   * Applies inline styles to the provided element by an object literal.
   *
   * @param elm    - An element to apply styles to.
   * @param styles - An object literal with styles.
   */
  function styles(elm, styles) {
      if (isString(styles)) {
          return getComputedStyle(elm)[styles];
      }
      forOwn$1(styles, (value, key) => {
          if (!isUndefined$1(value)) {
              elm.style[key] = String(value);
          }
      });
  }

  /**
   * Returns an open tag with provided classes.
   *
   * @param classes - Classes.
   * @param attrs   - Optional. An object with attributes.
   * @param tag     - Optional. A tag name.
   */
  function tag(classes, attrs = {}, tag) {
      return `<${tag || 'div'} ${joinAttrs(assign$1(attrs, {
        class: toArray(classes).filter(Boolean).join(' '),
    }))}>`;
  }

  /**
   * Sets or gets a text content of the provided node.
   *
   * @param node - A node to get or set a text.
   * @param text - Optional. A text to set.
   */
  function text(node, text) {
      if (node) {
          if (isUndefined$1(text)) {
              return node.textContent;
          }
          node.textContent = text;
      }
  }

  /**
   * Appends `px` to the value.
   * If the value is already string, just returns it.
   *
   * @param value - A value to append `px` to.
   */
  function unit(value) {
      return isString(value) ? value : `${value}px`;
  }

  /**
   * Checks if the client is Android or not.
   *
   * @return `true` if the client is Android, or otherwise `false`.
   */
  function isAndroid() {
      return /android/i.test(navigator.userAgent);
  }

  /**
   * Checks is the browser is based on the Gecko engine or not.
   *
   * @return `true` if the browser is the browser is based on the Gecko (Firefox), or otherwise `false`.
   */
  function isGecko() {
      return !!window['InstallTrigger'];
  }

  /**
   * Checks if the client is iOS or not.
   *
   * @return `true` if the client is iOS, or otherwise `false`.
   */
  function isIOS() {
      const { userAgent } = navigator;
      return /iPad|iPhone|iPod/.test(userAgent)
          || (userAgent.indexOf('Mac') > -1 && navigator.maxTouchPoints > 1);
  }

  /**
   * Checks is the browser is IE or not.
   *
   * @return `true` if the browser is IE, or otherwise `false`.
   */
  function isIE() {
      return /*@cc_on!@*/ !!document['documentMode'];
  }

  /**
   * Checks is the platform is Mac or not.
   *
   * @return `true` if the platform is Mac, or otherwise `false`.
   */
  function isMac() {
      return /Mac/i.test(navigator.platform);
  }

  /**
   * Checks if the device is likely mobile or not.
   *
   * @return `true` if the device is likely mobile, or otherwise `false`.
   */
  function isMobile() {
      return isAndroid() || isIOS();
  }

  /**
   * The project code.
   *
   * @since 0.1.0
   */
  const PROJECT_CODE = 'ryuseicode';
  /**
   * The abbreviated project code.
   *
   * @since 0.1.0
   */
  const PROJECT_CODE_SHORT = 'rc';

  /**
   * Throws an error if the provided condition is falsy.
   *
   * @param condition - If falsy, an error is thrown.
   * @param message   - Optional. A message to display.
   */
  function assert$1(condition, message = '') {
      if (!condition) {
          throw new Error(`[${PROJECT_CODE}] ${message}`);
      }
  }

  /**
   * Returns a function that invokes the provided function at most once in the specified duration.
   *
   * @since 0.1.0
   *
   * @param func        - A function to throttle.
   * @param interval    - A throttle duration in milliseconds.
   * @param initialCall - Optional. Determines whether to call the function initially.
   * @param debounce    - Optional. If `true`, the function returns a debounced function instead of throttled one.
   * @param raf         - Optional. Determines whether to use the `requestAnimationFrame` or not.
   *
   * @return A throttled function.
   */
  function throttle(func, interval, initialCall, debounce, raf) {
      let id;
      let invoker;
      function throttled(...args) {
          if (debounce) {
              cancel();
          }
          invoker = invoke.bind(this, ...args);
          if (!id) {
              if (isUndefined$1(id) && initialCall) {
                  invoker();
              }
              else {
                  id = raf ? requestAnimationFrame(invoker) : setTimeout(invoker, interval);
              }
          }
      }
      function invoke(...args) {
          func.apply(this, args);
          cancel();
      }
      function cancel() {
          raf ? cancelAnimationFrame(id) : clearTimeout(id);
          id = null;
      }
      throttled.cancel = cancel;
      throttled.invoke = () => {
          if (id) {
              invoker();
          }
      };
      return throttled;
  }

  /**
   * Returns a debounced function that invokes the provided function only after the internal timer expires.
   * The timer is reset whenever the debounced function is called.
   *
   * @param func     - A callback function.
   * @param duration - Debounce duration in milliseconds.
   *
   * @return A debounced function.
   */
  function debounce(func, duration) {
      return throttle(func, duration, false, true);
  }

  /**
   * Fires the provided function on the next tick.
   *
   * @param func - A function to call.
   */
  function nextTick(func) {
      setTimeout(func);
  }

  /**
   * Implements the `throttle` function via requestAnimationFrame.
   *
   * @param func - A function to throttle.
   * @param initialCall - Optional. Determines whether to call the function initially.
   *
   * @return A throttled function.
   */
  function rafThrottle(func, initialCall) {
      return throttle(func, 0, initialCall, false, true);
  }

  /**
   * The collection of forward arrow keys.
   *
   * @private
   * @since 0.1.0
   */
  const ARROW_FORWARD = [
      'ArrowDown',
      'ArrowRight',
  ];
  /**
   * The collection of backward arrow keys.
   *
   * @private
   * @since 0.1.0
   */
  const ARROW_BACKWARD = [
      'ArrowUp',
      'ArrowLeft',
  ];
  /**
   * The collection of all arrow keys.
   *
   * @private
   * @since 0.1.0
   */
  const ARROW_KEYS = [
      ...ARROW_FORWARD,
      ...ARROW_BACKWARD,
  ];
  /**
   * The map for normalizing differences of keys in browsers.
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values
   *
   * @private
   * @since 0.1.0
   */
  const NORMALIZATION_MAP = {
      Up: 'ArrowUp',
      Down: 'ArrowDown',
      Right: 'ArrowRight',
      Left: 'ArrowLeft',
      Del: 'Delete',
      Esc: 'Escape',
      Spacebar: ' ',
  };

  /**
   * Normalizes the provided key for different browsers.
   *
   * @param key - A key to normalize.
   */
  function normalizeKey(key) {
      return NORMALIZATION_MAP[key] || key;
  }

  /**
   * Checks if the keyboard event matches the provided matcher or not.
   *
   * @param e        - A KeyboardEvent object.
   * @param matchers - A KeyMatcher tuple or an array with matchers.
   *
   * @return `true` if the keyboard event satisfies the matcher, or otherwise `false`.
   */
  function matchesKey(e, matchers) {
      const key = normalizeKey(e.key).toUpperCase();
      return matchers && toArray(matchers, true).some(matcher => {
          return key === matcher[0].toUpperCase()
              && !matcher[1] === !e.ctrlKey
              && !matcher[2] === !e.shiftKey
              && !matcher[3] === !e.altKey;
      });
  }

  /**
   * Checks if the subject number is between `minOrMax` and `maxOrMin`.
   *
   * @param number    - A subject number to check.
   * @param minOrMax  - A min or max number.
   * @param maxOrMin  - A max or min number.
   * @param exclusive - Optional. Whether to exclude `x` or `y`.
   */
  function between(number, minOrMax, maxOrMin, exclusive) {
      const min = Math.min(minOrMax, maxOrMin);
      const max = Math.max(minOrMax, maxOrMin);
      return exclusive ? min < number && number < max : min <= number && number <= max;
  }

  const { max: max$1, min: min$1 } = Math;
  /**
   * Clamps a number.
   *
   * @param number - A subject number to check.
   * @param x      - A min or max number.
   * @param y      - A min or max number.
   */
  function clamp(number, x, y) {
      const minimum = min$1(x, y);
      const maximum = max$1(x, y);
      return min$1(max$1(minimum, number), maximum);
  }

  const { min, max, floor, ceil, abs, round } = Math;

  /**
   * Compares the provided 2 positions.
   *
   * @return If the `position1` is preceding, returns a negative number,
   *         or if it is following, returns a positive one. If they are same, returns `0`.
   */
  function compare(position1, position2) {
      return position1[0] - position2[0] || position1[1] - position2[1];
  }

  /**
   * The alias of document.createRange.
   * The Range constructor is not supported by IE.
   *
   * @since 0.1.0
   */
  const createRange = document.createRange.bind(document);

  /**
   * The alias of window.getSelection.
   *
   * @since 0.1.0
   */
  const getSelection = window.getSelection;

  /**
   * Finds a node that the offset number belongs to.
   *
   * @param elm    - An element to find in.
   * @param offset - An offset index.
   *
   * @return An object that contains a found node and a offset number.
   */
  function findSelectionBoundary(elm, offset) {
      const children = elm.childNodes;
      if (!children.length && !offset) {
          return { node: elm, offset: 0 };
      }
      if (offset <= elm.textContent.length) {
          for (let i = 0; i < children.length; i++) {
              const node = children[i];
              const length = node.textContent.length;
              if (isText(node)) {
                  if (offset <= length) {
                      return { node, offset };
                  }
              }
              else if (node instanceof Element) {
                  const found = findSelectionBoundary(node, offset);
                  if (found) {
                      return found;
                  }
              }
              offset -= length;
          }
      }
      return null;
  }

  /**
   * Sets a selection by an anchor and a focus object.
   * Note that the Range constructor does not supported by IE.
   *
   * @param anchor - An anchor boundary object.
   * @param focus  - A focus boundary object.
   */
  function setSelection(anchor, focus) {
      if (anchor && focus) {
          const selection = getSelection();
          if (selection.setBaseAndExtent) {
              selection.setBaseAndExtent(anchor.node, anchor.offset, focus.node, focus.offset);
          }
          else {
              const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : document.createRange();
              range.setStart(anchor.node, anchor.offset);
              range.setEnd(focus.node, focus.offset);
              selection.removeAllRanges();
              selection.addRange(range);
          }
      }
  }

  /**
   * Converts the provided string in the camel case to the kebab case.
   *
   * @param string - A string to convert.
   */
  function camelToKebab(string) {
      return string.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
  }

  /**
   * Counts the search string occurrence in the provided sting.
   *
   * @param string - A string to search in.
   * @param search - A string to search for.
   * @param from   - An index to search from.
   * @param to     - An index to search to.
   *
   * @return A number of occurrence.
   */
  function count(string, search, from = 0, to = string.length) {
      if (from || to !== string.length) {
          string = string.slice(from, to);
      }
      return (string.match(new RegExp(search, 'g')) || []).length;
  }

  /**
   * Checks if the string ends with the `search` string or not.
   *
   * @param string - A string to check.
   * @param search - A string to search.
   *
   * @return `true` if the string ends with the `search`, or otherwise `false`.
   */
  function endsWith(string, search) {
      return string.slice(-search.length) === search;
  }

  /**
   * Converts essential HTML special characters to HTML entities.
   *
   * @param string - A string to escape.
   *
   * @return An escaped string.
   */
  function escapeHtml(string) {
      return string.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  /**
   * Escapes string for the RegExp source.
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
   *
   * @param string - A string to escape.
   */
  function escapeRegExp(string) {
      return string.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * Formats a string.
   *
   * @param string       - A string to format.
   * @param replacements - A replacement or replacements.
   *
   * @return A formatted string.
   */
  function format(string, ...replacements) {
      for (let i = 0; i < replacements.length; i++) {
          string = string.replace('%s', String(replacements[i]));
      }
      return string;
  }

  /**
   * Returns the index within the provided string of the nth occurrence.
   * The optional `from` index determines the start position to search the target from.
   *
   * @param string - A string to search in.
   * @param search - A string to search startsWith
   * @param nth    - A number of the occurrence.
   * @param from   - Optional. A start index to search from.
   *
   * @return An index if the nth occurrence of the `search` string is found, or `-1` if not.
   */
  function nthIndexOf(string, search, nth, from = 0) {
      let index = from - 1;
      let count = nth;
      while ((index !== -1 || nth === count) && count--) {
          index = string.indexOf(search, index + 1);
      }
      return index;
  }

  /**
   * Returns a new string filled with a number of copies of the provided string.
   *
   * @param string - A string to repeat.
   * @param count  - An integer for determining the number of repeats.
   *
   * @return A new string containing copies of the provided string.
   */
  function repeat(string, count) {
      if (!String.prototype.repeat) {
          let result = '';
          while (count > 0) {
              if (count % 2) {
                  result += string;
              }
              count = floor(count / 2);
              string += string;
          }
          return result;
      }
      return string.repeat(count);
  }

  /**
   * Checks if the string starts with the `search` string or not.
   *
   * @param string - A string to check.
   * @param search - A string to search.
   *
   * @return `true` if the string starts with the `search`, or otherwise `false`.
   */
  function startsWith$1(string, search) {
      return string.slice(0, search.length) === search;
  }

  const ids = {};
  /**
   * Returns a sequential unique ID as "{ prefix }-{ number }".
   *
   * @param prefix - A prefix for the ID.
   */
  function uniqueId(prefix) {
      const number = (ids[prefix] || 0) + 1;
      const idNumber = number < 10 ? `0${number}` : number;
      ids[prefix] = number;
      return `${prefix}${idNumber}`;
  }

  /**
   * The base class for a component.
   *
   * @since 0.1.0
   */
  class Component {
      /**
       * The Component constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          this.Editor = Editor;
          this.event = Editor.event;
          this.options = Editor.options;
          this.language = Editor.language;
      }
      /**
       * Called when the component is mounted.
       *
       * @param elements - A collection of editor elements.
       */
      mount(elements) {
          this.elements = elements;
          forOwn$1(this.Editor.Components, (Component, key) => {
              this[key] = Component;
          });
      }
      /**
       * Called when the editor is destroyed.
       *
       * @internal
       */
      destroy() {
          off(null, '', this);
      }
      /**
       * Attaches an event handler with passing this instance as a key.
       * All handlers can only be detached by the `off()` method below.
       *
       * @param events   - An event name or names.
       * @param callback - A callback function.
       * @param thisArg  - Optional. Specifies the `this` parameter of the callback function.
       * @param priority - Optional. A priority number for the order in which the callbacks are invoked.
       */
      on(events, callback, thisArg, priority) {
          this.event.on(events, thisArg ? callback.bind(thisArg) : callback, this, priority);
      }
      /**
       * Detaches event handlers registered by `on()` without removing other handlers.
       *
       * @param events - An event name or names.
       */
      off(events) {
          this.event.off(events, this);
      }
      /**
       * Triggers callback functions.
       *
       * @param event - An event name.
       * @param args  - Optional. Any number of arguments to pass to callback functions.
       */
      emit(event, ...args) {
          this.event.emit(event, ...args);
      }
      /**
       * Listens to native events.
       * All handlers will be stored for destruction.
       *
       * @param elm      - A document, a window or an element.
       * @param events   - An event name or names.
       * @param callback - A callback function.
       * @param thisArg  - Optional. Specifies the `this` parameter of the callback function.
       */
      bind(elm, events, callback, thisArg) {
          on(elm, events, thisArg ? callback.bind(thisArg) : callback, this);
      }
      /**
       * Returns a Language or LanguageConfig object at the specified position.
       *
       * @param position - Optional. A position.
       *
       * @return A main Language object or sub language config object.
       */
      getLanguage(position) {
          position = position || this.Selection.get().start;
          const { language } = this;
          const info = this.lines.getInfoAt(position);
          if (info && info.language && language.use && language.use[info.language]) {
              return language.use[info.language].config;
          }
          return language;
      }
      /**
       * Attempts to invoke the method of the specified extension.
       *
       * @param name   - A name of the extension.
       * @param method - A method name to invoke.
       * @param args   - Optional. Arguments for the method.
       *
       * @return The return value of the method.
       */
      invoke(name, method, ...args) {
          return this.Editor.invoke(name, method, ...args);
      }
      /**
       * Returns the extension of the specified name.
       *
       * @param name - A name of an extension.
       *
       * @return An extension if found, or otherwise `undefined`.
       */
      require(name) {
          return this.Editor.require(name);
      }
      /**
       * Adds default icon strings. They can be still overridden by options.
       *
       * @param icons - Additional icon strings.
       */
      addIcons(icons) {
          const { options } = this;
          options.icons = assign$1({}, icons, options.icons);
      }
      /**
       * Adds default i18n strings. They can be still overridden by options.
       *
       * @param i18n - Additional i18n strings.
       */
      addI18n(i18n) {
          const { options } = this;
          options.i18n = assign$1({}, i18n, options.i18n);
      }
      /**
       * Adds default shortcuts to the keymap object. They can be still overridden by options.
       *
       * @param shortcuts - Additional shortcuts.
       */
      addKeyBindings(shortcuts) {
          const { options } = this;
          options.keymap = assign$1({}, shortcuts, options.keymap);
      }
      /**
       * Returns options for each component with merging default values.
       * If the returned value is `null`, that means the component should not be active.
       *
       * @param name     - An option name.
       * @param defaults - Default values.
       *
       * @return A merged options, or `null`.
       */
      getOptions(name, defaults) {
          const options = this.options[name];
          if (isUndefined$1(options) || options === true) {
              return defaults || {};
          }
          if (isObject$1(options)) {
              return assign$1({}, defaults, options);
          }
          assert$1(false);
      }
      /**
       * Returns the latest Lines instance.
       *
       * @return The Lines instance.
       */
      get lines() {
          return this.Code.Lines;
      }
      /**
       * Returns the i18n collection.
       *
       * @return The object with i18n strings.
       */
      get i18n() {
          return this.options.i18n;
      }
  }

  const CLASS_ROOT = PROJECT_CODE;
  const CLASS_BODY = `${PROJECT_CODE}__body`;
  const CLASS_SCROLLER = `${PROJECT_CODE}__scroller`;
  const CLASS_CONTAINER = `${PROJECT_CODE}__container`;
  const CLASS_EDITOR = `${PROJECT_CODE}__editor`;
  const CLASS_SCROLLBARS = `${PROJECT_CODE}__scrollbars`;
  const CLASS_SCROLLBAR = `${PROJECT_CODE}__scrollbar`;
  const CLASS_LINES = `${PROJECT_CODE}__lines`;
  const CLASS_LINE = `${PROJECT_CODE}__line`;
  const CLASS_SOURCE = `${PROJECT_CODE}__source`;
  const CLASS_BACKGROUND = `${PROJECT_CODE}__background`;
  const CLASS_CARETS = `${PROJECT_CODE}__carets`;
  const CLASS_CARET = `${PROJECT_CODE}__caret`;
  const CLASS_MARKERS = `${PROJECT_CODE}__markers`;
  const CLASS_MARKER = `${PROJECT_CODE}__marker`;
  const CLASS_OVERLAY = `${PROJECT_CODE}__overlay`;
  const CLASS_CONTEXT_MENU = `${PROJECT_CODE}__context-menu`;
  const CLASS_CONTEXT_MENU_GROUP = `${CLASS_CONTEXT_MENU}__group`;
  const CLASS_CONTEXT_MENU_LIST = `${CLASS_CONTEXT_MENU}__list`;
  const CLASS_CONTEXT_MENU_ITEM = `${CLASS_CONTEXT_MENU}__item`;
  const CLASS_CONTEXT_MENU_BUTTON = `${CLASS_CONTEXT_MENU}__button`;
  const CLASS_CONTEXT_MENU_LABEL = `${CLASS_CONTEXT_MENU_BUTTON}__label`;
  const CLASS_CONTEXT_MENU_SHORTCUT = `${CLASS_CONTEXT_MENU_BUTTON}__shortcut`;
  const CLASS_TOKEN = `${PROJECT_CODE}__token`;
  const CLASS_INPUT = `${PROJECT_CODE}__input`;
  const CLASS_BUTTON = `${PROJECT_CODE}__button`;
  const CLASS_ICON = `${PROJECT_CODE}__icon`;
  const CLASS_PLACEHOLDER = `${PROJECT_CODE}__placeholder`;
  const CLASS_ACTIVE = 'is-active';
  const CLASS_RENDERED = 'is-rendered';
  const CLASS_INITIALIZED = 'is-initialized';
  const CLASS_ANCHOR = 'is-anchor';
  const CLASS_FOCUS = 'is-focus';
  const CLASS_PRESERVED = 'is-preserved';
  const CLASS_FOCUSED = 'is-focused';
  const CLASS_READONLY = 'is-readonly';
  const CLASS_DRAGGING = 'is-dragging';
  const CLASS_EMPTY = 'is-empty';
  const CLASS_MOBILE = 'is-mobile';

  const EVENT_MOUNT = 'mount';
  const EVENT_MOUNTED = 'mounted';
  const EVENT_FOCUS = 'focus';
  const EVENT_BLUR = 'blur';
  const EVENT_READONLY = 'readOnly';
  const EVENT_KEYDOWN = 'keydown';
  const EVENT_INPUT = 'input';
  const EVENT_NEWLINE = 'newline';
  const EVENT_CHANGE = 'change';
  const EVENT_CHANGED = 'changed';
  const EVENT_COMPOSITION_START = 'compositionStart';
  const EVENT_COMPOSITION_UPDATE = 'compositionUpdate';
  const EVENT_COMPOSITION_END = 'compositionEnd';
  const EVENT_ANCHOR_LINE_CHANGED = 'anchorLineChanged';
  const EVENT_FOCUS_LINE_CHANGED = 'focusLineChanged';
  const EVENT_COPY = 'copy';
  const EVENT_CUT = 'cut';
  const EVENT_PASTE = 'paste';
  const EVENT_KEYMAP = 'keymap';
  const EVENT_CHUNK_MOVED = 'chunkMoved';
  const EVENT_CHUNK_SUPPLIED = 'chunkSupplied';
  const EVENT_SELECTING = 'selecting';
  const EVENT_SELECTED = 'selected';
  const EVENT_SELECTION_CHANGE = 'selectionChanged';
  const EVENT_SCROLL = 'scroll';
  const EVENT_SCROLLED = 'scrolled';
  const EVENT_SCROLLER_SCROLL = 'scrollerScroll';
  const EVENT_WINDOW_SCROLL = 'windowScroll';
  const EVENT_RESIZE = 'resize';
  const EVENT_SCROLL_WIDTH_CHANGED = 'scrollWidthChanged';
  const EVENT_SCROLL_HEIGHT_CHANGED = 'scrollHeightChanged';
  const EVENT_SYNCED = 'synced';
  const EVENT_CONTEXT_MENU_OPENED = 'contextMenuOpened';
  const EVENT_CONTEXT_MENU_CLOSED = 'contextMenuClosed';
  const EVENT_CONTEXT_MENU_CLICKED = 'contextMenuClicked';
  const EVENT_RESET = 'reset';
  const EVENT_INIT_STYLE = 'initStyle';
  const EVENT_FONT_LOADED = 'fontLoaded';
  const EVENT_DESTROYED = 'destroyed';

  /**
   * The editor is not active.
   */
  const IDLE = 0;
  /**
   * The selection is collapsed.
   */
  const COLLAPSED = 1;
  /**
   * The selection will change soon. The native selection has not been updated at this timing.
   */
  const START = 2;
  /**
   * The selection has just changed after the `START` state. The native selection has been updated.
   */
  const CHANGED = 3;
  /**
   * The selection has been programmatically updated.
   */
  const UPDATE = 4;
  /**
   * An user is selecting a document.
   */
  const SELECTING = 5;
  /**
   * The existing selection is being extended.
   */
  const EXTEND = 6;
  /**
   * User finishes the selection. The native selection has not been updated at this timing (in FF).
   */
  const END = 7;
  /**
   * The selection is settled and it is not collapsed.
   */
  const SELECTED = 8;
  /**
   * The selection is right-clicked.
   */
  const CLICKED_RIGHT = 10;

  /**
   * The offset amount for the horizontal position of the caret.
   *
   * @since 0.1.0
   */
  const HORIZONTAL_OFFSET = -1;
  /**
   * The debounce duration for the `blink` method.
   *
   * @since 0.1.0
   */
  const BLINK_DEBOUNCE_DURATION = 30;
  /**
   * The class for creating and controlling the caret element.
   *
   * @since 0.1.0
   */
  class CustomCaret {
      /**
       * The Caret constructor.
       *
       * @param Editor - An Editor instance.
       * @param id     - An ID for the caret.
       * @param parent - A parent element where the caret is appended.
       */
      constructor(Editor, id, parent) {
          this.Editor = Editor;
          this.caret = div([CLASS_CARET, `${CLASS_CARET}--${id}`], parent);
          this.blink = debounce(this.blink.bind(this), BLINK_DEBOUNCE_DURATION);
          Editor.event.on(EVENT_RESIZE, () => {
              if (this.position) {
                  this.move(this.position);
              }
          });
      }
      /**
       * Moves the caret to the specified position.
       *
       * @param position - A position to set as [ row, col ].
       */
      move(position) {
          const { Measure } = this.Editor.Components;
          const rect = Measure.getOffset(position);
          styles(this.caret, {
              top: unit(rect.top),
              left: unit(rect.left + HORIZONTAL_OFFSET),
              animation: 'none',
          });
          this.blink();
          this.position = position;
      }
      /**
       * Displays the caret.
       */
      show() {
          addClass(this.caret, CLASS_ACTIVE);
      }
      /**
       * Hides teh caret.
       */
      hide() {
          removeClass(this.caret, CLASS_ACTIVE);
      }
      /**
       * Starts the blink animation by removing the `none` value from the `animation`.
       */
      blink() {
          styles(this.caret, { animation: '' });
      }
  }

  /**
   * The ID of the primary caret.
   *
   * @since 0.1.0
   */
  const PRIMARY_CARET_ID = 'primary';
  /**
   * The component for generating and handling carets.
   *
   * @since 0.1.0
   */
  class Caret extends Component {
      constructor() {
          super(...arguments);
          /**
           * Stores the all registered Caret instances.
           */
          this.carets = {};
      }
      /**
       * Mounts the component.
       * Uses the native caret on IE and mobile devices.
       *
       * @param elements - A collection of essential editor elements.
       */
      mount(elements) {
          super.mount(elements);
          this.create();
          if (!isIE() && !isMobile()) {
              this.register(PRIMARY_CARET_ID);
              this.primary = this.get(PRIMARY_CARET_ID);
              this.listen();
          }
      }
      /**
       * Creates a wrapper element that contains carets.
       */
      create() {
          this.wrapper = div({
              class: CLASS_CARETS,
              role: 'presentation',
              'aria-hidden': true,
          }, this.elements.editor);
      }
      /**
       * Listens to some events.
       */
      listen() {
          const { editable } = this.elements;
          const { primary, Editor } = this;
          this.bind(editable, 'focus', () => {
              if (!Editor.readOnly) {
                  primary.show();
              }
          });
          this.bind(editable, 'blur', () => {
              primary.hide();
          });
          this.update = rafThrottle(this.update.bind(this), true);
          this.on(EVENT_READONLY, (e, readOnly) => {
              if (readOnly) {
                  primary.hide();
              }
              else {
                  if (Editor.isFocused()) {
                      this.update();
                      primary.show();
                  }
              }
          });
          this.on(EVENT_SELECTED, this.onSelected, this);
          this.on(EVENT_SELECTING, this.update);
      }
      /**
       * Called when the selection state is changed.
       *
       * @param e         - An EventBusEvent object.
       * @param Selection - A Selection instance.
       */
      onSelected(e, Selection) {
          if (!this.Editor.readOnly) {
              if (Selection.is(CHANGED, COLLAPSED, SELECTED)) {
                  this.update();
              }
          }
      }
      /**
       * Updates the primary caret position on the animation frame.
       */
      update() {
          this.primary.move(this.Selection.get(false).end);
      }
      /**
       * Registers a new caret.
       *
       * @param id - The ID for the caret to register.
       *
       * @return The registered CustomCaret instance.
       */
      register(id) {
          const { carets } = this;
          assert$1(!carets[id]);
          const caret = new CustomCaret(this.Editor, id, this.wrapper);
          carets[id] = caret;
          return caret;
      }
      /**
       * Returns the primary or the specific CustomCaret instance.
       *
       * @param id - Optional. A caret ID.
       *
       * @return A CustomCaret instance if available, or otherwise `undefined`.
       */
      get(id = PRIMARY_CARET_ID) {
          return this.carets[id];
      }
      /**
       * Returns the DOMRect object of the primary caret.
       *
       * @return A DOMRect object.
       */
      get rect() {
          return this.Selection.getRect(true);
      }
  }

  /**
   * Debounce duration for invoking the `scrollEnd()`.
   * This must not be less than the native scroll interval.
   *
   * @since 0.1.0
   */
  const SCROLL_END_DEBOUNCE_DURATION = 60;
  /**
   * The number of lines for margin.
   *
   * @since 0.1.0
   */
  const MARGIN_LINES = 10;

  /**
   * The class for handling line elements.
   *
   * @since 0.1.0
   */
  class Chunk extends Component {
      constructor() {
          super(...arguments);
          /**
           * Indicates what row corresponds with the first line element.
           * The number can be negative.
           */
          this.start = 0;
          /**
           * The number of lines for margin.
           */
          this.margin = MARGIN_LINES;
          /**
           * The current offset amount from the top in pixel.
           */
          this.offsetY = 0;
          /**
           * The anchor line data.
           */
          this.anchor = {};
          /**
           * The focus line data.
           */
          this.focus = {};
          /**
           * Holds the previous scroll position.
           */
          this.scrollTop = 0;
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential editor elements.
       */
      mount(elements) {
          super.mount(elements);
          const { scroller } = elements;
          this.scroller = scroller;
          this.parent = elements.lines;
          this.scrollTop = window.pageYOffset + scroller.scrollTop;
          this.active = this.isVisible();
          this.onScrolled = debounce(this.onScrolled.bind(this), SCROLL_END_DEBOUNCE_DURATION);
          this.supply();
          this.remove();
          this.listen();
      }
      /**
       * Listens to some events.
       */
      listen() {
          const onScroll = rafThrottle(this.onScroll.bind(this));
          this.bind(this.scroller, 'scroll', () => {
              onScroll(true);
              this.emit(EVENT_SCROLLER_SCROLL);
          });
          this.bind(window, 'scroll', () => {
              onScroll(false);
              this.emit(EVENT_WINDOW_SCROLL);
          });
          this.bind(window, 'scroll', rafThrottle(() => {
              this.active = this.isVisible();
              this.borderCache = null;
          }));
          this.on(EVENT_RESIZE, () => {
              this.borderCache = null;
              this.reposition();
          });
          this.on(EVENT_SCROLL_HEIGHT_CHANGED, () => {
              this.supply();
              this.borderCache = null;
          });
          this.on(EVENT_SELECTED, this.onSelected, this, 0);
          this.on(EVENT_SELECTING, () => {
              this.activate(true);
              if (this.focusChanged) {
                  this.emitChangedEvent(true);
              }
          });
      }
      /**
       * Called whenever the selection state changes.
       *
       * @param e         - An EventBusEvent object.
       * @param Selection - A Selection instance.
       */
      onSelected(e, Selection) {
          if (Selection.is(COLLAPSED, CHANGED)) {
              this.activate(true);
              this.activate(false);
              if (this.anchorChanged) {
                  this.emitChangedEvent(false);
              }
              if (this.focusChanged) {
                  this.emitChangedEvent(true);
              }
          }
      }
      /**
       * Called whenever the editor scrolls.
       * Be aware that the `scrollY` property is not supported in IE.
       *
       * @return byScroller - Indicates whether the editor is scrolled by the editor element itself or the window.
       */
      onScroll(byScroller) {
          const top = window.pageYOffset + this.scroller.scrollTop;
          if (this.active) {
              const { scrollTop } = this;
              if (scrollTop < top) {
                  this.moveDown();
              }
              else if (scrollTop > top) {
                  this.moveUp();
              }
              this.emit(EVENT_SCROLL, true);
              this.onScrolled(byScroller);
          }
          this.scrollTop = top;
      }
      /**
       * Called the scroll likely ends.
       *
       * @return byScroller - Indicates whether the editor is scrolled by the editor element itself or the window.
       */
      onScrolled(byScroller) {
          this.emit(EVENT_SCROLLED, byScroller);
      }
      /**
       * Activates the anchor or focus line.
       * - If the selection is collapsed outside of the view,
       *   the anchor and focus lines are merged into a single boundary line.
       * - If the line is not available but there is a boundary,
       *   that means the boundary has been added manually by the Selection component.
       *
       * @param focus - Determines whether to activate focus or anchor line.
       */
      activate(focus) {
          const className = focus ? CLASS_FOCUS : CLASS_ANCHOR;
          const row = this.Selection.get(false)[focus ? 'end' : 'start'][0];
          const boundary = this.getBoundary(focus);
          let line = this.getLine(row);
          if (!line) {
              const anotherBoundary = this.getBoundary(!focus);
              if (anotherBoundary.row === row) {
                  line = anotherBoundary.line;
              }
          }
          if (line) {
              if (!hasClass(line, className)) {
                  this.deactivate(focus);
                  addClass(line, className);
                  assign$1(boundary, { line, row });
                  this.setBoundaryChanged(focus, true);
              }
          }
      }
      /**
       * Deactivates the anchor or focus line if it is changed.
       *
       * @param focus - Determines whether to deactivate focus or anchor line.
       */
      deactivate(focus) {
          const boundary = this.getBoundary(focus);
          const { line } = boundary;
          if (line) {
              if (hasClass(line, CLASS_PRESERVED) && !hasClass(line, focus ? CLASS_ANCHOR : CLASS_FOCUS)) {
                  remove(line);
              }
              else {
                  removeClass(line, focus ? CLASS_FOCUS : CLASS_ANCHOR);
              }
              boundary.line = null;
              boundary.row = null;
          }
      }
      /**
       * Emits the `changed` event for an anchor or focus line.
       *
       * @param focus - Determines whether to emit the event for the focus or anchor line.
       */
      emitChangedEvent(focus) {
          const boundary = this.getBoundary(focus);
          assert$1(boundary.line);
          this.emit(focus ? EVENT_FOCUS_LINE_CHANGED : EVENT_ANCHOR_LINE_CHANGED, boundary.line, boundary.row);
          if (focus) {
              this.focusChanged = false;
          }
          else {
              this.anchorChanged = false;
          }
      }
      /**
       * Sets the `anchorChanged` or `focusChanged` property.
       *
       * @param focus   - Determines which property should be changed.
       * @param changed - The value for the property.
       */
      setBoundaryChanged(focus, changed) {
          if (focus) {
              this.focusChanged = changed;
          }
          else {
              this.anchorChanged = changed;
          }
      }
      /**
       * Supplies line elements so that they can fill the viewport.
       */
      supply() {
          const { lineHeight, scrollerRect } = this.Measure;
          const maxHeight = min(scrollerRect.height, window.innerHeight);
          const visibleLines = ceil(maxHeight / lineHeight);
          const totalLength = visibleLines + this.margin * 2;
          if (visibleLines !== this.visibleLines) {
              const { elms } = this;
              const { length } = elms;
              const diff = totalLength - length;
              if (diff > 0) {
                  this.html(this.start + length, diff, 'beforeend');
                  this.emit(EVENT_CHUNK_SUPPLIED, this, diff);
              }
              this.visibleLines = visibleLines;
          }
      }
      /**
       * Removes unnecessary lines.
       */
      remove() {
          const { elms, length } = this;
          if (elms.length > length) {
              remove(elms.slice(length - elms.length));
          }
      }
      /**
       * Returns a HTML string of lines.
       *
       * @param start  - A start row index.
       * @param length - A number of lines.
       * @param where  - Optional. If provided, built HTML will be inserted to the parent by the `insertAdjacentHTML`.
       *
       * @return A built HTML.
       */
      html(start, length, where) {
          let html = '';
          for (let i = 0; i < length; i++) {
              const row = start + i;
              const line = this.lines[row];
              html += tag([CLASS_LINE, line ? '' : CLASS_EMPTY]);
              html += line ? line.html : '';
              html += '</div>';
          }
          if (where) {
              this.parent.insertAdjacentHTML(where, html);
          }
          return html;
      }
      /**
       * Moves down elements which are outside of the border.
       */
      moveDown() {
          const lengthToMove = this.computeLengthToMoveDown();
          if (lengthToMove >= this.length) {
              this.jumpIntoView();
          }
          else if (lengthToMove > 0) {
              const { lineHeight } = this.Measure;
              this.offsetY += lineHeight * lengthToMove;
              if (this.start < 0) {
                  this.offsetY = max(this.offsetY + this.start * lineHeight, 0);
              }
              const { elms } = this;
              const html = this.html(this.start + elms.length, lengthToMove);
              elms[elms.length - 1].insertAdjacentHTML('afterend', html);
              remove(this.detach(0, lengthToMove));
              this.start += lengthToMove;
              this.attach();
              this.offset();
              this.emit(EVENT_CHUNK_MOVED, this);
          }
      }
      /**
       * Moves up elements which are outside of the border.
       */
      moveUp() {
          const lengthToMove = this.computeLengthToMoveUp();
          if (lengthToMove >= this.length) {
              this.jumpIntoView();
          }
          else if (lengthToMove > 0) {
              const { lineHeight } = this.Measure;
              remove(this.detach(-lengthToMove));
              const { elms } = this;
              const html = this.html(this.start - lengthToMove, lengthToMove);
              elms[0].insertAdjacentHTML('beforebegin', html);
              this.start -= lengthToMove;
              this.offsetY = max(this.offsetY - lineHeight * lengthToMove, 0);
              this.attach();
              this.offset();
              this.emit(EVENT_CHUNK_MOVED, this);
          }
      }
      /**
       * Computes the number of lines to move down.
       *
       * @return A number of lines to move down.
       */
      computeLengthToMoveDown() {
          if (this.end < this.lines.length) {
              const { Measure: { lineHeight }, margin } = this;
              const { top } = rect(this.parent);
              const border = this.border[0];
              if (top + lineHeight * margin < border) {
                  return floor((border - top) / lineHeight);
              }
          }
          return 0;
      }
      /**
       * Computes the number of lines to move up.
       *
       * @return A number of lines to move up.
       */
      computeLengthToMoveUp() {
          if (this.start > 0) {
              const { Measure: { lineHeight, padding: { bottom: paddingBottom } }, margin } = this;
              const { top, bottom } = rect(this.parent);
              const [topBorder, bottomBorder] = this.border;
              if (top > topBorder) {
                  return margin + floor((top - topBorder) / lineHeight);
              }
              if (bottom - lineHeight * margin - paddingBottom > bottomBorder) {
                  return floor((bottom - paddingBottom - bottomBorder) / lineHeight);
              }
          }
          return 0;
      }
      /**
       * Detaches lines in the specified lines from the chunk.
       * Both anchor and focus lines will be preserved, and others will be returned.
       *
       * @param start - A start index.
       * @param end   - An end index.
       *
       * @return An array with detached elements.
       */
      detach(start, end) {
          return this.elms.slice(start, end).reduce((detached, elm) => {
              const isAnchor = hasClass(elm, CLASS_ANCHOR);
              const isFocus = hasClass(elm, CLASS_FOCUS);
              if (isAnchor || isFocus) {
                  addClass(elm, CLASS_PRESERVED);
                  attr(elm, { 'aria-hidden': true });
              }
              else {
                  detached.push(elm);
              }
              return detached;
          }, []);
      }
      /**
       * Attaches detached anchor and focus lines to the chunk.
       * Do not move the anchor and focus lines to keep the native selection.
       */
      attach() {
          const { Selection, anchor: { line: anchorLine }, focus: { line: focusLine } } = this;
          const { anchor, focus } = Selection;
          const includesAnchor = this.includes(anchor[0]);
          const includesFocus = this.includes(focus[0]);
          const includesPreservedAnchor = includesAnchor && hasClass(anchorLine, CLASS_PRESERVED);
          const includesPreservedFocus = includesFocus && hasClass(focusLine, CLASS_PRESERVED);
          if (includesPreservedAnchor || includesPreservedFocus) {
              const anchorIndex = includesAnchor ? anchor[0] - this.start : -1;
              const focusIndex = includesFocus ? focus[0] - this.start : -1;
              const firstIndex = min(anchorIndex, focusIndex);
              const secondIndex = max(anchorIndex, focusIndex);
              const backward = Selection.isBackward();
              let firstElm, secondElm;
              if (firstIndex > -1) {
                  firstElm = backward ? focusLine : anchorLine;
                  secondElm = backward ? anchorLine : focusLine;
              }
              else {
                  secondElm = includesAnchor ? anchorLine : focusLine;
              }
              const { elms } = this;
              const topElms = firstElm ? elms.slice(0, firstIndex) : elms.slice(0, secondIndex);
              const middleElms = firstElm ? elms.slice(firstIndex + 1, secondIndex) : [];
              const bottomElms = elms.slice(secondIndex + 1);
              if (includesPreservedAnchor) {
                  removeClass(anchorLine, CLASS_PRESERVED);
                  attr(anchorLine, { 'aria-hidden': null });
                  remove(elms[anchorIndex]);
              }
              if (includesPreservedFocus && anchorIndex !== focusIndex) {
                  removeClass(focusLine, CLASS_PRESERVED);
                  attr(focusLine, { 'aria-hidden': null });
                  remove(elms[focusIndex]);
              }
              before$1(topElms, firstElm || secondElm);
              before$1(middleElms, secondElm);
              const { nextElementSibling } = secondElm;
              if (bottomElms.length && bottomElms[0] !== nextElementSibling) {
                  before$1(bottomElms, nextElementSibling);
              }
          }
      }
      /**
       * Offsets the parent element to make it visible inside the viewport.
       *
       * @param offsetY - Optional. Amount of the offset. If empty, the current `offsetY` will be used.
       */
      offset(offsetY = this.offsetY) {
          this.parent.style.top = `${offsetY}px`;
      }
      /**
       * Makes the chunk jump so that it is visible in the view.
       */
      jumpIntoView() {
          this.jump(this.Measure.closest(this.scroller.scrollTop));
      }
      /**
       * Repositions the chunk to the current scroll top position.
       */
      reposition() {
          const top = this.Measure.getTop(this.start);
          if (top !== this.offsetY) {
              const focusRow = this.focus.row;
              const includesFocus = this.includes(focusRow);
              this.jumpIntoView();
              if (includesFocus) {
                  this.View.jump(focusRow);
              }
          }
      }
      /**
       * Checks if the part of the scroller element is vertically visible or not.
       * This method does not care the horizontal visibility.
       *
       * @return `true` if the scroller is visible, or otherwise `false`.
       */
      isVisible() {
          const { top, bottom } = rect(this.scroller);
          const { innerHeight } = window;
          return between(top, 0, innerHeight) || between(bottom, 0, innerHeight) || top < 0 && bottom > innerHeight;
      }
      /**
       * Jumps to the specified row index.
       * Use `View#jump()` instead if you want to scroll to the specific line.
       *
       * @param row - A row to jump to.
       */
      jump(row) {
          const { Measure, length } = this;
          const { padding: { top: paddingTop }, lineHeight } = Measure;
          const offsetRows = ceil(paddingTop / lineHeight);
          this.start = clamp(row - offsetRows, 0, max(this.lines.length - length + this.margin, 0));
          this.offsetY = Measure.getTop(this.start);
          const elms = this.detach(0);
          elms[0].insertAdjacentHTML('afterend', this.html(this.start, length));
          remove(elms);
          this.offset();
          this.attach();
          this.emit(EVENT_CHUNK_MOVED, this);
      }
      /**
       * Returns the focus or anchor boundary data which contains the line and the row index.
       *
       * @param focus - Determines whether to return the focus or anchor boundary data.
       *
       * @return The boundary data object.
       */
      getBoundary(focus) {
          return focus ? this.focus : this.anchor;
      }
      /**
       * Manually adds preserved line.
       * This method should be only used by the Selection component.
       * Note that the `changed` event will be emitted by the `activate` method.
       *
       * @internal
       *
       * @param focus - Determines whether to add a focus or anchor line.
       * @param row   - A row index.
       *
       * @return A created preserved line element.
       */
      addPreservedLine(focus, row) {
          const { parent } = this;
          const classes = `${CLASS_LINE} ${focus ? CLASS_FOCUS : CLASS_ANCHOR} ${CLASS_PRESERVED}`;
          const line = div({ class: classes, 'aria-hidden': true });
          this.deactivate(focus);
          html$2(line, this.lines[row].html);
          if (row < this.start) {
              prepend(parent, line);
          }
          else {
              append(parent, line);
          }
          assign$1(this.getBoundary(focus), { line, row });
          this.setBoundaryChanged(focus, true);
          return line;
      }
      /**
       * Updates HTML of elements with the latest lines.
       * If omitting elements, updates all elements in the chunk.
       *
       * @param elms  - Optional. Elements to sync.
       * @param start - Optional. A start index that corresponds with the first element.
       */
      sync(elms = this.elms, start = this.start) {
          for (let i = 0; i < elms.length; i++) {
              const line = this.lines[i + start];
              const elm = elms[i];
              if (line) {
                  html$2(elm, line.html);
                  removeClass(elm, CLASS_EMPTY);
              }
              else {
                  text(elm, '');
                  addClass(elm, CLASS_EMPTY);
              }
          }
      }
      /**
       * Syncs difference of the number of lines before syncing each HTML for performance.
       * If the diff length is greater than the margin, this method does nothing.
       *
       * @param row  - A row index.
       * @param diff - Difference of the number of lines before and after editing.
       */
      syncDiff(row, diff) {
          if (abs(diff) < MARGIN_LINES) {
              const index = row - this.start;
              const { elms } = this;
              if (diff > 0) {
                  before$1(elms.slice(-diff), elms[index].nextElementSibling);
              }
              else if (diff < 0) {
                  append(this.parent, elms.slice(index + 1, index + 1 - diff));
              }
          }
      }
      /**
       * Refreshes the chunk.
       */
      refresh() {
          this.moveDown();
          this.moveUp();
      }
      /**
       * Scrolls to the specified top position
       * and manually calls the `onScroll` handler for succeeding synchronous processes.
       *
       * @internal
       *
       * @param scrollTop - A scroll position.
       */
      scroll(scrollTop) {
          this.scroller.scrollTop = scrollTop;
          this.onScroll(true);
      }
      /**
       * Returns the row index which the provided line element corresponds with.
       *
       * @param elm - A line element.
       *
       * @return The row index of the line element if available, or otherwise `-1`.
       */
      getRow(elm) {
          const row = this.elms.indexOf(elm);
          return row > -1 ? row + this.start : -1;
      }
      /**
       * Returns the line at the specified row if available.
       *
       * @param row - A row index.
       *
       * @return A line element if available, or `undefined` if not.
       */
      getLine(row) {
          return this.elms[row - this.start];
      }
      /**
       * Checks if the chunk includes the specified row or not.
       *
       * @param row - A row index.
       *
       * @return `true` if the chunk includes the row, or otherwise `false`.
       */
      includes(row) {
          return between(row, this.start, this.end);
      }
      /**
       * Returns the end index of the chunk lines.
       * This may be greater than the total number of actual lines.
       *
       * @return An end index of the chunk.
       */
      get end() {
          return this.start + this.length - 1;
      }
      /**
       * Returns the number of chunk lines without preserved ones.
       *
       * @return A number of line elements in the chunk.
       */
      get length() {
          return this.visibleLines + this.margin * 2;
      }
      /**
       * Returns chunk lines without preserved ones.
       *
       * @return An array containing line elements in the chunk.
       */
      get elms() {
          return slice(queryAll(this.parent, `.${CLASS_LINE}:not(.${CLASS_PRESERVED})`));
      }
      /**
       * Returns borders to move elements up or down.
       *
       * @return A tuple containing top and bottom borders.
       */
      get border() {
          if (!this.borderCache) {
              const domRect = rect(this.scroller);
              const top = max(domRect.top, 0);
              const bottom = min(domRect.bottom, window.innerHeight);
              this.borderCache = [top, bottom];
          }
          return this.borderCache;
      }
  }

  /**
   * The line break character.
   *
   * @private
   * @since 0.1.0
   */
  const LINE_BREAK$1 = '\n';

  /**
   * The abstract class for implementing an ArrayLike class.
   *
   * @since 0.1.0
   *
   * @typeParam T - A type for each element.
   */
  class AbstractArrayLike {
      constructor() {
          /**
           * The length of elements.
           */
          this.length = 0;
      }
      /**
       * Implements the `push` method by using native method.
       *
       * @param items - Items to push.
       */
      push(...items) {
          arrayProto.push.apply(this, items);
      }
      /**
       * Implements the `splice` method by using native method.
       *
       * @param start       - A start index.
       * @param deleteCount - The number of items to delete from the start index.
       * @param items       - New items to insert at the start index.
       */
      splice(start, deleteCount, ...items) {
          splice(this, start, deleteCount, ...items);
      }
      /**
       * Clears elements.
       */
      clear() {
          splice(this, 0, this.length);
      }
  }

  /**
   * Checks if the token matches the provided matcher or not.
   *
   * @param token   - A token to test.
   * @param matcher - An array described as a TokenMatcher tuple.
   */
  function matchesToken(token, matcher) {
      if (token && token[0] === matcher[0] && (!matcher[1] || matcher[1].test(token[1]))) {
          return isUndefined$1(matcher[2]) || token[2].state === matcher[2];
      }
      return false;
  }

  /*!
   * RyuseiLight.js
   * Version  : 1.1.8
   * License  : MIT
   * Copyright: 2020 Naotoshi Fujita
   */

  /**
   * The line break character.
   *
   * @private
   * @since 0.0.1
   */
  var LINE_BREAK = '\n';
  var CATEGORY_KEYWORD = 'keyword';
  var CATEGORY_COMMENT = 'comment';
  var CATEGORY_TAG = 'tag';
  var CATEGORY_TAG_CLOSE = 'tag.close';
  var CATEGORY_SELECTOR = 'selector';
  var CATEGORY_ATRULE = 'atrule';
  var CATEGORY_ATTRIBUTE = 'attr';
  var CATEGORY_PROPERTY = 'prop';
  var CATEGORY_VALUE = 'value';
  var CATEGORY_VARIABLE = 'variable';
  var CATEGORY_ENTITY = 'entity';
  var CATEGORY_CDATA = 'cdata';
  var CATEGORY_PROLOG = 'prolog';
  var CATEGORY_IDENTIFIER = 'identifier';
  var CATEGORY_STRING = 'string';
  var CATEGORY_NUMBER = 'number';
  var CATEGORY_BOOLEAN = 'boolean';
  var CATEGORY_FUNCTION = 'function';
  var CATEGORY_CLASS = 'class';
  var CATEGORY_DECORATOR = 'decorator';
  var CATEGORY_REGEXP = 'regexp';
  var CATEGORY_OPERATOR = 'operator';
  var CATEGORY_BRACKET = 'bracket';
  var CATEGORY_DELIMITER = 'delimiter';
  var CATEGORY_SPACE = 'space';
  var CATEGORY_TEXT = 'text'; // Internal use only

  var CATEGORY_LINEBREAK = 'lb';
  /**
   * Checks if the given subject is an object or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is an object, or otherwise `false`.
   */

  function isObject(subject) {
    return subject !== null && typeof subject === 'object';
  }
  /**
   * Checks if the given subject is `undefined` or not.
   *
   * @param subject - A subject to check.
   *
   * @return `true` if the subject is `undefined`, or otherwise `false`.
   */


  function isUndefined(subject) {
    return typeof subject === 'undefined';
  }
  /**
   * Iterates over the provided object by own enumerable keys with calling the iteratee function.
   *
   * @param object   - An object to iterate over.
   * @param iteratee - An iteratee function that takes the value and key as arguments.
   *
   * @return A provided object itself.
   */


  function forOwn(object, iteratee) {
    if (object) {
      var keys = Object.keys(object);

      for (var i = 0; i < keys.length; i++) {
        iteratee(object[keys[i]], keys[i]);
      }
    }
  }
  /**
   * Assigns all own enumerable properties of all source objects to the provided object.
   * `undefined` in source objects will be skipped.
   *
   * @param object  - An object to assign properties to.
   * @param sources - Objects to assign properties from.
   *
   * @return An object assigned properties of the sources to.
   */


  function assign(object) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (source) {
      if (isObject(source)) {
        forOwn(source, function (value, key) {
          if (!isUndefined(source[key])) {
            object[key] = source[key];
          }
        });
      }
    });
    return object;
  }
  /**
   * Throws an error if the provided condition is falsy.
   *
   * @param condition - If falsy, an error is thrown.
   * @param message   - Optional. A message for the error.
   */


  function assert(condition, message) {
    if (message === void 0) {
      message = '';
    }

    if (!condition) {
      throw new Error(message);
    }
  }
  /**
   * Finds the provided key from a map and returns its index.
   *
   * @param map - A map to search in.
   * @param key - A key to search for.
   *
   * @return An index if found, or `-1` otherwise.
   */


  function find(map, key) {
    for (var i = 0; i < map.length; i++) {
      if (map[i][0] === key) {
        return i;
      }
    }

    return -1;
  }
  /**
   * Insert entries before the reference entry specified by the `ref`.
   * If the reference is not found, a new entry is created.
   *
   * @param map     - A map to insert values to.
   * @param ref     - A reference key.
   * @param entries - entries to insert.
   */


  function before(map, ref, entries) {
    var index = find(map, ref);

    if (index > -1) {
      map.splice.apply(map, [index, 0].concat(entries));
    } else {
      map.push.apply(map, entries);
    }
  }
  /**
   * Checks if the string starts with the `char` or not.
   *
   * @param string - A string to check.
   * @param char   - A character.
   *
   * @return `true` if the string starts with the `char`, or otherwise `false`.
   */


  function startsWith(string, _char) {
    return string.charAt(0) === _char;
  }
  /**
   * Checks if the RegExp supports the sticky flag or not.
   */


  var isStickySupported = !isUndefined(/x/.sticky);
  /**
   * The class for creating a simple lexer by a Language object.
   *
   * @since 0.0.1
   */

  var Lexer$1 = /*#__PURE__*/function () {
    /**
     * The Lexer constructor.
     *
     * @param language - A Language object.
     */
    function Lexer(language) {
      this.language = language;
      this.init(language);
    }
    /**
     * Initializes the language object.
     *
     * @param language - A Language object to initialize.
     */


    var _proto = Lexer.prototype;

    _proto.init = function init(language) {
      var _this = this;

      forOwn(language.grammar, function (tokenizers, key) {
        language.grammar[key] = _this.merge(language, tokenizers);
      });
      forOwn(language.use, this.init.bind(this));
    }
    /**
     * Includes tokenizers required by `#` annotation and flatten them.
     *
     * @param language   - A language object.
     * @param tokenizers - Tokenizers.
     *
     * @return Merged tokenizers.
     */
    ;

    _proto.merge = function merge(language, tokenizers) {
      var merged = [];

      for (var i = 0; i < tokenizers.length; i++) {
        var tokenizer = tokenizers[i];
        var _tokenizers$i = tokenizers[i],
            category = _tokenizers$i[0],
            regexp = _tokenizers$i[1];

        if (startsWith(category, '#') && !regexp) {
          merged.push.apply(merged, this.merge(language, language.grammar[category.slice(1)]));
        } else {
          (function () {
            var flags = regexp.toString().match(/[gimsy]*$/)[0].replace(/[gy]/g, '');
            var source = regexp.source + (isStickySupported ? '' : '|()');
            forOwn(language.source, function (replacement, key) {
              source = source.replace(new RegExp("%" + key, 'g'), replacement.source);
            });
            tokenizer[1] = new RegExp(source, (isStickySupported ? 'y' : 'g') + flags);
            merged.push(tokenizer);
          })();
        }
      }

      return merged;
    }
    /**
     * Parses the text by the provided language and tokenizers.
     *
     * @param text       - A text to tokenize.
     * @param language   - A Language object.
     * @param tokenizers - An array with tokenizers.
     * @param state      - Optional. The current state name.
     *
     * @return An index of the text where the handling ends.
     */
    ;

    _proto.parse = function parse(text, language, tokenizers, state) {
      var index = 0;
      var position = 0;
      this.depth++;

      main: while (index < text.length && !this.aborted) {
        for (var i = 0; i < tokenizers.length; i++) {
          var tokenizer = tokenizers[i];
          var regexp = tokenizer[1],
              action = tokenizer[2];
          regexp.lastIndex = index;
          var match = regexp.exec(text);

          if (!match || !match[0]) {
            continue;
          }

          if (position < index) {
            this.push([CATEGORY_TEXT, text.slice(position, index)], language, state);
          }

          if (action === '@back') {
            position = index;
            break main;
          }

          var offset = this.handle(match, language, tokenizer, state);
          index += offset || 1;
          position = index;

          if (action === '@break') {
            break main;
          }

          continue main;
        }

        index++;
      }

      if (position < index) {
        this.push([CATEGORY_TEXT, text.slice(position)], language, state);
      }

      this.depth--;
      return index;
    }
    /**
     * Pushes the provided token to the lines array.
     *
     * @param token    - A token to push.
     * @param language - A Language object.
     * @param state    - A state name.
     */
    ;

    _proto.push = function push(token, language, state) {
      var depth = this.depth;
      var category = token[0],
          text = token[1];
      var start = this.index;
      var index = 0;
      var from = 0;

      while (index > -1 && !this.aborted) {
        index = text.indexOf(LINE_BREAK, from);
        var line = this.lines[this.index];
        var empty = from === index && !line.length;
        var code = empty ? LINE_BREAK : text.slice(from, index < 0 ? undefined : index);
        var info = {
          depth: depth,
          language: language.id,
          state: state
        };

        if (code) {
          if (category !== CATEGORY_TEXT) {
            info.head = index > -1 && !from;
            info.tail = index < 0 && !!from;
            info.split = index > -1 || !!from;
            info.distance = this.index - start;
          }

          line.push([category === CATEGORY_TEXT && empty ? CATEGORY_LINEBREAK : category, code, info]);
        }

        if (index > -1) {
          this.index++;
          this.aborted = this.limit && this.index >= this.limit;

          if (!this.aborted) {
            from = index + 1;
            this.lines[this.index] = [];
          }
        }
      }
    }
    /**
     * Handles the matched text.
     *
     * @param match     - A matched result.
     * @param language  - A Language object.
     * @param tokenizer - A tokenizer that has been matched with the text.
     * @param state     - A state name.
     *
     * @return An index of the text where the handling ends.
     */
    ;

    _proto.handle = function handle(match, language, tokenizer, state) {
      var category = tokenizer[0];

      if (!category) {
        return 0;
      }

      var text = match[0];

      if (tokenizer[3] === '@debug') {
        // eslint-disable-next-line
        console.log(text, tokenizer);
      }

      if (startsWith(category, '@')) {
        assert(language.use);
        var lang = language.use[category.slice(1)];
        assert(lang);
        return this.parse(text, lang, lang.grammar.main, category);
      }

      if (startsWith(category, '#')) {
        var tokenizers = language.grammar[category.slice(1)];
        assert(tokenizers);

        if (tokenizer[2] === '@rest') {
          text = match.input.slice(match.index);
        }

        return this.parse(text, language, tokenizers, category);
      }

      this.push([category, text], language, state);
      return text.length;
    }
    /**
     * Tokenizes the text by the current language.
     *
     * @param text  - A text to tokenize.
     * @param limit - Optional. Limits the number of lines.
     *
     * @return An array with tokens.
     */
    ;

    _proto.tokenize = function tokenize(text, limit) {
      this.lines = [[]];
      this.index = 0;
      this.depth = -1;
      this.limit = limit || 0;
      this.aborted = false;
      this.parse(text, this.language, this.language.grammar.main, '#main');
      return this.lines;
    };

    return Lexer;
  }();
  var REGEXP_NUMBER = /[+-]?(\d+\.?\d*|\d*\.?\d+)([eE][+-]?\d+)?/;
  var REGEXP_BOOLEAN = /\b(?:true|false)\b/;
  var REGEXP_BRACKET = /[[\]{}()]/;
  var REGEXP_SPACE = /[ \t]+/;
  var REGEXP_QUOTE = /'(?:\\'|.)*?'/;
  var REGEXP_DOUBLE_QUOTE = /"(?:\\"|.)*?"/;
  var REGEXP_MULTILINE_COMMENT = /\/\*[\s\S]*?(\*\/|$)/;
  var REGEXP_SLASH_COMMENT = /\/\/.*/;
  var REGEXP_GENERAL_KEYWORDS = /\b(?:break|catch|class|continue|do|else|extends|finally|for|function|if|implements|in|instanceof|interface|new|null|return|throw|try|while)\b/;
  /**
   * Returns the CSS language definition.
   *
   * @return A Language object.
   */

  function css$1() {
    return {
      id: 'css',
      name: 'CSS',
      grammar: {
        main: [['#common'], // An atrule without a block
        ['#findSingleAtrule'], // Blocks including atrules
        ['#findBlock']],
        findBlock: [['#block', /(?:(?![\t\n\r ;\{\}])[\s\S])(?:(?![;\{\}])[\s\S])*\{[\s\S]*?\}/, '@rest']],
        findSingleAtrule: [['#atrule', /@(?:(?![;\{])[\s\S])+?;/]],
        // Finds atrules before { and ;
        findAtrule: [['#atrule', /@(?:(?![;\{])[\s\S])*?(?=[;\{])/]],
        // May not start with digits
        findSelector: [['#selector', /(?:(?![\t\n\r ;\{\}])[\s\S])[\s\S]*?(?=\{)/]],
        common: [[CATEGORY_STRING, /(["'])[\s\S]*?(?:(?!\\)[\s\S])\1/], [CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT], [CATEGORY_SPACE, REGEXP_SPACE]],
        block: [['#inner', /{/, '@rest'], [CATEGORY_BRACKET, /}/, '@break'], ['#findAtrule'], ['#findSelector'], [CATEGORY_SPACE, REGEXP_SPACE]],
        inner: [[CATEGORY_BRACKET, /{/], ['#common'], ['#findBlock'], ['#props'], ['#findAtrule'], ['', /}/, '@back']],
        atrule: [['#common'], ['#url', /\burl\(/, '@rest'], [CATEGORY_SPACE, REGEXP_SPACE], [CATEGORY_ATRULE, /[^\s();]+/], [CATEGORY_DELIMITER, /[:;,]/], ['#paren', /\(/, '@rest']],
        paren: [[CATEGORY_BRACKET, /^\(/], ['#common'], ['#paren', /\(/, '@rest'], [CATEGORY_BRACKET, /\)/, '@break'], ['#props']],
        selector: [['#common'], [CATEGORY_OPERATOR, /[>+~]/], [CATEGORY_BRACKET, /[[\]()]/], [CATEGORY_DELIMITER, /=/], [CATEGORY_SELECTOR, /::?\S+/], [CATEGORY_SELECTOR, /[\W\d]\S+/], [CATEGORY_TAG, /\b[a-z]+|\*/i], [CATEGORY_SELECTOR, /\S+/]],
        url: [['#common'], [CATEGORY_FUNCTION, /^url/], [CATEGORY_BRACKET, /\(/], [CATEGORY_STRING, /[^)]+/], [CATEGORY_BRACKET, /\)/, '@break']],
        props: [[CATEGORY_PROPERTY, /[a-z0-9-_\xA0-\uFFFF]+(?=:)/i], ['#url', /\burl\(/, '@rest'], [CATEGORY_FUNCTION, /\b[\w-]+(?=\()\b/], [CATEGORY_KEYWORD, /!important|\b(?:initial|inherit|unset)/], [CATEGORY_PROPERTY, /[a-z0-9-]+(?=:)/], [CATEGORY_NUMBER, /#([0-9a-f]{6}|[0-9a-f]{3})/i], [CATEGORY_NUMBER, /\bU\+[0-9a-f?-]+/i], [CATEGORY_NUMBER, /[+-]?(\d+\.?\d*|\d*\.?\d+)/], [CATEGORY_DELIMITER, /[:;,]/], ['#paren', /\(/, '@rest'], [CATEGORY_BRACKET, /[[\])]/], [CATEGORY_SPACE, REGEXP_SPACE]]
      }
    };
  }
  /**
   * Returns the JavaScript language definition.
   *
   * @return A Language object.
   */


  function javascript$1() {
    return {
      id: 'javascript',
      name: 'JavaScript',
      alias: ['js'],
      source: {
        func: /[_$a-z\xA0-\uFFFF][_$a-z0-9\xA0-\uFFFF]*/
      },
      grammar: {
        main: [[CATEGORY_STRING, REGEXP_QUOTE], [CATEGORY_STRING, REGEXP_DOUBLE_QUOTE], ['#backtick', /`/, '@rest'], [CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT], [CATEGORY_COMMENT, REGEXP_SLASH_COMMENT], [CATEGORY_REGEXP, /\/(\[.*?]|\\\/|.)+?\/[gimsuy]*/], [CATEGORY_KEYWORD, REGEXP_GENERAL_KEYWORDS], [CATEGORY_KEYWORD, /\b(?:as|async|await|case|catch|const|debugger|default|delete|enum|export|from|import|let|package|private|protected|public|super|switch|static|this|typeof|undefined|var|void|with|yield)\b/], [CATEGORY_KEYWORD, /\b((get|set)(?=\s+%func))/i], [CATEGORY_CLASS, /\b[A-Z][\w$]*\b/], [CATEGORY_FUNCTION, /%func(?=\s*\()/i], [CATEGORY_BOOLEAN, REGEXP_BOOLEAN], [CATEGORY_DECORATOR, /@[^\s(@]+/], [CATEGORY_IDENTIFIER, /\b[a-z_$][\w$]*\b/], [CATEGORY_NUMBER, REGEXP_NUMBER], [CATEGORY_OPERATOR, /=>/], [CATEGORY_OPERATOR, /\+[+=]?|-[-=]?|\*\*?=?|[/%^]=?|&&?=?|\|\|?=?|\?\??=?|<<?=?|>>>=?|>>?=?|[!=]=?=?|[~:^]/], [CATEGORY_BRACKET, REGEXP_BRACKET], [CATEGORY_DELIMITER, /[;.,]+/], [CATEGORY_SPACE, REGEXP_SPACE]],
        backtick: [[CATEGORY_STRING, /^`/], [CATEGORY_STRING, /(\$[^{]|\\[$`]|[^`$])+/], ['#expression', /\${/, '@rest'], [CATEGORY_STRING, /`/, '@break']],
        expression: [[CATEGORY_DELIMITER, /^\${/], [CATEGORY_DELIMITER, /}/, '@break'], ['#main']]
      }
    };
  }
  /**
   * Returns the HTML language definition.
   *
   * @param options - Optional. Options.
   *
   * @return A Language object.
   */


  function html$1(options) {
    if (options === void 0) {
      options = {};
    }

    var script = (options.script || javascript$1)();
    var style = (options.style || css$1)();
    var cdata = [CATEGORY_CDATA, /<!\[CDATA\[[\s\S]*\]\]>/i]; // Embedded scripts or styles may contain CDATA sections.

    script.grammar.main.unshift(cdata);
    style.grammar.main.unshift(cdata);
    return {
      id: 'html',
      alias: ['markup'],
      name: 'HTML',
      use: {
        script: script,
        style: style
      },
      grammar: {
        main: [[CATEGORY_COMMENT, /<!\x2D\x2D[\s\S]*?\x2D\x2D>/], [CATEGORY_PROLOG, /<!DOCTYPE[\s\S]*?>/i], cdata, ['#script', /<script[\s\S]*?>[\s\S]*?<\/script>/], ['#style', /<style[\s\S]*?>[\s\S]*?<\/style>/], ['#tag', /<[\s\S]*?>/], [CATEGORY_ENTITY, /&[\da-z]+;|&#\d+;/i], [CATEGORY_SPACE, REGEXP_SPACE]],
        script: [['#tag', /^<script[\s\S]*?>/], cdata, ['@script', /[\s\S]+(?=<\/script>)/], ['#tag', /<\/script>/]],
        style: [['#tag', /^<style[\s\S]*?>/], ['@style', /[\s\S]+(?=<\/style>)/], ['#tag', /<\/style>/]],
        tag: [['#closeTag', /<\/.+>/], ['#tagContent']],
        closeTag: [[CATEGORY_TAG_CLOSE, /[^\s/<>"'=]+/], ['#tagContent']],
        tagContent: [['#attr', /[\t\n\r ]+[\s\S]+(?=[\t\n\r \/>])/], [CATEGORY_TAG, /[^\s/<>"'=]+/], [CATEGORY_BRACKET, /[<>]/], [CATEGORY_DELIMITER, /[/]/]],
        attr: [[CATEGORY_SPACE, REGEXP_SPACE], [CATEGORY_VALUE, /(['"])(\\\1|.)*?\1/], [CATEGORY_DELIMITER, /[/=]/], [CATEGORY_ATTRIBUTE, /[^\s/>"'=]+/]]
      }
    };
  }
  /**
   * Returns the JSON language definition.
   *
   * @link https://www.json.org/json-en.html
   *
   * @return A Language object.
   */


  function json$1() {
    return {
      id: 'json',
      name: 'JSON',
      grammar: {
        main: [[CATEGORY_PROPERTY, /".*?[^\\]"(?=:)/], [CATEGORY_STRING, REGEXP_DOUBLE_QUOTE], [CATEGORY_KEYWORD, /\bnull\b/], [CATEGORY_NUMBER, /[+-]?(\d+\.?\d*)([eE][+-]?\d+)?/], [CATEGORY_BRACKET, /[{}[\]]/], [CATEGORY_BOOLEAN, REGEXP_BOOLEAN], [CATEGORY_OPERATOR, /:/], [CATEGORY_DELIMITER, /,/], [CATEGORY_SPACE, REGEXP_SPACE]]
      }
    };
  }
  /**
   * Returns the JSX language definition.
   *
   * @return A Language object.
   */


  function jsx$1(options) {
    if (options === void 0) {
      options = {};
    }

    var language = assign((options.base || javascript$1)(), {
      id: 'jsx',
      name: 'JSX',
      alias: ['react']
    });
    var grammar = language.grammar;
    before(grammar.main, CATEGORY_CLASS, [['#findPairedTag'], ['#findSelfClosedTag']]);
    assign(grammar, {
      // This doesn't pick correct paired tags if nested, but they are incrementally searched later.
      findPairedTag: [['#pairedTag', /(?:<[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*?([0-9A-Z_a-z]+)[\s\S]*?>[\s\S]*?<\/\1>)|<[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*?>[\s\S]*?<\/>/, '@rest']],
      // Should not match the closing delimiter inside `{}`, `''` and `""`.
      findSelfClosedTag: [['#selfClosedTag', /<(?:\{[\s\S]*?\}|(["'])[\s\S]*?\1|(?:(?!>)[\s\S]))+?\/>/]],
      findBracket: [['#code', /{/, '@rest']],
      pairedTag: [['#openTag', /^</, '@rest'], ['#findBracket'], ['#findPairedTag'], ['#findSelfClosedTag'], ['#tagName', /<\/([\w][^\s]*?)?>/, '@break'], [CATEGORY_SPACE, REGEXP_SPACE]],
      code: [[CATEGORY_BRACKET, /^{/], [CATEGORY_BRACKET, /}/, '@break'], ['#findBracket'], ['#main']],
      selfClosedTag: [['#openTag', /^</, '@rest']],
      openTag: [['#tagName', /<\s*[^\s/>"'=]*/], ['#findBracket'], [CATEGORY_ATTRIBUTE, /[^\s/>"'=]+/], [CATEGORY_VALUE, /(['"])(\\\1|.)*?\1/], [CATEGORY_SPACE, REGEXP_SPACE], [CATEGORY_DELIMITER, /[/=]/], [CATEGORY_BRACKET, />/, '@break']],
      tagName: [[CATEGORY_BRACKET, /[<>]/], [CATEGORY_SPACE, REGEXP_SPACE], [CATEGORY_DELIMITER, /\//], [CATEGORY_CLASS, /[A-Z][\w$-]*/], [CATEGORY_TAG, /[^\s/>"'=]+/]]
    });
    return language;
  }
  /**
   * Returns the None language definition.
   *
   * @return A Language object.
   */


  function none$1() {
    return {
      id: 'none',
      name: '',
      grammar: {
        main: []
      }
    };
  }
  /**
   * Returns the SCSS language definition.
   *
   * @return A Language object.
   */


  function scss$1() {
    var language = assign(css$1(), {
      id: 'scss',
      name: 'SCSS'
    });
    var grammar = language.grammar;
    assign(grammar, {
      findBlock: [
      /**
       * Include: div {}, .class {}, #id {}, * {}, *{}, #{ $variable } {}, .something__#{ $variable } {}
       * Exclude: #{ variable }: value
       */
      ['#block', /([\*-_a-z]|#\{(?:(?!;)[\s\S])*?\}|((#\{(?:(?!;)[\s\S])*?\}|(?:(?![\t-\r ;\{\}\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF])[\s\S]))(#\{(?:(?!;)[\s\S])*?\}|(?:(?![#;\{\}])[\s\S])|#(?:(?!\{)[\s\S]))+?))(?!#)\{[\s\S]*?\}/i, '@rest']],
      // May contain #{} interpolation
      findSingleAtrule: [['#atrule', /@(#\{|(?:(?![;\{])[\s\S]))+?;/]],
      findAtrule: [['#atrule', /@(#\{|(?:(?![;\{])[\s\S]))*?(?=[;\{])/]],
      // May contain #{} interpolation
      findSelector: [['#selector', /(?:(?!;)[\s\S])*?(?:(?!#)[\s\S])(?=\{)/, '']],
      findInterp: [['#interp', /#{/, '@rest']],
      common: [['#string'], [CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT], [CATEGORY_COMMENT, REGEXP_SLASH_COMMENT], [CATEGORY_DELIMITER, /;/], [CATEGORY_SPACE, REGEXP_SPACE]],
      string: [['#singleQuote', /'/, '@rest'], ['#doubleQuote', /"/, '@rest']],
      singleQuote: [[CATEGORY_STRING, /^'/], ['#findInterp'], [CATEGORY_STRING, /(\\'|#[^{]|[^'#])+/], [CATEGORY_STRING, /'/, '@break']],
      doubleQuote: [[CATEGORY_STRING, /^"/], ['#findInterp'], [CATEGORY_STRING, /(\\"|#[^{]|[^"#])+/], [CATEGORY_STRING, /"/, '@break']],
      selector: [['#common'], ['#findInterp'], [CATEGORY_OPERATOR, /[>+~]/], [CATEGORY_BRACKET, /[[\]()]/], [CATEGORY_DELIMITER, /=/], [CATEGORY_SELECTOR, /::?\S+(?=#{)/], [CATEGORY_SELECTOR, /[\W\d]\S+(?=#{)/], [CATEGORY_TAG, /\b[a-zA-Z]+\b|\*/], [CATEGORY_SELECTOR, /([^#\s]|#[^{\s])+/]],
      url: [['#common'], ['#findInterp'], [CATEGORY_FUNCTION, /^url/], [CATEGORY_BRACKET, /\(/], [CATEGORY_STRING, /[^)]+(?=#{)/], [CATEGORY_STRING, /[^)]+/], [CATEGORY_BRACKET, /\)/, '@break']],
      interp: [[CATEGORY_DELIMITER, /#{/], [CATEGORY_DELIMITER, /}/, '@break'], ['#common'], ['#props']]
    });
    grammar.inner.unshift(['#findInterp']);
    before(grammar.atrule, '#url', [['#findInterp']]);
    before(grammar.props, CATEGORY_PROPERTY, [['#findInterp'], [CATEGORY_VARIABLE, /\$[\w-_]+/]]);
    return language;
  }
  /**
   * Returns the XML language definition.
   *
   * @return A Language object.
   */


  function xml$1() {
    var language = assign(html$1(), {
      id: 'xml',
      name: 'XML',
      alias: []
    });
    language.grammar.main.unshift([CATEGORY_PROLOG, /<\?[\s\S]*?\?>/]);
    return language;
  }
  /**
   * Returns the Typescript language definition.
   *
   * @return A Language object.
   */


  function typescript$1() {
    var language = assign(javascript$1(), {
      id: 'typescript',
      name: 'TypeScript',
      alias: ['ts']
    });
    var grammar = language.grammar;
    var main = grammar.main;
    before(main, CATEGORY_KEYWORD, [[CATEGORY_KEYWORD, /\b(?:declare|keyof|namespace|readonly|type|string|number|boolean|bigint|symbol|object|any|never|unknown|infer|is)\b/]]);
    before(main, CATEGORY_FUNCTION, [['#functions', /([_$a-z\xA0-\uFFFF][_$a-z0-9\xA0-\uFFFF]*)?(?:<[^>]+?>)?\s*?\(/]]);
    assign(grammar, {
      functions: [[CATEGORY_FUNCTION, /^[\w$]+/]].concat(main.filter(function (tokenizer) {
        return tokenizer[0] !== '#functions';
      }))
    });
    return language;
  }
  /**
   * Returns the VUE language definition.
   *
   * @return A Language object.
   */


  function vue$1(options) {
    if (options === void 0) {
      options = {};
    }

    var language = assign(html$1(options), {
      id: 'vue',
      name: 'Vue',
      alias: []
    }); // Vue uses Mustache syntax for writing code inside tags.

    language.grammar.main.push(['@script', /{{[\s\S]*?}}/]);
    return language;
  } // export { common }     from './common/common';

  /**
   * Determines what HTML should be inserted to empty lines.
   * Be aware that changing this character may break the selection.
   *
   * @since 0.1.0
   */
  const EMPTY_LINE_HTML = '<br>';
  /**
   * The class for managing data of each line.
   *
   * @since 0.1.0
   */
  class Line {
      /**
       * The Line constructor.
       *
       * @param options - Options.
       */
      constructor(options) {
          /**
           * Holds the last update time.
           */
          this.time = 0;
          /**
           * Holds the depth of the first token.
           */
          this.depth = 0;
          /**
           * Holds tokens.
           */
          this.tokens = [];
          /**
           * Depth of tabs.
           */
          this.indentDepth = 0;
          this.options = options;
      }
      /**
       * Initializes some properties.
       */
      init() {
          const { first } = this;
          const info = (first && first[2]) || {};
          this.depth = info.depth || 0;
          this.language = info.language || '';
          this.split = info.split;
          this.indentDepth = count(this.getIndent(), this.options.indent);
          this.htmlCache = undefined;
          this.textCache = undefined;
      }
      /**
       * Sets new tokens and initializes properties.
       * To avoid updating tokens by the old value made by async processes,
       * pass the update time with `Date.now()`.
       *
       * @param tokens - An array with tokens.
       * @param time   - Optional. If this time is older than the current time, tokens will not be updated.
       */
      set(tokens, time) {
          if (!time || time > this.time) {
              this.tokens = tokens;
              this.time = time || Date.now();
              this.init();
          }
      }
      /**
       * Returns the indent of the line if available.
       *
       * @return An indent string if available, or an empty string if not.
       */
      getIndent() {
          const { first } = this;
          if (first) {
              if (first[0] === CATEGORY_SPACE) {
                  return first[1];
              }
              if (first[0] === CATEGORY_COMMENT) {
                  const match = this.text.match(new RegExp(`^${this.options.indent}+`));
                  return match ? match[0] : '';
              }
          }
          return '';
      }
      /**
       * Returns the TokenInfo object at the index.
       *
       * @param index - A token index.
       *
       * @return A TokenInfo object if available, or `undefined` if not.
       */
      getInfo(index) {
          const token = this.tokens[index];
          return token && token[2];
      }
      /**
       * Returns the TokenInfo object at the col index.
       *
       * @param col - A col index.
       *
       * @return A TokenInfo object if available, or `undefined` if not.
       */
      getInfoAt(col) {
          const { tokens, tokens: { length } } = this;
          if (tokens.length) {
              if (col === this.text.length) {
                  return tokens[length - 1][2];
              }
              for (let i = 0; i < length; i++) {
                  const info = tokens[i][2];
                  if (info.from <= col && col < info.to) {
                      return info;
                  }
              }
          }
      }
      /**
       * Checks if the line contains only a line break/spaces or not.
       *
       * @return `true` if the line contains only a line break or spaces. Otherwise, `false`.
       */
      isEmpty() {
          const { tokens } = this;
          return tokens.length === 1 && includes([CATEGORY_LINEBREAK, CATEGORY_SPACE], tokens[0][0]);
      }
      /**
       * Builds the HTML by tokens.
       * This should not be pre-built in the init function for better performance.
       *
       * @return The HTML string of the line.
       */
      get html() {
          if (!this.htmlCache) {
              let html = '';
              for (let i = 0; i < this.tokens.length; i++) {
                  const token = this.tokens[i];
                  if (i === 0 && token[1] === LINE_BREAK$1) {
                      html += EMPTY_LINE_HTML;
                      break;
                  }
                  else {
                      html += token[2].html;
                  }
              }
              this.htmlCache = html || EMPTY_LINE_HTML;
          }
          return this.htmlCache;
      }
      /**
       * Builds the text by tokens.
       *
       * @return The text of the line.
       */
      get text() {
          if (isUndefined$1(this.textCache)) {
              this.textCache = this.tokens.reduce((text, token) => {
                  if (token[0] !== CATEGORY_LINEBREAK) {
                      text += token[1];
                  }
                  return text;
              }, '');
          }
          return this.textCache;
      }
      /**
       * Returns the first token.
       *
       * @return The first token.
       */
      get first() {
          return this.tokens[0];
      }
  }

  /**
   * The max number of lines to be inserted at once.
   * Inserting many lines harms the performance.
   *
   * @since 0.1.0
   */
  const MAX_INSERTION_LENGTH = 100;
  /**
   * Delay for the asynchronous tokenization.
   *
   * @since 0.1.0
   */
  const ASYNC_SYNC_DELAY = 10;
  /**
   * The class for managing data of all lines.
   *
   * @since 0.1.0
   */
  class Lines extends AbstractArrayLike {
      /**
       * The Lines constructor.
       *
       * @param event    - An EventBus instance.
       * @param language - A Language object.
       * @param options  - Options.
       */
      constructor(event, language, options) {
          super();
          /**
           * Holds the setTimeout ids.
           */
          this.timers = {};
          this.language = language;
          this.event = event;
          this.options = options;
      }
      /**
       * Inserts a new line at the specified row index.
       * Be aware that inserting a lot of lines causes the fatal performance issue.
       *
       * @param row   - A row index.
       * @param count - A number of lines to insert.
       */
      insert(row, count) {
          count = count || 1;
          while (count-- > 0) {
              this.splice(row, 0, new Line(this.options));
          }
      }
      /**
       * Deletes a line or lines from the specified row.
       *
       * @param row   - A row index.
       * @param count - A number of lines to delete.
       */
      delete(row, count) {
          this.splice(row, count);
      }
      /**
       * Syncs lines with the provided code.
       *
       * @param row    - A row index where sync starts.
       * @param code   - Code to sync.
       * @param limit  - Optional. Limits the number of lines to sync.
       * @param before - Optional. A pseudo line prepended to the code.
       * @param time   - Optional. A timestamp when the sync starts.
       *
       * @return `true` if the last line is changed, or otherwise `false`.
       */
      sync(row, code, limit, before = '', time) {
          if (before) {
              code = before + LINE_BREAK$1 + code;
              if (limit) {
                  limit++;
              }
          }
          const lines = this.language.lexer.run(code, limit);
          if (before) {
              lines.shift();
          }
          let changed;
          for (let i = 0; i < lines.length; i++) {
              const rowIndex = row + i;
              const tokens = lines[i];
              if (!this[rowIndex]) {
                  this.insert(rowIndex);
              }
              if (this[rowIndex]) {
                  if (i === lines.length - 1) {
                      changed = !this.isSame(this[rowIndex].tokens, tokens);
                  }
                  this[rowIndex].set(tokens, time);
              }
          }
          return changed;
      }
      /**
       * Starts an asynchronous sync process.
       *
       * @param id       - A worker ID.
       * @param row      - A row index where sync starts.
       * @param code     - Code to sync.
       * @param limit    - Optional. Limits the number of lines to sync.
       * @param before   - Optional. A pseudo line prepended to the code.
       * @param callback - Optional. A function called after syncing.
       */
      asyncSync(id, row, code, limit, before = '', callback) {
          const { timers } = this;
          if (timers[id]) {
              clearTimeout(timers[id]);
          }
          const time = Date.now();
          timers[id] = setTimeout(() => {
              this.sync(row, code, limit, before, time);
              if (callback) {
                  callback();
              }
          }, ASYNC_SYNC_DELAY);
      }
      /**
       * Finds the minimum indent string between the `startRow` and the `endRow`.
       *
       * @param startRow - A start row index to search from.
       * @param endRow   - An end row index to search to.
       *
       * @return A minimum indent string.
       */
      findMinIndent(startRow, endRow) {
          let minIndent = undefined;
          for (let i = startRow; i <= endRow; i++) {
              const indent = this[i].getIndent();
              minIndent = isUndefined$1(minIndent) || minIndent.length > indent.length ? indent : minIndent;
          }
          return minIndent || '';
      }
      /**
       * Returns a token info at the specified position.
       *
       * @param position - A position to search at.
       *
       * @return A TokenInfo if available, or otherwise `undefined`.
       */
      getInfoAt(position) {
          const line = this[position[0]];
          return line ? line.getInfoAt(position[1]) : undefined;
      }
      /**
       * Searches backwards for a token that matches the matcher.
       * If the `counterpart` matcher is provided,
       * this method attempts to match the target and counterpart, such as `{` and `}`.
       *
       * @param position    - A position to start searching.
       * @param matcher     - A matcher.
       * @param counterpart - Optional. A matcher of the counter part.
       * @param depth       - Optional. Determines the initial depth.
       * @param limit       - Optional. Limits the number of lines to scan.
       *
       * @return A TokenInfo object if found, or `undefined` if not.
       */
      scanUp(position, matcher, counterpart, depth = 0, limit) {
          const info = this.getInfoAt(position);
          if (info) {
              const [row] = position;
              const min = limit ? max(0, row - limit) : 0;
              for (let i = row; i >= min; i--) {
                  const tokens = this[i].tokens;
                  for (let j = i === row ? info.index : tokens.length - 1; j >= 0; j--) {
                      if (matchesToken(tokens[j], matcher)) {
                          if (!depth) {
                              return { row: i, info: this[i].getInfo(j) };
                          }
                          depth++;
                      }
                      if (counterpart && matchesToken(tokens[j], counterpart)) {
                          depth--;
                      }
                  }
              }
          }
      }
      /**
       * Searches forwards for a token that matches the matcher.
       * If the `counterpart` matcher is provided,
       * this method attempts to match the target and counterpart, such as `{` and `}`.
       *
       * @param position    - A position to start searching.
       * @param matcher     - A matcher.
       * @param counterpart - Optional. A matcher of the counter part.
       * @param depth       - Optional. Determines the initial depth.
       * @param limit       - Optional. Limits the number of lines to scan.
       *
       * @return A TokenInfo object if found, or `undefined` if not.
       */
      scanDown(position, matcher, counterpart, depth = 0, limit) {
          const info = this.getInfoAt(position);
          if (info) {
              const [row] = position;
              const { length } = this;
              const max = limit ? min(length, row + limit) : length;
              for (let i = row; i < max; i++) {
                  const tokens = this[i].tokens;
                  for (let j = i === row ? info.index : 0; j < tokens.length; j++) {
                      if (matchesToken(tokens[j], matcher)) {
                          if (!depth) {
                              return { row: i, info: this[i].getInfo(j) };
                          }
                          depth++;
                      }
                      if (counterpart && matchesToken(tokens[j], counterpart)) {
                          depth--;
                      }
                  }
              }
          }
      }
      /**
       * Searches for a start position where the split token actually starts.
       * If the token at the position is not split, this returns `undefined`.
       *
       * @param position - A position.
       *
       * @return A position where the split token starts if available.
       */
      findBlockStart(position) {
          const info = this.getInfoAt(position);
          if (info) {
              if (info.split) {
                  const startRow = position[0] - info.distance;
                  const line = this[startRow];
                  const lastInfo = line.getInfo(line.tokens.length - 1);
                  return [startRow, lastInfo.from];
              }
              return [position[0], info.from];
          }
      }
      /**
       * Searches for an end position where the split token actually ends.
       * If the token at the position is not split, this returns `undefined`.
       *
       * @param position - A position.
       *
       * @return A position where the split token ends if available.
       */
      findBlockEnd(position) {
          const info = this.getInfoAt(position);
          if (info) {
              if (info.split && !info.tail) {
                  for (let i = position[0] + 1; i < this.length; i++) {
                      const info = this[i].getInfo(0);
                      if (info && info.tail) {
                          return [i, info.to];
                      }
                  }
              }
              return [position[0], info.to];
          }
      }
      /**
       * Syncs the number of lines.
       *
       * @param row   - A row index.
       * @param value - A new size.
       *
       * @return Increased or decreased number of lines.
       */
      syncSize(row, value) {
          const diff = value - this.length;
          if (diff > 0) {
              if (diff < MAX_INSERTION_LENGTH) {
                  this.insert(row, diff);
              }
              else {
                  this.setLength(value);
              }
          }
          else if (diff < 0) {
              this.delete(row, -diff);
          }
          return diff;
      }
      /**
       * Destroys the instance.
       */
      destroy() {
          forOwn$1(this.timers, clearTimeout);
      }
      /**
       * Sets the length of this Lines.
       * All overflown items will be removed from the end, or all missing items are added to the end as empty lines.
       *
       * @param value - A new length.
       */
      setLength(value) {
          const { length } = this;
          if (length > value) {
              this.splice(value, length - value);
          }
          else if (length < value) {
              while (value-- > length) {
                  this.push(new Line(this.options));
              }
          }
      }
      /**
       * Checks if the passed 2 arrays with tokens are same or not.
       *
       * @param tokens1 - An array with tokens.
       * @param tokens2 - Another array with tokens.
       *
       * @return `true` if they are considered as same, or otherwise `false`.
       */
      isSame(tokens1, tokens2) {
          return tokens1.length === tokens2.length && tokens1.every((token1, index) => {
              const token2 = tokens2[index];
              return token1[0] === token2[0] && token1[1] === token2[1] && token1[2].depth === token2[2].depth;
          });
      }
  }

  /**
   * The class for handling the raw text and syncing it to lines.
   *
   * @since 0.1.0
   */
  class Code extends Component {
      constructor() {
          super(...arguments);
          /**
           * Holds the minimum row for asynchronous syncing.
           */
          this.minStart = Infinity;
          /**
           * Holds the maximum row for asynchronous syncing.
           */
          this.maxEnd = 0;
      }
      /**
       * Sets a new value.
       *
       * @internal
       *
       * @param value - A new value.
       */
      init(value) {
          if (!this.Lines) {
              this.Lines = new Lines(this.event, this.Editor.language, this.options);
          }
          else {
              this.Lines.clear();
          }
          this.value = value;
          this.Lines.sync(0, value);
      }
      /**
       * Returns a text before the specified row index, including the row itself.
       *
       * @param row - A row index.
       *
       * @return A sliced text.
       */
      before(row) {
          const { text } = this;
          if (row < 0) {
              return '';
          }
          return text.slice(0, row < this.size - 1 ? nthIndexOf(text, LINE_BREAK$1, row + 1) + 1 : text.length);
      }
      /**
       * Returns a text after the specified row index, including the row itself.
       *
       * @param row - A row index.
       *
       * @return A sliced text.
       */
      after(row) {
          const { text } = this;
          if (row <= 0) {
              return text;
          }
          return text.slice(row < this.size ? nthIndexOf(text, LINE_BREAK$1, row) + 1 : text.length);
      }
      /**
       * Returns the code at the row index.
       *
       * @param row - A row index.
       *
       * @return The text of the line at the specified row.
       */
      getLine(row) {
          return row < this.size ? this.sliceLines(row, row) : '';
      }
      /**
       * Slices the code by the specified row range.
       *
       * @param startRow - A start row index to start slicing a text.
       * @param endRow   - An end row index to end slicing a text.
       *
       * @return A sliced text.
       */
      sliceLines(startRow, endRow) {
          const { text } = this;
          const endIndex = endRow < this.size - 1 ? nthIndexOf(text, LINE_BREAK$1, endRow + 1) + 1 : this.text.length;
          return text.slice(nthIndexOf(text, LINE_BREAK$1, startRow) + 1, endIndex);
      }
      /**
       * Slices the code by the specified position range.
       *
       * @param start - A start position to start slicing a text.
       * @param end   - Optional. An end position to end slicing a text.
       *
       * @return A sliced text.
       */
      sliceRange(start, end) {
          const startIndex = this.positionToIndex(start);
          const endIndex = end ? this.positionToIndex(end) : this.text.length;
          return startIndex < endIndex ? this.text.slice(startIndex, endIndex) : '';
      }
      /**
       * Replaces lines by the replacement text.
       *
       * @param startRow    - A start row index.
       * @param endRow      - An end row index.
       * @param replacement - A replacement text.
       */
      replaceLines(startRow, endRow, replacement) {
          assert$1(startRow <= endRow);
          this.text = this.before(startRow - 1) + this.normalize(replacement) + this.after(endRow + 1);
          this.sizeCache = 0;
      }
      /**
       * Replaces the code in a specified range by the replacement text.
       *
       * @param start       - A start position.
       * @param end         - An end position.
       * @param replacement - A replacement text.
       */
      replaceRange(start, end, replacement) {
          const startIndex = this.positionToIndex(start);
          const endIndex = this.positionToIndex(end);
          const { value } = this;
          if (startIndex <= endIndex) {
              this.text = value.slice(0, startIndex) + this.normalize(replacement) + value.slice(endIndex);
              this.sizeCache = 0;
          }
      }
      /**
       * Replaces lines by the iteratee function invoked for each line.
       * The returning string of the function will be used as a new line.
       *
       * @param startRow - A start row index.
       * @param endRow   - An end row index.
       * @param iteratee - An iteratee function invoked for each line.
       */
      replaceLinesBy(startRow, endRow, iteratee) {
          const { size } = this;
          assert$1(endRow < size);
          const isLast = endRow === size - 1;
          const lines = this.sliceLines(startRow, endRow).split(LINE_BREAK$1, endRow - startRow + 1);
          this.replaceLines(startRow, endRow, lines.reduce((acc, line, index, array) => {
              const lineBreak = isLast && index === array.length - 1 ? '' : LINE_BREAK$1;
              return acc + iteratee(line, index, array) + lineBreak;
          }, ''));
      }
      /**
       * Searches the provided word or regexp.
       *
       * @param search     - A string or a regexp object.
       * @param ignoreCase - Optional. Whether to perform case-insensitive search or not.
       * @param wholeWord  - Optional. Whether to only match a whole word or not.
       * @param limit      - Optional. Limits the number of matched results.
       *
       * @return An array with tuples that contains `[ index, length ]`.
       */
      search(search, ignoreCase, wholeWord, limit) {
          const source = isString(search) ? escapeRegExp(search) : search.source;
          const ranges = [];
          if (source) {
              const regexp = new RegExp(wholeWord ? `\\b${source}\\b` : source, ignoreCase ? 'gi' : 'g');
              lines: for (let i = 0; i < this.Lines.length; i++) {
                  const line = this.Lines[i];
                  let match;
                  while ((match = regexp.exec(line.text))) {
                      if (!match[0]) {
                          regexp.lastIndex++;
                      }
                      ranges.push({
                          start: [i, match.index],
                          end: [i, match.index + match[0].length],
                      });
                      if (limit && ranges.length >= limit) {
                          break lines;
                      }
                  }
              }
          }
          return ranges;
      }
      /**
       * Destroys the component.
       *
       * @internal
       */
      destroy() {
          if (this.Lines) {
              this.Lines.destroy();
          }
          super.destroy();
      }
      /**
       * Converts the provided position to the text index.
       *
       * @param position - A position to convert.
       *
       * @return A converted index.
       */
      positionToIndex(position) {
          const [row] = position;
          assert$1(row < this.size);
          return nthIndexOf(this.text, LINE_BREAK$1, row) + 1 + position[1];
      }
      /**
       * Normalizes characters of line breaks.
       *
       * @param value - A value to normalize.
       *
       * @return A normalized text.
       */
      normalize(value) {
          return value.replace(/\r\n?/g, '\n');
      }
      /**
       * Sets a new value.
       *
       * @param value - A value to set.
       */
      set value(value) {
          this.text = this.normalize(value);
          this.sizeCache = 0;
      }
      /**
       * Returns the current code.
       *
       * @return The current code.
       */
      get value() {
          return this.text;
      }
      /**
       * Returns the number of lines by counting line breaks.
       *
       * @return The number of lines.
       */
      get size() {
          this.sizeCache = this.sizeCache || count(this.text, LINE_BREAK$1) + 1;
          return this.sizeCache;
      }
  }

  /**
   * The SVG view box settings.
   *
   * @since 0.1.0
   */
  const VIEW_BOX = '0 0 24 24';
  /**
   * Returns an icon SVG element specified by the name.
   *
   * @param d       - The path of the icon element.
   * @param stroke  - Stroke width.
   * @param linecap - Linecap.
   *
   * @return The SVG element of the icon.
   */
  function icon(d, stroke, linecap) {
      const svg = createSvg('svg', { viewBox: VIEW_BOX, class: CLASS_ICON });
      const path = createSvg('path', { d, fill: 'currentColor' });
      if (stroke) {
          attr(path, { 'stroke-width': stroke, 'stroke-linecap': linecap, stroke: 'currentColor' });
      }
      attr(svg, { viewBox: VIEW_BOX });
      svg.appendChild(path);
      return svg;
  }
  /**
   * The helper function to create a SVG element.
   *
   * @param tag   - A tag name in the SVG namespace.
   * @param attrs - An object literal with attributes.
   *
   * @return An created element.
   */
  function createSvg(tag, attrs) {
      const elm = document.createElementNS('http://www.w3.org/2000/svg', tag);
      attr(elm, attrs);
      return elm;
  }

  /**
   * The stroke linecap value for the path element.
   */
  const STROKE_LINECAP = 'round';
  /**
   * The base class for creating UI, such as a toolbar or a dialog.
   *
   * @since 0.1.0
   */
  class UIComponent extends Component {
      constructor() {
          super(...arguments);
          /**
           * Stores group elements.
           */
          this.groups = {};
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential editor elements.
       */
      mount(elements) {
          super.mount(elements);
          this.create();
          this.listen();
      }
      /**
       * Creates elements.
       * Override this method in a child class and provide a wrapper element.
       */
      create() {
          assert$1(false);
      }
      /**
       * Listens to some events.
       */
      listen() {
          this.bind(window, 'keydown', this.escape, this);
      }
      /**
       * Hides the toolbar when the escape key is pressed.
       *
       * @param e - A KeyboardEvent object.
       */
      escape(e) {
          if (this.isActive() && normalizeKey(e.key) === 'Escape') {
              this.hide();
              prevent(e);
          }
      }
      /**
       * Appends the group element to the wrapper element just before displaying the UI.
       * Override this method to change the default element to append the group to.
       *
       * @param group - A group ID.
       */
      append(group) {
          append(this.wrapper, this.groups[group].elm);
      }
      /**
       * Sets focus to the first element that has the greatest tab index.
       * If it is not found, sets focus to the first input or button element if available.
       *
       * @param group - A group ID.
       */
      autoFocus(group) {
          const { elm } = this.groups[group];
          const target = query(elm, '[tabindex]') || query(elm, 'input, button');
          if (target) {
              target.focus();
              if (target instanceof HTMLInputElement) {
                  target.select();
              }
          }
      }
      /**
       * Creates a close button.
       * The wrapper element must exist and have an ID attribute before calling this method.
       *
       * @param attrs - Attributes for the button.
       *
       * @return A created button element.
       */
      createCloseButton(attrs) {
          const button = this.createButtons({
              id: 'close',
              icon: 'close',
              click: 'hide',
          }, null, this).close;
          attr(button, attrs);
          return button;
      }
      /**
       * Creates buttons according to the settings.
       *
       * @param settings  - A settings object.
       * @param parent    - A parent element to append the button to.
       * @param component - A component instance.
       * @param classes   - Additional classes for buttons.
       *
       * @return An object with created buttons.
       */
      createButtons(settings, parent, component, classes) {
          const buttons = {};
          toArray(settings).forEach(settings => {
              const button = this.createButton(settings, parent, classes);
              const { click } = settings;
              if (click) {
                  this.bind(button, 'click', e => {
                      if (isString(click)) {
                          component[click]();
                      }
                      else {
                          click(e, this.Editor, settings);
                      }
                  });
              }
              buttons[settings.id] = button;
          }, []);
          return buttons;
      }
      /**
       * Creates a button with the provided settings.
       *
       * @param settings - A settings object.
       * @param parent   - A parent element to append the button to.
       * @param classes  - Additional classes for buttons.
       *
       * @return A created button element.
       */
      createButton(settings, parent, classes) {
          const { i18n } = this.options;
          const { checkbox, tabindex, icon: iconName } = settings;
          const label = i18n[settings.i18n || settings.id];
          classes = [CLASS_BUTTON].concat(iconName ? `${CLASS_BUTTON}--icon` : null, classes);
          const button = create('button', {
              title: iconName ? label : null,
              type: 'button',
              tabindex: !isUndefined$1(tabindex) ? tabindex : null,
              role: checkbox ? 'checkbox' : null,
              'aria-checked': checkbox ? 'false' : null,
              'aria-label': label,
          }, parent || settings.parent);
          addClass(button, classes);
          if (iconName) {
              const iconSettings = this.options.icons[iconName];
              if (iconSettings) {
                  append(button, icon(iconSettings[0], iconSettings[1], iconSettings[2] || STROKE_LINECAP));
              }
          }
          else {
              html$2(button, settings.html || label);
          }
          return button;
      }
      /**
       * A utility function to create an input field.
       *
       * @param settings - A settings object.
       * @param parent   - A parent element where the created input element will be appended.
       *
       * @return A created input element.
       */
      createField(settings, parent) {
          const label = this.i18n[settings.i18n || settings.id];
          const { tabindex } = settings;
          return create('input', {
              class: `${CLASS_INPUT}`,
              placeholder: label,
              spellcheck: false,
              tabindex: !isUndefined$1(tabindex) ? tabindex : null,
              'aria-label': label,
          }, parent);
      }
      /**
       * Displays the UI.
       *
       * @param group - A group ID.
       */
      show(group) {
          if (this.isActive()) {
              remove(this.groups[this.group].elm);
          }
          addClass(this.wrapper, CLASS_ACTIVE);
          this.append(group);
          this.group = group;
      }
      /**
       * Hides the UI.
       */
      hide() {
          if (this.isActive()) {
              removeClass(this.wrapper, CLASS_ACTIVE);
              remove(this.groups[this.group].elm);
          }
      }
      /**
       * Checks if the specified group is active or not.
       * If omitted, this checks any group is active or not.
       *
       * @param group - Optional. A group ID to check.
       */
      isActive(group) {
          return hasClass(this.wrapper, CLASS_ACTIVE) && (!group || this.group === group);
      }
      /**
       * Checks if one of the elements in the UI has focus or not.
       *
       * @return `true` if an element in the UI has focus, or otherwise `false`.
       */
      isFocused() {
          return this.wrapper.contains(activeElement());
      }
  }

  /**
   * The ID for the main context menu.
   */
  const MAIN_CONTEXT_MENU_ID = 'main';
  /**
   * The collection of "edit" items for the context menu.
   *
   * @since 0.1.0
   */
  const CONTEXT_MENU_EDIT = [
      {
          id: 'copy',
          shortcut: ['C', true],
      },
      {
          id: 'cut',
          shortcut: ['X', true],
          disableOnReadOnly: true,
      },
      {
          id: 'paste',
          shortcut: ['V', true],
          disableOnReadOnly: true,
      },
  ];
  /**
   * The collection of "selection" items for the context menu.
   *
   * @since 0.1.0
   */
  const CONTEXT_MENU_SELECTION = [
      {
          id: 'selectAll',
          shortcut: ['A', true],
      },
  ];

  /**
   * The margin from the menu to the right of the window.
   *
   * @since 0.1.0
   */
  const MARGIN_RIGHT = 5;
  /**
   * The margin from the menu to the bottom of the window.
   *
   * @since 0.1.0
   */
  const MARGIN_BOTTOM = 5;
  /**
   * The class for creating a context menu replacing the native one.
   *
   * @since 0.1.0
   */
  class ContextMenu extends UIComponent {
      constructor() {
          super(...arguments);
          /**
           * The index of the current menu item.
           */
          this.index = -1;
      }
      /**
       * Listens some events.
       */
      listen() {
          super.listen();
          const { elements } = this;
          this.bind(elements.editor, 'mousedown', this.onMouseDown, this);
          this.bind(document, 'contextmenu', this.onContextMenu, this);
          this.bind(window, 'keydown', this.onKeydown, this);
          this.on([EVENT_BLUR, EVENT_SCROLLER_SCROLL, EVENT_WINDOW_SCROLL], this.hide, this);
          this.bind(elements.root, 'focusin', () => {
              if (!this.contains(activeElement()) && !this.wrapper.contains(activeElement())) {
                  this.hide();
              }
          });
      }
      /**
       * Creates the context menu elements.
       *
       * @link https://www.w3.org/TR/wai-aria-1.2/#menu
       */
      create() {
          this.wrapper = div({ class: CLASS_CONTEXT_MENU, role: 'menu' }, this.elements.overlay);
      }
      /**
       * Called when the mouse button is clicked.
       * If the button number is 2, which means a right click,
       * displays the menu and moves it at the cursor location, otherwise hides the menu.
       *
       * @param e - A MouseEvent object.
       */
      onMouseDown(e) {
          if (e.button === 2) {
              this.show(MAIN_CONTEXT_MENU_ID);
              this.move(e.clientX, e.clientY);
          }
          else {
              this.hide();
          }
      }
      /**
       * Called when the contextmenu event of the document is fired.
       * Since the context menu may scroll the scroller or the window,
       * displaying the menu at this moment is too early.
       *
       * @param e - An Event object.
       */
      onContextMenu(e) {
          if (this.isActive()) {
              return prevent(e);
          }
          if (this.contains(e.target)) {
              const { Selection } = this;
              if (!Selection.is(IDLE)) {
                  this.View.jump(Selection.focus[0]);
                  requestAnimationFrame(() => {
                      const { rect } = this.Caret;
                      this.show(MAIN_CONTEXT_MENU_ID);
                      this.move(rect.left, rect.bottom);
                  });
              }
              prevent(e, true);
          }
      }
      /**
       * Called when the window receives the keydown.
       *
       * @param e - A KeyboardEvent object.
       */
      onKeydown(e) {
          if (this.isActive()) {
              const key = normalizeKey(e.key);
              const arrowUp = key === 'ArrowUp';
              if (key === 'ArrowDown' || arrowUp) {
                  this.focus(arrowUp);
                  prevent(e);
              }
          }
      }
      /**
       * Sets focus on the menu item in order.
       *
       * @param backwards - Whether to decrement or increment the menu index.
       */
      focus(backwards) {
          const buttons = queryAll(this.wrapper, `.${CLASS_CONTEXT_MENU_BUTTON}`);
          const { length } = buttons;
          if (length) {
              this.index += backwards ? -1 : 1;
              if (this.index < 0) {
                  this.index = length - 1;
              }
              else if (this.index >= length) {
                  this.index = 0;
              }
              buttons[this.index].focus();
          }
      }
      /**
       * Moves the menu to the provided client coordinates.
       *
       * @param clientX - A client x coordinate.
       * @param clientY - A client y coordinate.
       */
      move(clientX, clientY) {
          const { wrapper, wrapper: { clientWidth }, Measure: { scrollerRect } } = this;
          const { documentElement } = document;
          if (clientX + clientWidth > documentElement.clientWidth - MARGIN_RIGHT) {
              clientX -= clientWidth;
          }
          clientY = min(clientY, height(documentElement) - height(wrapper) - MARGIN_BOTTOM);
          styles(wrapper, {
              top: unit(clientY - scrollerRect.top),
              left: unit(clientX - scrollerRect.left),
          });
      }
      /**
       * Checks whether the editor contains the passed element/event target or not.
       *
       * @param target - An EventTarget object that is an Element instance in most cases.
       *
       * @return `true` if the editor contains the target, or otherwise `false`.
       */
      contains(target) {
          return isHTMLElement(target) && this.elements.editor.contains(target);
      }
      /**
       * Creates elements for menu items.
       *
       * @param group - A group ID.
       */
      build(group) {
          const { lists, elm } = this.groups[group];
          text(elm, '');
          forOwn$1(lists, (settings, key) => {
              const list = create('ul', [CLASS_CONTEXT_MENU_LIST, `${CLASS_CONTEXT_MENU_LIST}--${key}`], elm);
              settings = settings.map(settings => {
                  settings.parent = create('li', CLASS_CONTEXT_MENU_ITEM, list);
                  return settings;
              });
              const buttons = this.createButtons(settings, null, this, CLASS_CONTEXT_MENU_BUTTON);
              forOwn$1(buttons, (button, id) => {
                  const buttonSettings = this.findSettings(settings, id);
                  assert$1(buttonSettings);
                  attr(button, { role: 'menuitem' });
                  this.bind(button, 'click', () => {
                      this.emit(EVENT_CONTEXT_MENU_CLICKED, this, id, button);
                      this.hide();
                  });
                  if (buttonSettings.disableOnReadOnly) {
                      button.disabled = this.Editor.readOnly;
                      this.on(EVENT_READONLY, (e, readOnly) => { button.disabled = readOnly; });
                  }
                  this.bind(button, 'mouseover', () => {
                      button.focus();
                  });
              });
              this.buttons = assign$1({}, this.buttons, buttons);
          });
      }
      /**
       * Finds the each button settings from the array of settings.
       *
       * @param settings - An array with settings.
       * @param id       - A button ID to find.
       *
       * @return The found button settings.
       */
      findSettings(settings, id) {
          for (let i = 0; i < settings.length; i++) {
              if (settings[i].id === id) {
                  return settings[i];
              }
          }
      }
      /**
       * Registers a menu item or items.
       *
       * @example
       *
       * Registers a new item to the "edit" list in the "main" context menu:
       * ```ts
       * const ryuseiCode = new RyuseiCode();
       * ryuseiCode.apply( 'textarea' );
       *
       * const { ContextMenu } = ryuseiCode.Editor.Components;
       *
       * ContextMenu.register( 'main', 'edit', {
       *   id  : 'myButton',
       *   html: 'Click Me',
       *   click() {
       *     console.log( 'Clicked! );
       *   },
       * } );
       * ```
       *
       * Registers a new list and items to the the "main" context menu:
       * ```ts
       * const ryuseiCode = new RyuseiCode();
       * ryuseiCode.apply( 'textarea' );
       *
       * const { ContextMenu } = ryuseiCode.Editor.Components;
       *
       * ContextMenu.register( 'main', 'my-list', [
       *   {
       *     id  : 'button1',
       *     html: 'Button 1',
       *     click() {
       *       console.log( 'You clicked the Button 1' );
       *     },
       *   },
       *   {
       *     id  : 'button2',
       *     html: 'Button 2',
       *     click() {
       *       console.log( 'You clicked the Button 2' );
       *     },
       *   },
       * ] );
       * ```
       *
       * Registers a new group:
       * ```ts
       * const ryuseiCode = new RyuseiCode();
       * ryuseiCode.apply( 'textarea' );
       *
       * const { ContextMenu } = ryuseiCode.Editor.Components;
       *
       * ContextMenu.register( 'my-context-menu', 'my-list', [
       *   ...
       * ] );
       *
       * ContextMenu.show( 'my-context-menu' );
       * ```
       *
       * @param group    - A group ID. If it does not exist, a new group will be generated.
       * @param list     - A list ID.
       * @param settings - An menu item or items.
       */
      register(group, list, settings) {
          const { groups } = this;
          if (!groups[group]) {
              groups[group] = {
                  elm: div([CLASS_CONTEXT_MENU_GROUP, `${CLASS_CONTEXT_MENU_GROUP}--${group}`]),
                  lists: {},
              };
          }
          settings.forEach(settings => {
              const label = this.i18n[settings.i18n || settings.id];
              const shortcut = settings.shortcut ? this.Keymap.getShortcut(settings.shortcut) : '';
              settings.html = settings.html || `<span class="${CLASS_CONTEXT_MENU_LABEL}">${label}</span>`
                  + (shortcut ? `<span class="${CLASS_CONTEXT_MENU_SHORTCUT}">${shortcut}</span>` : '');
          });
          const { lists } = groups[group];
          lists[list] = (lists[list] || []).concat(settings);
      }
      /**
       * Displays the specified context menu.
       *
       * @param group - A group ID.
       */
      show(group) {
          if (this.groups[group]) {
              this.build(group);
              super.show(group);
              this.index = -1;
              this.emit(EVENT_CONTEXT_MENU_OPENED);
          }
      }
      /**
       * Hides the context menu.
       */
      hide() {
          if (this.isActive()) {
              super.hide();
              this.buttons = null;
              this.emit(EVENT_CONTEXT_MENU_CLOSED);
          }
      }
  }

  /**
   * Holds the clipboard object. IE does not support this object.
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Navigator/clipboard
   *
   * @since 0.1.0
   */
  const { clipboard } = navigator;
  /**
   * The class for normalizing different copy/paste behaviours in browsers.
   *
   * @since 0.1.0
   */
  class Clipboard {
      /**
       * Creates a temporary textarea element.
       *
       * @param text - A value for the textarea.
       *
       * @return A created element.
       */
      create(text) {
          const textarea = create('textarea', {}, document.body);
          const offset = '-999999px';
          styles(textarea, { position: 'absolute', top: offset, left: offset });
          textarea.value = text;
          focus(textarea);
          textarea.setSelectionRange(0, text.length);
          return textarea;
      }
      /**
       * Pastes the text via execCommand for old browsers.
       *
       * @return A pasted text.
       */
      execPaste() {
          const textarea = this.create('');
          document.execCommand('paste');
          const { value } = textarea;
          remove(textarea);
          return value;
      }
      /**
       * Copies the provided text via execCommand for old browsers.
       *
       * @param text     - A text to copy.
       * @param onFailed - Optional. A callback fired when copy failed.
       */
      execCopy(text, onFailed) {
          const textarea = this.create(text);
          try {
              document.execCommand('copy');
          }
          catch (e) {
              if (onFailed) {
                  onFailed();
              }
          }
          remove(textarea);
      }
      /**
       * Pastes the clipboard text.
       *
       * @param onPaste - A callback fired after pasting a text, taking a pasted value as the first argument.
       */
      paste(onPaste) {
          if (clipboard) {
              clipboard.readText().then(onPaste);
          }
          else {
              onPaste(this.execPaste());
          }
      }
      /**
       * Copies the passed text.
       *
       * @param text     - A text to copy.
       * @param onFailed - Optional. A callback fired when copy failed.
       */
      copy(text, onFailed) {
          if (clipboard) {
              clipboard.writeText(text).catch(() => {
                  this.execCopy(text, onFailed);
              });
          }
          else {
              this.execCopy(text, onFailed);
          }
      }
  }

  /**
   * The class for editing the code.
   *
   * @since 0.1.0
   */
  class Edit extends Component {
      constructor() {
          super(...arguments);
          /**
           * Holds the Clipboard instance.
           */
          this.clipboard = new Clipboard();
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential editor elements.
       */
      mount(elements) {
          super.mount(elements);
          this.register();
          this.listen();
      }
      /**
       * Listens to some events.
       */
      listen() {
          const { editable } = this.elements;
          this.on(EVENT_KEYDOWN, this.onKeydown, this);
          this.bind(editable, 'paste', this.onPaste, this);
          this.bind(editable, 'copy cut', e => {
              this[e.type]();
          });
          this.bind(editable, 'dragover drop paste cut', e => {
              prevent(e, true);
          });
          this.on(EVENT_CONTEXT_MENU_CLICKED, this.onMenuClick, this);
          if (isIE()) {
              this.bind(editable, 'compositionstart', e => {
                  if (this.deletedByInput) {
                      prevent(e, true);
                  }
              });
          }
      }
      /**
       * Called when any key is pressed.
       *
       * @param e  - An EventBusEvent object.
       * @param ke - A KeyboardEvent object.
       */
      onKeydown(e, ke) {
          const { Selection } = this;
          const key = normalizeKey(ke.key);
          const isKey = (keys) => includes(toArray(keys), key);
          this.deletedByInput = false;
          if (this.Keymap.matches(ke, 'selectAll')) {
              Selection.selectAll();
              return prevent(ke, true);
          }
          if (ke.altKey || ke.metaKey || ke.ctrlKey) {
              return;
          }
          if (Selection.isMultiline()) {
              if (key.length === 1 || isKey(['Process', 'Enter'])) {
                  this.delete();
                  this.deletedByInput = true;
              }
              else if (isKey(['Delete', 'Backspace'])) {
                  this.delete();
                  prevent(ke);
              }
          }
      }
      /**
       * Called when the context menu item is clicked.
       *
       * @param e    - An EventBusEvent object.
       * @param menu - A ContextMenu instance.
       * @param id   - The ID of the clicked item.
       */
      onMenuClick(e, menu, id) {
          const { Selection } = this;
          if (id === 'copy' || id === 'cut') {
              if (!this.isSelected()) {
                  Selection.selectLine(undefined, id === 'copy', true);
              }
              this[id]();
          }
          else if (id === 'paste') {
              this.clipboard.paste(this.paste.bind(this));
          }
          else if (id === 'selectAll') {
              Selection.selectAll();
          }
      }
      /**
       * Called when the text is being pasted to the editor.
       *
       * @param e - A ClipboardEvent object.
       */
      onPaste(e) {
          const string = (e.clipboardData || window['clipboardData']).getData('text');
          if (string) {
              this.paste(string);
          }
          prevent(e);
      }
      /**
       * Registers items to the context menu.
       */
      register() {
          const { ContextMenu } = this;
          ContextMenu.register(MAIN_CONTEXT_MENU_ID, 'edit', CONTEXT_MENU_EDIT);
          ContextMenu.register(MAIN_CONTEXT_MENU_ID, 'selection', CONTEXT_MENU_SELECTION);
      }
      /**
       * Checks if some texts are selected or not.
       * Be aware that this is not same with negating getSelection().isCollapsed.
       *
       * @return `true` if some texts are selected, or otherwise `false`.
       */
      isSelected() {
          return !this.Selection.isCollapsed();
      }
      /**
       * Checks if the Editor is editable or not.
       *
       * @return `true` if the Editor is editable.
       */
      isEditable() {
          return !this.Editor.readOnly;
      }
      /**
       * Deletes the selected text. Nothing will happen when the selection is collapsed.
       */
      delete() {
          if (this.isSelected()) {
              this.paste('', 'delete');
          }
      }
      /**
       * Pastes the provided text at the current position.
       *
       * @param string - A string to paste.
       * @param type   - Optional. Specifies the input type.
       */
      paste(string, type = 'paste') {
          if (!this.isEditable()) {
              return;
          }
          if (type === 'paste') {
              this.emit(EVENT_PASTE, string);
          }
          const { Selection, Code } = this;
          const { start, end } = Selection.get();
          const size = count(string, LINE_BREAK$1) + 1;
          const startRow = start[0];
          const endRow = startRow + size - 1;
          const endLine = string.slice(string.lastIndexOf(LINE_BREAK$1) + 1);
          const col = endLine.length + (size > 1 ? 0 : start[1]);
          const position = [endRow, col];
          this.emit(EVENT_CHANGE, type);
          Code.replaceRange(start, end, string);
          this.Sync.sync(startRow, endRow, endRow);
          Selection.set(position);
          this.emit(EVENT_CHANGED, type);
      }
      /**
       * Copies the provided text to the clipboard.
       * If the text is not provided, this method tries to copy the current selection.
       *
       * @param string        - Optional. A string to copy.
       * @param skipSelection - Optional. Whether to restore the selection range after copy or not.
       */
      copy(string, skipSelection) {
          const { failedToCopy } = this.i18n;
          const onFailed = () => {
              if (this.require('Dialog')) {
                  this.invoke('Dialog', 'message', failedToCopy);
              }
              else {
                  alert(this.i18n.failedToCopy);
              }
          };
          const copySelection = isUndefined$1(string);
          string = copySelection ? this.Selection.toString() : string;
          this.emit(EVENT_COPY, string);
          const { Selection } = this;
          const range = Selection.get(false);
          this.clipboard.copy(string, onFailed);
          if (!skipSelection) {
              Selection.set(range.start, range.end);
          }
      }
      /**
       * Cuts the selected code. Nothing will happen if the selection is collapsed.
       */
      cut() {
          if (this.isSelected() && this.isEditable()) {
              this.emit(EVENT_CUT);
              this.copy(undefined, true);
              this.delete();
          }
      }
      /**
       * Cuts the current line.
       */
      cutLine() {
          if (!this.isEditable()) {
              return;
          }
          this.emit(EVENT_CUT);
          const { Selection } = this;
          const { start: [startRow] } = Selection.get();
          const position = [startRow, 0];
          this.View.jump(startRow);
          Selection.selectLine(startRow, false);
          this.copy(undefined, true);
          Selection.update(position);
          this.emit(EVENT_CHANGE);
          this.Code.replaceLines(startRow, startRow, '');
          this.Sync.sync(startRow, startRow);
          Selection.set(position);
          this.emit(EVENT_CHANGED);
      }
  }

  /**
   * The input type for composition.
   *
   * @since 0.1.0
   */
  const COMPOSITION_INPUT_TYPE = 'composition';
  /**
   * The class for handling the user input.
   *
   * @since 0.1.0
   */
  class Input extends Component {
      /**
       * Initialized the component.
       *
       * @param elements - A collection of essential editor elements.
       */
      mount(elements) {
          super.mount(elements);
          this.listen();
      }
      /**
       * Listen to some events.
       */
      listen() {
          const { editable } = this.elements;
          this.bind(editable, 'keydown', this.onKeydown, this);
          this.bind(editable, isIE() ? 'textinput' : 'input', this.onInput, this);
          this.bind(editable, 'compositionstart', this.onCompositionStart, this);
          this.bind(editable, 'compositionupdate', this.onCompositionUpdate, this);
          this.bind(editable, 'compositionend', this.onCompositionEnd, this);
          this.on(EVENT_FOCUS_LINE_CHANGED, (e, line, row) => {
              this.line = line;
              this.row = row;
          });
      }
      /**
       * Called when the composition starts.
       * Needs to emit the `change` event at this timing to save the start position.
       * Note that some browsers do not support a CompositionEvent object.
       *
       * @param e - A CompositionEvent object or a regular Event object.
       */
      onCompositionStart(e) {
          if (this.disabled) {
              const { Editor, Selection } = this;
              const range = Selection.get(false);
              getSelection().removeAllRanges();
              Editor.blur();
              nextTick(() => {
                  Editor.focus();
                  Selection.set(range.start, range.end);
              });
              return;
          }
          this.composing = true;
          this.set(COMPOSITION_INPUT_TYPE);
          this.emit(EVENT_COMPOSITION_START, e);
          this.emit(EVENT_CHANGE, COMPOSITION_INPUT_TYPE);
      }
      /**
       * Called whenever the composing content is updated.
       *
       * @param e - A CompositionEvent object or a regular Event object.
       */
      onCompositionUpdate(e) {
          nextTick(() => {
              this.Selection.update(this.getCaretPosition());
              this.emit(EVENT_COMPOSITION_UPDATE, e);
          });
      }
      /**
       * Called when the composition ends.
       *
       * @param e - A CompositionEvent object or a regular Event object.
       */
      onCompositionEnd(e) {
          this.composing = false;
          this.apply();
          this.emit(EVENT_COMPOSITION_END, e);
      }
      /**
       * Called whenever any key is pressed.
       *
       * @param e - A KeyboardEvent object.
       */
      onKeydown(e) {
          const key = normalizeKey(e.key);
          const { altKey, shiftKey } = e;
          if (this.disabled && !ARROW_KEYS.includes(key)) {
              return prevent(e, true);
          }
          this.emit(EVENT_KEYDOWN, e);
          if (isPrevented(e)) {
              return;
          }
          this.info = this.lines.getInfoAt(this.getCaretPosition());
          this.set('input', { key });
          if (key === 'Enter') {
              this.handleEnter(e);
              return;
          }
          if (this.Selection.isCollapsed()) {
              if (key === 'Delete' && !shiftKey && !altKey) {
                  this.handleDelete(e);
              }
              else if (key === 'Backspace' && !altKey) {
                  this.handleBackspace(e);
              }
          }
      }
      /**
       * Called whenever any input is received.
       * Need to wait for the `compositionend` before calling `apply()`.
       */
      onInput(e) {
          this.emit(EVENT_INPUT, this, e);
          if (!this.composing) {
              this.apply();
          }
      }
      /**
       * Handles the Enter key.
       *
       * @param e - A KeyboardEvent object.
       */
      handleEnter(e) {
          if (!this.composing) {
              this.set('newline', {
                  key: 'Enter',
                  value: this.before + LINE_BREAK$1 + this.after,
                  position: [this.row + 1, 0],
              });
              this.emit(EVENT_NEWLINE, this);
              this.apply();
              prevent(e);
          }
      }
      /**
       * Handles the delete key.
       *
       * @param e - A KeyboardEvent object.
       */
      handleDelete(e) {
          const { row, lines } = this;
          if (this.col === this.value.length && row < lines.length - 1) {
              this.apply({
                  type: 'deleteNext',
                  key: 'Delete',
                  value: this.value + lines[row + 1].text,
                  startRow: row,
                  endRow: row + 1,
              });
              prevent(e);
          }
      }
      /**
       * Handles the backspace key.
       */
      handleBackspace(e) {
          const { row, col } = this;
          if (col === 0) {
              if (row > 0) {
                  const prev = this.lines[row - 1].text;
                  this.apply({
                      type: 'removePrev',
                      key: 'Backspace',
                      value: prev + this.value,
                      startRow: row - 1,
                      position: [row - 1, prev.length],
                  });
              }
              prevent(e);
          }
      }
      /**
       * Appends a line break if the provided row is not the end of the document.
       *
       * @param value - A value where the line break will be appended.
       * @param row   - Optional. A row index.
       *
       * @return The value with the line break, or the provided value itself.
       */
      appendLineBreak(value, row = this.row) {
          return value + (row < this.lines.length - 1 ? LINE_BREAK$1 : '');
      }
      /**
       * Settles the final value to apply.
       *
       * @param value  - A value to settle.
       * @param endRow - An end row index.
       */
      settleValue(value, endRow) {
          const { state } = this;
          if (state) {
              if (state.insertion) {
                  value = this.before + state.insertion + this.after;
              }
              else if (!isUndefined$1(state.value)) {
                  value = state.value;
              }
          }
          return this.appendLineBreak(value, endRow);
      }
      /**
       * Settles the final position to apply.
       *
       * @param position - A position to settle.
       */
      settlePosition(position) {
          const { state } = this;
          if (state) {
              if (state.position) {
                  return state.position;
              }
              position[1] += state.offset || 0;
          }
          return position;
      }
      /**
       * Returns the current caret position.
       *
       * @return A position of the caret.
       */
      getCaretPosition() {
          return [this.row, this.col];
      }
      /**
       * Sets the input state.
       * If the state with the provided type exists, new props will be assigned to it.
       *
       * @param type  - The type of the state.
       * @param props - Optional. An object with state values.
       */
      set(type, props = {}) {
          const { state } = this;
          if (state && state.type === type) {
              this.state = assign$1(state, props);
          }
          else {
              this.state = assign$1({ type }, props);
          }
      }
      /**
       * Returns the current state object.
       */
      get() {
          return this.state;
      }
      /**
       * Applies the current input state to the editor.
       *
       * @param state - Optional. A new state to apply.
       */
      apply(state) {
          this.state = state || this.state;
          if (!this.state || !this.line) {
              return;
          }
          const { Selection, row } = this;
          const { type, startRow = row, endRow = row } = this.state;
          const position = this.getCaretPosition();
          if (type !== COMPOSITION_INPUT_TYPE) {
              this.emit(EVENT_CHANGE, type);
          }
          this.View.jump(endRow);
          this.Code.replaceLines(startRow, endRow, this.settleValue(this.value, endRow));
          this.Sync.sync(startRow, endRow);
          Selection.set(this.settlePosition(position));
          this.emit(EVENT_CHANGED, type);
          this.state = null;
          this.info = null;
      }
      /**
       * Inserts a text at the current or specified index.
       *
       * @param text  - A text to insert.
       * @param index - Optional. An index where the text is inserted.
       */
      insert(text, index = this.col) {
          const { value } = this;
          this.value = value.slice(0, index) + text + value.slice(index);
      }
      /**
       * Returns a character at the current caret position or specified col index.
       *
       * @param col - Optional. A col index of the desired character.
       *
       * @return A character at the specified position.
       */
      char(col = this.col) {
          return this.value.charAt(col);
      }
      /**
       * Returns the value of the current line.
       *
       * @return A text of the current line.
       */
      get value() {
          return text(this.line) || '';
      }
      /**
       * Sets a new value to the current line.
       *
       * @param value - A new value to set.
       */
      set value(value) {
          text(this.line, value);
      }
      /**
       * Returns the string of the current line before the caret position.
       *
       * @return The string before the caret.
       */
      get before() {
          return this.value.slice(0, this.col);
      }
      /**
       * Returns the string of the current line after the caret position.
       *
       * @return The string after the caret.
       */
      get after() {
          return this.value.slice(this.col);
      }
      /**
       * Returns the length of the current line.
       *
       * @return The length of the current line.
       */
      get length() {
          return this.value.length;
      }
      /**
       * Returns the current col index.
       *
       * @return The col index of the caret.
       */
      get col() {
          const { line } = this;
          const selection = getSelection();
          if (line && selection.rangeCount > 0) {
              const range = selection.getRangeAt(0).cloneRange();
              range.setStart(line, 0);
              return range.toString().length;
          }
          return 0;
      }
      /**
       * Returns `true` if the input is disabled.
       *
       * @return `true` if the input is disabled.
       */
      get disabled() {
          return this._disabled;
      }
      /**
       * Makes the input disabled.
       * All keys are ignored while it is disabled.
       */
      set disabled(disabled) {
          this._disabled = disabled;
      }
  }

  /**
   * The component for detecting keyboard shortcuts and distributing them as internal events.
   *
   * @since 0.1.0
   */
  class Keymap extends Component {
      constructor() {
          super(...arguments);
          /**
           * Stores the target keys.
           */
          this.keys = [];
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          super.mount(elements);
          this.keymap = assign$1({}, KEYMAP$6, this.options.keymap);
          forOwn$1(this.keymap, matchers => {
              if (matchers) {
                  this.keys.push(...toArray(matchers, true).map(matcher => {
                      return matcher[0].toUpperCase();
                  }));
              }
          });
          this.on(EVENT_KEYDOWN, this.onKeydown, this, 0);
      }
      /**
       * Called when any key is pressed.
       *
       * @param e  - An EventBusEvent object.
       * @param ke - A KeyboardEvent object.
       */
      onKeydown(e, ke) {
          if (!this.Editor.readOnly) {
              if (includes(this.keys, normalizeKey(ke.key).toUpperCase())) {
                  const action = this.find(ke);
                  if (action) {
                      this.emit(`${EVENT_KEYMAP}:${action}`, ke, action);
                  }
              }
          }
      }
      /**
       * Finds the shortcut action from keymap definition.
       *
       * @param e - A KeyboardEvent object.
       *
       * @return A found action.
       */
      find(e) {
          let action = '';
          forOwn$1(this.keymap, (matchers, id) => {
              if (this.matches(e, id)) {
                  action = id;
                  return false;
              }
          });
          return action;
      }
      /**
       * Checks if the keyboard event matches keys of the provided ID or not.
       *
       * @param e  - A KeyboardEvent object.
       * @param id - An ID.
       *
       * @return `true` if the keyboard event matches keys of the ID, or otherwise `false`.
       */
      matches(e, id) {
          const matchers = this.keymap[id];
          return matchers && matchesKey(e, matchers);
      }
      /**
       * Builds a shortcut that describes keys of the provided keymap ID or a KeyMatcher object.
       * For example, `undo` or `[ 'Z', true ]` will be `Ctrl + Z`.
       *
       * @param id - An ID in a keymap or a KeyMatcher object.
       *
       * @return A built shortcut as a string.
       */
      getShortcut(id) {
          const matchers = isString(id) ? this.keymap[id] : id;
          if (matchers) {
              const matcher = isArray(matchers[0]) ? matchers[0] : matchers;
              if (matcher) {
                  const modifiers = MODIFIER_KEYS[isMac() ? 'mac' : 'default'];
                  const keys = matcher.slice(1).map((use, index) => use && modifiers[index]).filter(Boolean);
                  return keys.concat(matcher[0]).join('+');
              }
          }
          return '';
      }
  }

  /**
   * The utility class for measuring texts.
   *
   * @since 0.1.0
   */
  class MeasureText {
      /**
       * The MeasureText constructor.
       *
       * @param font - A font string for the context.
       */
      constructor(font) {
          /**
           * Stores width of characters.
           */
          this.chars = {};
          this.context = create('canvas').getContext('2d');
          this.context.font = font;
      }
      /**
       * Returns the width of the provided character.
       * Note that IE rounds the width of the text.
       *
       * @param char     - A character to measure.
       * @param useCache - Optional. Determines whether to use the cached width or not.
       *
       * @return The width of the character in pixel.
       */
      getCharWidth(char, useCache = true) {
          const { chars, context } = this;
          return (useCache && chars[char]) || (chars[char] = isIE()
              ? context.measureText(repeat(char, 10)).width / 10
              : context.measureText(char).width);
      }
      /**
       * Returns the width of the provided text.
       *
       * @param text     - A text to measure.
       * @param useCache - Optional. Determines whether to use the cached width or not.
       */
      measure(text, useCache = true) {
          let width = 0;
          for (let i = 0; i < text.length; i++) {
              width += this.getCharWidth(text.charAt(i), useCache);
          }
          return width;
      }
      /**
       * Clears cached width.
       */
      clear() {
          this.chars = {};
      }
  }

  /**
   * The class for measuring offset positions and caches some values.
   *
   * @since 0.1.0
   */
  class Measure extends Component {
      /**
       * The Measure constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(Editor);
          /**
           * Caches the DOMRect objects of some elements.
           */
          this.rectCaches = {};
          this.on(EVENT_MOUNT, this.onMount, this, 0);
      }
      /**
       * Called just before components are mounted.
       * This component must be initialized earlier than other components.
       *
       * @param e        - An EventBusEvent object.
       * @param elements - A collection of essential editor elements.
       */
      onMount(e, elements) {
          this.elements = elements;
          this.createMeasureText();
          this.updatePadding();
          this.listen();
      }
      /**
       * Listens to some events.
       * The resize handler must be executed after the Style update listener and before others.
       */
      listen() {
          this.on(EVENT_RESIZE, () => {
              this.lineHeightCache = 0;
              this.updatePadding();
              this.createMeasureText();
              this.clearRectCaches();
          }, 1);
          this.on(EVENT_FONT_LOADED, () => {
              this.measureText.clear();
          }, 1);
          this.on([EVENT_SCROLL_HEIGHT_CHANGED, EVENT_SCROLLED, EVENT_WINDOW_SCROLL], this.clearRectCaches, this, 1);
      }
      /**
       * Updates the cache of the padding.
       */
      updatePadding() {
          const { editor } = this.elements;
          const line = div(CLASS_LINE, editor);
          this.padding = {
              top: parseFloat(styles(editor, 'paddingTop')) || 0,
              bottom: parseFloat(styles(editor, 'paddingBottom')) || 0,
              left: parseFloat(styles(line, 'paddingLeft')) || 0,
              right: parseFloat(styles(line, 'paddingRight')) || 0,
          };
          remove(line);
      }
      /**
       * Creates a `MeasureText` instance only when the font settings are changed.
       */
      createMeasureText() {
          const font = this.buildCSSFont();
          if (this.font !== font) {
              this.measureText = new MeasureText(font);
              this.font = font;
          }
      }
      /**
       * Returns the CSS font string of the current environment.
       *
       * @return A built string.
       */
      buildCSSFont() {
          const { lines } = this.elements;
          return `${styles(lines, 'fontSize')} ${styles(lines, 'fontFamily')}`;
      }
      /**
       * Clears the all rect caches.
       */
      clearRectCaches() {
          this.rectCaches = {};
      }
      /**
       * Returns a top position of the line at the provided row.
       *
       * @param row - A row index.
       *
       * @return A top position in px.
       */
      getTop(row) {
          return clamp(row, 0, this.lines.length - 1) * this.lineHeight;
      }
      /**
       * Returns a bottom position of the line at the provided row.
       *
       * @param row - A row index.
       *
       * @return A bottom position in px.
       */
      getBottom(row) {
          const { Code } = this;
          const isLast = row >= Code.size - 1;
          return this.getTop(row + 1) + (isLast ? this.lineHeight : 0);
      }
      /**
       * Finds the closest row index with the provided position.
       *
       * @param top - A top position to search for.
       *
       * @return The closest row index.
       */
      closest(top) {
          const row = round((top - this.padding.top) / this.lineHeight);
          return clamp(row, 0, this.lines.length - 1);
      }
      /**
       * Measures the provided string and returns the width.
       *
       * @param string   - A string to measure.
       * @param useCache - Optional. Determines whether to use the cached width or not..
       *
       * @return The width of the string.
       */
      measureWidth(string, useCache = true) {
          return this.measureText.measure(string, useCache);
      }
      /**
       * Converts the passed position to the BoundaryRect object.
       *
       * @param position - A position to convert.
       *
       * @return An object literal with top and left positions.
       */
      getOffset(position) {
          const { padding } = this;
          const line = position[0] === this.Selection.focus[0] ? this.Input.value : this.Code.getLine(position[0]);
          return {
              top: this.getTop(position[0]) + padding.top,
              left: this.measureWidth(line.slice(0, position[1])) + padding.left,
          };
      }
      /**
       * Returns a DOMRect object of the editor element.
       *
       * @return A DOMRect object.
       */
      get editorRect() {
          return (this.rectCaches.editor = this.rectCaches.editor || rect(this.elements.editor));
      }
      /**
       * Returns a DOMRect object of the scroller element.
       *
       * @return A DOMRect object.
       */
      get scrollerRect() {
          return (this.rectCaches.scroller = this.rectCaches.scroller || rect(this.elements.scroller));
      }
      /**
       * Returns a DOMRect object of the container element.
       *
       * @return A DOMRect object.
       */
      get containerRect() {
          return (this.rectCaches.container = this.rectCaches.container || rect(this.elements.container));
      }
      /**
       * Returns the line height in px.
       *
       * @return Line height in px.
       */
      get lineHeight() {
          return (this.lineHeightCache = this.lineHeightCache
              || parseFloat(styles(this.elements.editor, 'lineHeight')));
      }
  }

  /**
   * The class for highlighting arbitrary texts.
   *
   * @since 0.1.0
   */
  class Marker {
      /**
       * The Marker constructor.
       *
       * @param Editor   - An Editor instance.
       * @param elements - A collection of editor elements.
       */
      constructor(Editor, elements) {
          this.Editor = Editor;
          this.elements = elements;
          this.scroller = elements.scroller;
      }
      /**
       * Calculates boundaries for drawing the marker.
       *
       * @param anchor - An anchor position.
       * @param focus  - A focus position.
       *
       * @return An object with start and end boundaries.
       */
      calcBoundaries(anchor, focus) {
          const { Measure } = this.Editor.Components;
          const isBackward = compare(anchor, focus) > 0;
          return {
              start: Measure.getOffset(isBackward ? focus : anchor),
              end: Measure.getOffset(isBackward ? anchor : focus),
          };
      }
      /**
       * Generates HTML of the marker.
       *
       * @param anchor   - An anchor position.
       * @param focus    - A focus position.
       * @param useCache - A focus position.
       *
       * @return The generated HTML string of the marker.
       */
      html(anchor, focus, useCache = true) {
          if (useCache && this.cache) {
              return this.cache;
          }
          const { Measure: { lineHeight, padding } } = this.Editor.Components;
          const { start, end } = this.calcBoundaries(anchor, focus);
          const diff = end.top - start.top;
          const fillHeight = diff - lineHeight;
          const startLeft = max(start.left, padding.left);
          let html = '';
          if (diff) {
              html += this.buildLine(start.top, startLeft, '100%');
              html += this.buildLine(end.top, padding.left, max(end.left - padding.left, 0));
              if (fillHeight > 0) {
                  html += this.buildLine(start.top + lineHeight, padding.left, '100%', fillHeight);
              }
          }
          else {
              html += this.buildLine(start.top, startLeft, max(end.left - startLeft, 0));
          }
          this.cache = html;
          return html;
      }
      /**
       * Builds HTML of each line.
       *
       * @param top    - A top position.
       * @param left   - A left position.
       * @param width  - Width.
       * @param height - Optional. Height.
       *
       * @return A generated HTML string.
       */
      buildLine(top, left, width, height) {
          let styles = `top: ${unit(top)}; left: ${unit(left)}; width: ${unit(width)};`;
          if (height) {
              styles += ` height: ${unit(height)};`;
          }
          return `<div class="${CLASS_MARKER}" style="${styles}"></div>`;
      }
  }

  /**
   * The class for highlighting arbitrary texts.
   *
   * @since 0.1.0
   */
  class StandaloneMarker extends Marker {
      /**
       * The Marker constructor.
       *
       * @param Editor   - An Editor instance.
       * @param elements - A collection of editor elements.
       * @param classes  - Optional. Class names for the wrapper element.
       */
      constructor(Editor, elements, classes) {
          super(Editor, elements);
          this.wrapper = div([CLASS_MARKERS].concat(classes), elements.background);
      }
      /**
       * Draws the range for the anchor to the focus.
       *
       * @param anchor - An anchor position.
       * @param focus  - A focus position.
       */
      draw(anchor, focus) {
          html$2(this.wrapper, this.html(anchor, focus, false));
      }
      /**
       * Clears the marker.
       */
      clear() {
          html$2(this.wrapper, '');
      }
      /**
       * Checks if the provided client position is inside the current range or not.
       *
       * @param clientX - X position that is relative to the client.
       * @param clientY - Y position that is relative to the client.
       *
       * @return `true` if the position is inside the range, or otherwise `false`.
       */
      isInside(clientX, clientY) {
          const { children } = this.wrapper;
          for (let i = 0; i < children.length; i++) {
              const domRect = rect(children[i]);
              if (domRect.width
                  && between(clientX, domRect.left, domRect.right)
                  && between(clientY, domRect.top, domRect.bottom)) {
                  return true;
              }
          }
          return false;
      }
      /**
       * Destroys the instance.
       */
      destroy() {
          remove(this.wrapper);
      }
  }

  /**
   * The modifier class for the selection marker.
   *
   * @since 0.1.0
   */
  const CLASS_MARKER_SELECTION = `${CLASS_MARKERS}--selection`;
  /**
   * The class for highlighting a selection range.
   *
   * @since 0.1.0
   */
  class SelectionMarker extends StandaloneMarker {
      /**
       * The SelectionMarker constructor.
       *
       * @param editor   - An Editor instance.
       * @param elements - A collection of editor elements.
       */
      constructor(editor, elements) {
          super(editor, elements, CLASS_MARKER_SELECTION);
          this.listen();
      }
      /**
       * Listens to some events.
       */
      listen() {
          const { event } = this.Editor;
          event.on(EVENT_SELECTED, this.onStateChanged.bind(this), this, 0);
          event.on(EVENT_SELECTING, rafThrottle(this.drawSelection.bind(this)));
          event.on(EVENT_RESIZE, () => {
              this.clear();
              this.drawSelection();
          });
      }
      /**
       * Called when the selection state is changed.
       *
       * @param e         - An EventBusEvent object.
       * @param Selection - A Selection instance.
       * @param state     - A new state.
       * @param prev      - A previous state.
       */
      onStateChanged(e, Selection, state, prev) {
          if (Selection.is(COLLAPSED, CHANGED)) {
              this.clear();
          }
          if (Selection.is(CHANGED, SELECTED) && prev !== CLICKED_RIGHT) {
              this.drawSelection();
          }
      }
      /**
       * Draws the current selection.
       */
      drawSelection() {
          const { Selection } = this.Editor.Components;
          if (!Selection.isCollapsed()) {
              const range = Selection.get(false);
              this.draw(range.start, range.end);
          }
          else {
              this.clear();
          }
      }
  }

  /**
   * The throttle duration for calling the `observe` method while scrolling.
   *
   * @since 0.1.0
   */
  const OBSERVE_THROTTLE_DURATION = 200;
  /**
   * Limits the number of ranges to register.
   *
   * @since 0.1.0
   */
  const MAX_RANGES = 10000;
  /**
   * The class for highlighting the selection and arbitrary ranges.
   *
   * @since 0.1.0
   */
  class Range extends Component {
      constructor() {
          super(...arguments);
          /**
           * Stores ranges with categorizing them into arbitrary groups.
           */
          this.ranges = {};
          /**
           * Stores wrapper elements of markers.
           */
          this.groups = {};
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of editor elements.
       */
      mount(elements) {
          super.mount(elements);
          this.selection = new SelectionMarker(this.Editor, elements);
          const observe = this.observe.bind(this, false);
          this.on(EVENT_CHUNK_MOVED, throttle(observe, OBSERVE_THROTTLE_DURATION));
          this.on(EVENT_SCROLLED, observe);
          this.on([EVENT_FONT_LOADED, EVENT_RESIZE], this.observe.bind(this, true));
      }
      /**
       * Observes ranges and draw/hide them.
       *
       * @param refresh - Optional. If `true`, redraws markers without their caches.
       */
      observe(refresh) {
          if (this.Editor) {
              forOwn$1(this.ranges, (ranges, group) => {
                  if (this.groups[group]) {
                      this.draw(group, refresh);
                  }
              });
          }
      }
      /**
       * Draws visible markers.
       *
       * @param group   - A group to draw.
       * @param refresh - Optional. If `true`, redraws markers without their caches.
       */
      draw(group, refresh) {
          const ranges = this.ranges[group];
          let html = '';
          ranges.forEach(data => {
              const { range } = data;
              if (this.isVisible(range)) {
                  html += data.marker.html(range.start, range.end, !refresh);
              }
          });
          this.groups[group].innerHTML = html;
      }
      /**
       * Checks if the range should be drawn or not.
       * This returns `true` when the range boundary is inside the viewport, or the range contains it.
       *
       * @param range - A range to check.
       *
       * @return `true` if the range should be drawn or otherwise `false`.
       */
      isVisible(range) {
          const { Chunk } = this;
          const [startRow] = range.start;
          const [endRow] = range.end;
          return Chunk.includes(startRow) || Chunk.includes(endRow) || between(Chunk.start, startRow, endRow);
      }
      /**
       * Registers ranges to the group and draw them as markers if they are inside viewport.
       * If `concat` is `true`, sequential ranges will be concatenated as a single range.
       *
       * @param group       - A group name.
       * @param ranges      - A range or ranges to draw.
       * @param concat      - Optional. Determines whether to concat sequential ranges into the single one or not.
       * @param constructor - Optional. Specifies the Marker constructor.
       */
      register(group, ranges, concat = true, constructor = Marker) {
          const { ranges: info } = this;
          let lastRange;
          info[group] = info[group] || [];
          ranges = ranges.slice(0, MAX_RANGES);
          for (let i = 0; i < ranges.length; i++) {
              const range = ranges[i];
              if (concat && lastRange && compare(lastRange.end, range.start) === 0) {
                  lastRange.end = range.end;
              }
              else {
                  lastRange = { start: range.start, end: range.end };
                  info[group].push({ range: lastRange, marker: new constructor(this.Editor, this.elements) });
              }
          }
          if (!this.groups[group]) {
              const classes = [CLASS_MARKERS, `${CLASS_MARKERS}--${group}`];
              this.groups[group] = div(classes, this.elements.background);
          }
          this.observe();
      }
      /**
       * Clears ranges and rendered markers in the specified group.
       * If the group name is omitted, all ranges will be cleared.
       *
       * @param group - Optional. A group name to clear.
       */
      clear(group) {
          if (group) {
              const ranges = this.ranges[group];
              if (ranges) {
                  text(this.groups[group], '');
                  this.clearRanges(group);
              }
          }
          else {
              forOwn$1(this.ranges, (markers, key) => { this.clear(key); });
          }
      }
      /**
       * Clears ranges in the specified group.
       * Rendered markers are not cleared.
       *
       * @param group - A group name to clear.
       */
      clearRanges(group) {
          this.ranges[group] = [];
      }
  }

  /**
   * The class for checking a current state or category.
   * States and categories are defined by language tokenizers.
   *
   * @since 0.1.0
   */
  class Scope extends Component {
      /**
       * Checks if the current start position is in the specified state or category.
       * With a `!` prefix, this returns `true` if the position is NOT inside the scope.
       *
       * @param names    - A name or names of scope.
       * @param position - Optional. Specifies the position to check.
       *
       * @return `true` if the start position is inside the scope.
       */
      isIn(names, position) {
          names = toArray(names);
          const states = names.filter(name => name.indexOf('#') > -1);
          const categories = names.filter(name => name.indexOf('#') === -1);
          return this.inState(states, position) && this.inCategory(categories, position);
      }
      /**
       * Checks if the current start position is in the specified state or not.
       * `!` is acceptable.
       *
       * @param states   - A state or state names.
       * @param position - Optional. Specifies the position to check.
       */
      inState(states, position) {
          return this.inScope(states, false, position);
      }
      /**
       * Checks if the current start position is in the specified category or not.
       * `!` is acceptable.
       *
       * @param categories - A state or state names.
       * @param position   - Optional. Specifies the position to check.
       */
      inCategory(categories, position) {
          return this.inScope(categories, true, position);
      }
      /**
       * Checks if the current start position is in the specified state or not.
       * If `category` is `true`, this method checks if the position is in the category or not.
       *
       * @param names    - A state or state names.
       * @param category - Optional. Determines whether to check for a category or not.
       * @param position - Optional. Specifies the position to check.
       */
      inScope(names, category, position) {
          names = toArray(names);
          const negated = names.filter(name => startsWith$1(name, '!')).map(name => name.slice(1));
          if (negated.length && this.inScope(negated, category)) {
              return false;
          }
          names = names.filter(name => !startsWith$1(name, '!'));
          return !names.length || names.some(name => {
              const info = this.lines.getInfoAt(position || this.Selection.get().start);
              return info && info[category ? 'category' : 'state'] === name;
          });
      }
  }

  /**
   * Sets the `contentEditable` attribute of the provided element.
   *
   * @param elm      - An element.
   * @param editable - Whether to set the value to `true` or `false`.
   */
  function toggleEditable(elm, editable) {
      elm.contentEditable = editable ? 'true' : 'false';
  }

  /**
   * The origin position.
   *
   * @since 0.1.0
   */
  const ORIGIN = [0, 0];
  /**
   * The delay time for reselection after scroll ends.
   *
   * @since 0.1.0
   */
  const DELAY_FOR_RESELECTION = 5;

  /**
   * The class for provides the simple event system.
   *
   * @since 0.1.0
   */
  class EventBus {
      constructor() {
          /**
           * Holds all handlers.
           */
          this.handlers = {};
      }
      /**
       * Registers an event handler.
       *
       * @param events   - An event name or names separated by spaces. Use a dot(.) to add a namespace.
       * @param callback - A callback function to register.
       * @param key      - Optional. An object for an identifier of the handler.
       * @param priority - Optional. A priority number for the order in which the callbacks are invoked.
       *                   Lower numbers correspond with earlier execution. The default value is 10.
       */
      on(events, callback, key, priority = 10) {
          toArray(events).filter(Boolean).join(' ').split(' ').forEach(eventNS => {
              const [event, namespace] = eventNS.split('.');
              const eventHandlers = this.handlers[event] || [];
              eventHandlers.push({ event, callback, namespace, priority, key });
              eventHandlers.sort((handler1, handler2) => handler1.priority - handler2.priority);
              this.handlers[event] = eventHandlers;
          });
      }
      /**
       * Removes event handlers registered by `on()`.
       * If only the event name is provided, all handlers that associate with the event are removed.
       * If the event name and namespace are specified, handlers that associate with the event and namespace are removed.
       *
       * @param events - An event name or names separated by spaces. Use a dot(.) to add a namespace.
       * @param key    - Optional. An object for an identifier of the handler.
       */
      off(events, key) {
          toArray(events).filter(Boolean).join(' ').split(' ').forEach(eventNS => {
              const [event, namespace] = eventNS.split('.');
              const eventHandlers = this.handlers[event];
              if (eventHandlers) {
                  if (key || namespace) {
                      this.handlers[event] = eventHandlers.filter(handler => {
                          return !(handler.key === key && handler.namespace === namespace);
                      });
                  }
                  else {
                      this.handlers[event] = [];
                  }
              }
          });
      }
      /**
       * Triggers callback functions.
       *
       * @param event - An event name.
       * @param args  - Optional. Any number of arguments to pass to callback functions.
       */
      emit(event, ...args) {
          const eventHandlers = this.handlers[event];
          const eventObject = { type: event };
          if (eventHandlers) {
              eventHandlers.forEach(handler => { handler.callback(eventObject, ...args); });
          }
      }
      /**
       * Removes all handlers.
       */
      destroy() {
          this.handlers = {};
      }
  }

  /**
   * The class for providing a simple state system.
   *
   * @since 0.1.0
   */
  class State$1 {
      /**
       * The State constructor.
       *
       * @param initial - An initial state.
       */
      constructor(initial) {
          /**
           * The EventBus instance.
           */
          this.event = new EventBus();
          this.state = initial;
      }
      /**
       * Sets a new state.
       *
       * @param state - A state to change to.
       */
      set(state) {
          if (this.state !== state && !this.held) {
              this.prev = this.state;
              this.state = state;
              this.event.emit('changed', state, this.prev);
          }
      }
      /**
       * Checks if the current state is a provided one or one of them.
       * If multiple states are passed, this method checks them by the `or` condition.
       *
       * @param states - A state or states to check.
       */
      is(...states) {
          return includes(slice(states), this.state);
      }
      /**
       * Checks if the previous state is a provided one or one of them.
       * If multiple states are passed, this method checks them by the `or` condition.
       *
       * @param states - A state or states to check.
       */
      isPrev(...states) {
          return includes(slice(states), this.prev);
      }
      /**
       * Holds the current state so that it won't change.
       */
      hold() {
          this.held = true;
      }
      /**
       * Disables to hold the state.
       */
      release() {
          this.held = false;
      }
      /**
       * Registers the event handler.
       *
       * @param events   - An event name or names separated by spaces.
       * @param callback - A callback function to register.
       * @param priority - Optional. A priority number for the order in which the callbacks are invoked.
       */
      on(events, callback, priority) {
          this.event.on(events, callback, this, priority);
      }
  }

  /**
   * The class for observing the selection states.
   *
   * @since 0.1.0
   */
  class State extends State$1 {
      /**
       * The State constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(IDLE);
          /**
           * The WeakMap key for identifying event handlers(just uses a new empty object).
           */
          this.key = {};
          this.Editor = Editor;
          this.elements = Editor.elements;
          this.Selection = Editor.Components.Selection;
          this.listen();
      }
      /**
       * Listens to some events.
       * Note that the `mouseup` event of `window` needs to be listened to instead of the editable element,
       * because users may release the mouse outside of it.
       */
      listen() {
          const { editable } = this.elements;
          const { event } = this.Editor;
          const { key } = this;
          const onKeydown = this.onKeydown.bind(this);
          on(document, 'selectionchange', this.onSelectionChange.bind(this), key);
          on(window, 'pointerup', this.onSelectionEnd.bind(this), key);
          on(editable, 'pointerdown', this.onSelectionStart.bind(this), key);
          on(editable, 'keydown', onKeydown, key);
          on(editable, 'keyup', this.onKeyup.bind(this), key);
          event.on(EVENT_FOCUS, this.onFocus.bind(this));
          event.on(EVENT_BLUR, this.onBlur.bind(this));
      }
      /**
       * Called when the editor is focused.
       */
      onFocus() {
          if (this.is(IDLE)) {
              this.set(COLLAPSED);
          }
      }
      /**
       * Called when the editor is blurred.
       * Needs to check the Components existence because this may be called after destruction.
       */
      onBlur() {
          if (this.Editor.Components) {
              if (!this.isFocused()) {
                  this.set(IDLE);
              }
          }
      }
      /**
       * Called whenever the selection of the document is changed.
       * - Only handles the change made by the editable element.
       * - Detects the selection change that made by the start action, such as `pointerdown` and
       *   makes the state go into the `CHANGED` state.
       * - If the selection changes after `CHANGED`, which means user selects texts and the range is not collapsed,
       *   makes the state go into the `SELECTING` state.
       * - In FF, the event is sometimes fired after `pointerdown`.
       * - In iOS, the event is fired after `pointerup`.
       */
      onSelectionChange() {
          if (activeElement() !== this.Editor.elements.editable) {
              return;
          }
          if (this.is(START, EXTEND)) {
              this.set(CHANGED);
          }
          else if (this.is(CHANGED)) {
              this.set(SELECTING);
          }
          else if (this.is(COLLAPSED, SELECTED)) {
              if (getSelection().isCollapsed) {
                  this.set(CHANGED);
                  this.set(COLLAPSED);
              }
              else {
                  this.set(SELECTING);
                  this.set(SELECTED);
              }
          }
      }
      /**
       * Called when the pointer becomes active or when arrow keys are pressed.
       * If a shift key is pressed,
       * that means the existing selection is being updated instead that a new one is created.
       *
       * @param e - An event object.
       */
      onSelectionStart(e) {
          if (isPrevented(e)) {
              return;
          }
          this.device = e instanceof PointerEvent ? 'pointer' : 'keyboard';
          const { Selection } = this;
          if (e instanceof PointerEvent) {
              if (e.button === 2 && Selection.isInside(e.clientX, e.clientY)) {
                  this.set(CLICKED_RIGHT);
                  return;
              }
          }
          this.set(e.shiftKey ? EXTEND : START);
      }
      /**
       * Called when the `pointerup` or `keyup` event is triggered on the window object.
       * Note that the state goes into `SELECTED` when the previous state is `EXTEND`
       * even if the native selection is collapsed,
       * because an anchor node may disappear after scrolling.
       * The selection is correctly handled by the Selection class.
       */
      onSelectionEnd() {
          if (this.device && !this.is(IDLE)) {
              this.device = null;
              if (!this.is(CLICKED_RIGHT)) {
                  if (this.is(EXTEND)) {
                      this.set(SELECTED);
                  }
                  else {
                      this.set(END);
                      this.set(getSelection().isCollapsed ? COLLAPSED : SELECTED);
                  }
              }
          }
      }
      /**
       * Called when any key is pressed.
       *
       * @param e - A KeyboardEvent object.
       */
      onKeydown(e) {
          if (includes(ARROW_KEYS, normalizeKey(e.key))) {
              this.onSelectionStart(e);
          }
      }
      /**
       * Called when any key is released.
       *
       * @param e - A KeyboardEvent object.
       */
      onKeyup(e) {
          if (includes(ARROW_KEYS, normalizeKey(e.key))) {
              this.onSelectionEnd();
          }
      }
      /**
       * Checks if the editor or the context menu has focus or not.
       *
       * @return `true` if they have focus or otherwise `false`.
       */
      isFocused() {
          return this.elements.editor.contains(activeElement()) || this.Editor.Components.ContextMenu.isFocused();
      }
      /**
       * Should be called when the custom selection is manually updated.
       *
       * @param collapsed - Indicates whether the new selection is collapsed or not.
       */
      update(collapsed) {
          if (!this.is(START, EXTEND)) {
              this.set(UPDATE);
              this.set(collapsed ? COLLAPSED : SELECTED);
          }
      }
      /**
       * Attempts to refresh the selection state.
       *
       * @param collapsed - Indicates whether the new selection is collapsed or not.
       */
      refresh(collapsed) {
          if (!this.is(START, EXTEND)) {
              this.set(START);
              this.set(CHANGED);
              this.set(collapsed ? COLLAPSED : SELECTED);
          }
      }
      /**
       * Destroys the instance.
       */
      destroy() {
          this.event.destroy();
          off(null, '', this.key);
      }
  }

  /**
   * The class for handing both a native and custom selection.
   *
   * @since 0.1.0
   */
  class Selection extends Component {
      constructor() {
          super(...arguments);
          /**
           * Keeps the position where the selection starts.
           */
          this.anchor = ORIGIN;
          /**
           * Keeps the position where the selection ends.
           */
          this.focus = ORIGIN;
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          super.mount(elements);
          this.state = new State(this.Editor);
          this.listen();
      }
      /**
       * Listens to some events.
       */
      listen() {
          const { editable } = this.elements;
          this.bind(document, 'selectionchange', this.onSelectionChange, this);
          if (isIE()) {
              this.bind(editable, 'dblclick', this.onDblClick, this);
          }
          else {
              this.bind(editable, 'mousedown', this.onMouseDown, this);
          }
          this.state.on('changed', this.onStateChanged.bind(this));
          this.on([EVENT_SCROLLER_SCROLL, EVENT_WINDOW_SCROLL], this.onScroll, this);
          this.on(EVENT_SCROLLED, this.ensureSelection, this);
      }
      /**
       * Called whenever the selection is changed.
       * Be aware that this is fired even when the editor is not focused.
       */
      onSelectionChange() {
          if (this.isFocused()) {
              if (this.is(SELECTING, EXTEND)) {
                  const focus = this.getNativeSelection(true);
                  if (focus) {
                      this.focus = focus;
                      this.emit(EVENT_SELECTING);
                  }
              }
              this.emit(EVENT_SELECTION_CHANGE);
          }
      }
      /**
       * Called when the mouse button is pressed.
       * Detects the double-click earlier than the `dblclick` to prevent the native smart selection.
       *
       * @param e - A MouseEvent object.
       */
      onMouseDown(e) {
          if (e.detail > 1) {
              this.onDblClick();
              prevent(e);
          }
      }
      /**
       * Called when the code element is double-clicked.
       * If a word is clicked, selects it. Otherwise, selects a clicked node.
       */
      onDblClick() {
          const range = this.getWordRangeAt(this.anchor);
          if (range) {
              this.set(range.start, range.end);
          }
          else {
              const boundary = this.getNativeSelectionBoundary(false);
              if (boundary) {
                  const { node } = boundary;
                  const selection = getSelection();
                  const range = createRange();
                  range.selectNode(node);
                  selection.removeAllRanges();
                  selection.addRange(range);
                  const anchor = this.getNativeSelection();
                  const focus = this.getNativeSelection(true);
                  if (anchor && focus) {
                      this.set(anchor, focus);
                  }
              }
          }
      }
      /**
       * Called whenever the selection state is changed.
       *
       * - Updating positions at the `START` state is too early
       *   because the native selection has not been updated yet.
       * - Jumps to the focus position just before extending the existing selection by a keyboard
       *   so that the native selection is able to be updated.
       * - The `EVENT_SELECTING` event must be emitted after `EVENT_SELECTED` event
       *   for listeners to prepare something at the `SELECTING` state.
       * - When the state goes into `SELECTED` state, the custom selection may be collapsed,
       *   e.g. single backward selection -> shift + arrow. To make sure the state becomes `COLLAPSED`,
       *   sets the native selection.
       *
       * @param e     - An EventBusEvent object.
       * @param state - A state number.
       * @param prev  - A previous state number.
       */
      onStateChanged(e, state, prev) {
          if (prev !== UPDATE && prev !== CLICKED_RIGHT) {
              if (state === COLLAPSED || state === CHANGED || state === SELECTED) {
                  this.anchor = this.getNativeSelection() || this.anchor;
                  this.focus = this.getNativeSelection(true) || this.focus;
              }
              if (prev !== START && state === SELECTED) {
                  if (this.detectSelectAll()) {
                      const { lines, lines: { length } } = this;
                      const lastLineLength = lines[length - 1].text.length;
                      if (compare(this.anchor, [0, 0]) !== 0
                          || compare(this.focus, [length - 1, lastLineLength]) !== 0) {
                          this.selectAll();
                          return;
                      }
                  }
              }
          }
          this.emit(EVENT_SELECTED, this, state, prev);
          if (state === SELECTING) {
              this.emit(EVENT_SELECTING);
          }
      }
      /**
       * Called when the window or scroller scrolls.
       */
      onScroll() {
          const { Input } = this;
          const top = window.pageYOffset + this.elements.scroller.scrollTop;
          if (this.isMultiline() && !Input.disabled && top !== this.scrollTop) {
              this.Input.disabled = true;
              this.scrollTop = top;
          }
      }
      /**
       * Sets the custom selection by changing the native selection.
       *
       * @param anchor - An anchor position.
       * @param focus  - Optional. A focus position.
       */
      set(anchor, focus) {
          this.setNativeSelection(anchor, focus) || this.update(anchor, focus);
      }
      /**
       * Returns positions of the current selection.
       * If the `normalize` is `true`, the `start` will be always preceding position.
       *
       * @param normalize - Optional. Whether to normalize the position or not.
       *
       * @return An object literal with anchor and focus positions.
       */
      get(normalize = true) {
          const { anchor, focus } = this;
          const isBackward = this.isBackward();
          return {
              start: isBackward && normalize ? focus : anchor,
              end: isBackward && normalize ? anchor : focus,
          };
      }
      /**
       * Updates the custom selection range without using the native selection.
       *
       * @param anchor   - An anchor position.
       * @param focus    - Optional. A focus position.
       * @param silently - Optional. Whether to change the state or not.
       */
      update(anchor, focus, silently) {
          this.anchor = anchor;
          this.focus = focus || anchor;
          if (!silently) {
              this.state.update(this.isCollapsed());
          }
      }
      /**
       * Selects the current or specified line.
       * This method sets the range twice for the backward selection.
       *
       * @param row       - Optional. A row index where to select.
       * @param refresh   - Optional. Whether to refresh the current selection or not.
       * @param backwards - Optional. Selects a line backwards.
       */
      selectLine(row = this.focus[0], refresh = true, backwards) {
          const { lines } = this;
          const line = lines[row];
          if (line) {
              const start = [row, 0];
              const end = row < lines.length - 1 ? [row + 1, 0] : [row, line.text.length];
              const anchor = backwards ? end : start;
              const focus = backwards ? start : end;
              if (refresh) {
                  this.set(anchor, focus);
              }
              else {
                  this.update(anchor, focus, true);
              }
          }
      }
      /**
       * Selects again the current selection.
       */
      reselect() {
          this.set(this.anchor, this.focus);
      }
      /**
       * Selects the whole code.
       */
      selectAll() {
          const { lines } = this;
          const endRow = lines.length - 1;
          this.set([0, 0], [endRow, lines[endRow].text.length]);
      }
      /**
       * Holds the current state so that it won't change.
       */
      hold() {
          this.state.hold();
      }
      /**
       * Disables to hold the state.
       */
      release() {
          this.state.release();
      }
      /**
       * Converts the selection to a string.
       * An empty string will be returned when the selection is collapsed.
       *
       * @return A string representing the current selection.
       */
      toString() {
          const range = this.get();
          return this.Code.sliceRange(range.start, range.end);
      }
      /**
       * Returns the DOMRect node of the native selection boundary.
       * Note that the boundary node is usually a Text node,
       * but sometimes the line or the editable element.
       *
       * @param focus - Determines whether to get the DOMRect of the focus or anchor node.
       *
       * @return A DOMRect object if available, or otherwise `null`.
       */
      getRect(focus) {
          const boundary = this.getNativeSelectionBoundary(focus);
          if (boundary) {
              let { node, offset } = boundary;
              while (isHTMLElement(node)) {
                  node = node.firstChild;
                  offset = 0;
                  if (isBr(node)) {
                      return rect(node);
                  }
              }
              if (node) {
                  const range = createRange();
                  range.setStart(node, offset);
                  range.collapse(true);
                  return rect(range);
              }
          }
          return null;
      }
      /**
       * Returns the current location as a string formatted by the i18n definition.
       *
       * @return A string that describes the current location.
       */
      getLocation() {
          const { focus } = this;
          return format(this.i18n.location, focus[0] + 1, focus[1] + 1);
      }
      /**
       * Checks if the selection state is one of the provided states or not.
       * This is just an alias of the `state.is()` method.
       *
       * @param states - A state or states to check.
       *
       * @return `true` if the current state is one of the provided states, or otherwise `false`.
       */
      is(...states) {
          return this.state.is(...states);
      }
      /**
       * Collapses the selection to anchor or focus position.
       *
       * @param toFocus - Optional. Collapses the selection to the focus position.
       */
      collapse(toFocus) {
          this.set(toFocus ? this.focus : this.anchor);
      }
      /**
       * Checks is the selection is backward or not.
       *
       * @return `true` if the selection is backward, or otherwise `false`.
       */
      isBackward() {
          return compare(this.anchor, this.focus) > 0;
      }
      /**
       * Checks if the selection is collapsed or not.
       *
       * @return `true` if the selection is collapsed, or otherwise `false`.
       */
      isCollapsed() {
          return compare(this.anchor, this.focus) === 0;
      }
      /**
       * Checks if more than one line is selected or not.
       *
       * @return `true` if more than one line is selected or otherwise `false`.
       */
      isMultiline() {
          return this.anchor[0] !== this.focus[0];
      }
      /**
       * Checks if the editor is focused or not.
       *
       * @return `true` if the editor is focused, or otherwise `false`.
       */
      isFocused() {
          return this.Editor && this.Editor.isFocused();
      }
      /**
       * Checks if the provided client position is inside the current selection range or not.
       *
       * @param clientX - X position that is relative to the client.
       * @param clientY - Y position that is relative to the client.
       *
       * @return `true` if the position is inside the range, or otherwise `false`.
       */
      isInside(clientX, clientY) {
          return this.Range.selection.isInside(clientX, clientY);
      }
      /**
       * Destroys the instance.
       */
      destroy() {
          this.state.destroy();
          super.destroy();
      }
      /**
       * Sets a native selection range.
       * Be aware that calling `setSelection` emits `selectionchange` only in IE, but does not in others.
       *
       * @param start - A start position.
       * @param end   - Optional. An end position. If omitted, the start position is used alternatively.
       *
       * @return `true` if the selection is successfully changed, or otherwise `undefined`.
       */
      setNativeSelection(start, end = start) {
          const { Chunk } = this;
          const isSingle = start[0] === end[0];
          const startLine = Chunk.getLine(start[0]) || Chunk.addPreservedLine(false, start[0]);
          const endLine = isSingle ? startLine : Chunk.getLine(end[0]) || Chunk.addPreservedLine(true, end[0]);
          const collapsed = compare(start, end) === 0;
          const anchor = findSelectionBoundary(startLine, start[1]);
          const focus = collapsed ? anchor : findSelectionBoundary(endLine, end[1]);
          if (anchor && focus) {
              const anchorNode = anchor.node;
              const focusNode = focus.node;
              anchor.node = isBr(anchorNode) ? anchorNode.parentNode : anchorNode;
              focus.node = isBr(focusNode) ? focusNode.parentNode : focusNode;
              this.hold();
              setSelection(anchor, focus);
              this.release();
              this.state.refresh(collapsed);
          }
          return true;
      }
      /**
       * Converts the native selection boundary to a position represented as [ row, col ].
       * In FF, the selection
       *
       * @param focus - Optional. Whether to returns a position on the focus boundary or not.
       *
       * @return A converted position. If the position is not found, always returns [ 0, 0 ].
       */
      getNativeSelection(focus) {
          const line = this.findActiveLine(focus);
          const boundary = this.getNativeSelectionBoundary(focus);
          if (line && boundary) {
              const { Chunk } = this;
              const range = createRange();
              range.setStart(line, 0);
              range.setEnd(boundary.node, boundary.offset);
              let row = Chunk.getRow(line);
              if (row < 0) {
                  const anchor = Chunk.getBoundary(false);
                  const focus = Chunk.getBoundary(true);
                  if (anchor.line === line) {
                      row = anchor.row;
                  }
                  else if (focus.line === line) {
                      row = focus.row;
                  }
              }
              if (row > -1) {
                  return [row, range.toString().length];
              }
          }
          return null;
      }
      /**
       * Finds a line where the native anchor node belongs.
       * If the `focus` is set to `true`, finds a line where the native focus node belongs.
       *
       * @param focus - Determines whether to find a line that has focus node or not.
       *
       * @return A line where an anchor or a focus node belongs.
       */
      findActiveLine(focus) {
          const boundary = this.getNativeSelectionBoundary(focus);
          if (boundary) {
              const { node } = boundary;
              const elm = isText(node) ? node.parentNode : node;
              if (isHTMLElement(elm)) {
                  return closest(elm, `.${CLASS_LINE}`);
              }
          }
          return null;
      }
      /**
       * Converts the provided position to the range for wrapping the word at the position.
       * If the text at the position is not a word, such as `/` or `-`, this returns `null`.
       *
       * @param row - A row index.
       * @param col - A col index.
       *
       * @return An object that describes the range of the word at the position.
       *         If the text is not a word, returns `null`.
       */
      getWordRangeAt([row, col]) {
          const line = this.lines[row];
          if (line) {
              const string = line.text;
              const words = string.split(/[^\w]/);
              let index = 0;
              for (let i = 0; i < words.length; i++) {
                  const from = i > 0 ? index + 1 : 0;
                  const to = from + words[i].length;
                  if (from <= col && col < to) {
                      return { start: [row, from], end: [row, to] };
                  }
                  index = to;
              }
          }
          return null;
      }
      /**
       * Returns a boundary node and offset of the native selection.
       * Be aware that the target node must be in the chunk,
       * or otherwise this method returns `null`.
       * Besides, IE returns a parent node as a boundary node, and child index as a offset
       * if the boundary is `<br>`(an empty line).
       *
       * @param focus - Whether to get the focus boundary or not.
       *
       * @return An object literal with a node and offset.
       */
      getNativeSelectionBoundary(focus) {
          const { editable } = this.elements;
          const selection = getSelection();
          const prefix = focus ? 'focus' : 'anchor';
          let node = selection[`${prefix}Node`];
          let offset = selection[`${prefix}Offset`];
          if (node === editable) {
              node = editable.children[offset];
              offset = 0;
          }
          return node ? { node, offset } : null;
      }
      /**
       * Detects selection of all contents in a immediate way, such as the `Select All` iOS context menu.
       *
       * @return `true` if all contents are selected, or otherwise `false`.
       */
      detectSelectAll() {
          const { lines } = this.elements;
          const anchorLine = this.findActiveLine(false);
          const focusLine = this.findActiveLine(true);
          const elms = slice(lines.children).filter(elm => !hasClass(elm, CLASS_EMPTY));
          return anchorLine === elms[0]
              && focusLine === elms[elms.length - 1]
              && compare(this.anchor, this.focus)
              && this.anchor[1] === 0
              && this.focus[1] === focusLine.textContent.length;
      }
      /**
       * The dirty code to ensure the selection contains the latest nodes.
       */
      ensureSelection() {
          const { Input } = this;
          const { editable } = this.elements;
          const selection = getSelection();
          if (!isMobile() && this.isMultiline() && activeElement() === editable && selection.setBaseAndExtent) {
              const { editable } = this.elements;
              const { anchorOffset, focusOffset } = selection;
              let { anchorNode, focusNode } = selection;
              attr(editable, { 'aria-hidden': true });
              this.hold();
              selection.removeAllRanges();
              if (isGecko()) {
                  const anchorClone = anchorNode.cloneNode(true);
                  const focusClone = focusNode.cloneNode(true);
                  anchorNode.parentNode.replaceChild(anchorClone, anchorNode);
                  focusNode.parentNode.replaceChild(focusClone, focusNode);
                  anchorNode = anchorClone;
                  focusNode = focusClone;
              }
              else {
                  toggleEditable(editable, false);
              }
              setTimeout(() => {
                  selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
                  nextTick(() => {
                      this.Editor.focus();
                      Input.disabled = false;
                      toggleEditable(editable, true);
                      attr(editable, { 'aria-hidden': null });
                      this.release();
                  });
              }, DELAY_FOR_RESELECTION);
          }
          else {
              Input.disabled = false;
          }
      }
  }

  /**
   * The sample string.
   *
   * @since 0.1.3
   */
  const SAMPLE = '    ';
  /**
   * The timeout duration in milliseconds.
   *
   * @since 0.1.3
   */
  const TIMEOUT = 5000;
  /**
   * The class for observing the font loading.
   *
   * @since 0.1.3
   */
  class FontObserver {
      /**
       * The Observer constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          /**
           * Keeps the time when the instance is created.
           */
          this.time = Date.now();
          this.Editor = Editor;
          this.Measure = this.Editor.Components.Measure;
          this.initialWidth = this.Measure.measureWidth(SAMPLE);
          this.observe();
      }
      /**
       * Observes the font loading.
       */
      observe() {
          const width = this.Measure.measureWidth(SAMPLE, false);
          if (width !== this.initialWidth) {
              this.Editor.event.emit(EVENT_FONT_LOADED);
          }
          else {
              if (Date.now() - this.time < TIMEOUT) {
                  requestAnimationFrame(this.observe.bind(this));
              }
          }
      }
  }

  /**
   * The component for customizing some styles of the editor.
   *
   * @since 0.1.0
   */
  class Style extends Component {
      /**
       * The Style constructor.
       *
       * @param Editor - An Editor element.
       */
      constructor(Editor) {
          super(Editor);
          /**
           * Stores all styles.
           */
          this.selectors = {};
          this.init();
          this.on('body:open', (e, append) => {
              this.emit(EVENT_INIT_STYLE, this.add.bind(this));
              append(`<style id="${this.options.id}-style">${this.build()}</style>`);
          });
      }
      /**
       * Adds styles defined in options.
       */
      init() {
          const { options, options: { lineHeight } } = this;
          ['width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'].forEach(prop => {
              const value = options[prop];
              if (value) {
                  this.add('root', prop, unit(value));
              }
          });
          const height = lineHeight ? `${lineHeight}em` : undefined;
          this.add('root', isGecko() ? '-moz-tab-size' : 'tabSize', options.tabSize);
          this.add(`.${CLASS_EDITOR}`, {
              lineHeight: lineHeight,
              fontFamily: options.monospaceFont,
          });
          this.add(`.${CLASS_MARKER}`, 'minHeight', height);
          this.add(`.${CLASS_CARET}`, 'height', height);
          if (!isIE()) {
              this.add(`.${CLASS_LINE}:not(.${CLASS_EMPTY}):not(.${CLASS_PRESERVED})`, 'height', height);
          }
      }
      /**
       * Converts the selectors object into a single style string.
       *
       * @return A built string.
       */
      build() {
          let html = '';
          forOwn$1(this.selectors, (styles, selector) => {
              let props = '';
              forOwn$1(styles, (value, prop) => {
                  if (!isUndefined$1(value)) {
                      props += `${camelToKebab(prop)}: ${value};`;
                  }
              });
              if (props) {
                  html += `${selector}{${props}}`;
              }
          });
          return html;
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential editor elements.
       */
      mount(elements) {
          this.style = query(elements.root, 'style');
          append(query(document, 'head'), this.style);
          if (this.options.monospaceFont) {
              new FontObserver(this.Editor);
          }
      }
      /**
       * Adds a style to the specified selector.
       *
       * @param selector - A selector string.
       * @param prop     - A CSS property or an objet literal with properties and values.
       * @param value    - A value for the property.
       */
      add(selector, prop, value) {
          if (isString(prop)) {
              if (!isUndefined$1(value)) {
                  const { selectors } = this;
                  selector = `#${this.options.id}${selector === 'root' ? '' : ' ' + selector}`;
                  selectors[selector] = selectors[selector] || {};
                  selectors[selector][prop] = value;
              }
          }
          else {
              forOwn$1(prop, (value, key) => {
                  this.add(selector, key, value);
              });
          }
      }
      /**
       * Applies current styles to the style element.
       */
      apply() {
          text(this.style, this.build());
      }
      /**
       * Destroys the component.
       */
      destroy() {
          super.destroy();
          remove(this.style);
      }
  }

  /**
   * Max lines to asynchronously sync code to the Lines instance at once.
   *
   * @since 0.1.0
   */
  const ASYNC_SYNC_LINES = 3000;
  /**
   * Max lines to scan up for asynchronously sync.
   *
   * @since 0.1.0
   */
  const ASYNC_SYNC_LINES_BACKWARDS = 100;
  /**
   * Max lines to scan up for synchronously sync.
   *
   * @since 0.1.0
   */
  const SYNC_LINES_BACKWARDS = 100;

  /**
   * The class for syncing changes to Lines and View components.
   *
   * @since 0.1.0
   */
  class Sync extends Component {
      constructor() {
          super(...arguments);
          /**
           * Holds the minimum row for asynchronous syncing.
           */
          this.minStart = Infinity;
          /**
           * Holds the maximum row for asynchronous syncing.
           */
          this.maxEnd = 0;
      }
      /**
       * Syncs the changes between the start and end rows to the Lines and View components.
       * Since the `startRow` can be very far from the `row` when pasting huge code,
       * syncs lines inaccurately by setting the `strict` to `false` at first,
       * and then starts strict synchronization.
       *
       * @param startRow  - A start row index.
       * @param endRow    - An end row index.
       * @param jumpTo    - Optional. Jumps to the specified row before starting synchronization.
       */
      sync(startRow, endRow, jumpTo) {
          const { Chunk, View } = this;
          const diff = this.lines.syncSize(startRow, this.Code.size);
          View.autoHeight();
          View.autoWidth();
          if (!isUndefined$1(jumpTo)) {
              View.jump(jumpTo);
          }
          if (Chunk.includes(startRow)) {
              this.run(startRow, Chunk.end - startRow + 1);
          }
          else {
              const { start, end } = Chunk;
              this.run(start, end - start + 1, false);
              this.syncLines(startRow, endRow);
          }
          Chunk.syncDiff(startRow, diff);
          Chunk.sync();
      }
      /**
       * Starts the sync sequence.
       *
       * @param row    - A row index.
       * @param limit  - Limits the number of synchronously syncing.
       * @param strict - Optional. Determines whether the synchronization must be strict or not.
       */
      run(row, limit, strict = true) {
          const result = this.find(row, SYNC_LINES_BACKWARDS);
          let { startRow } = result;
          if (!strict && row - startRow > SYNC_LINES_BACKWARDS) {
              startRow = row - SYNC_LINES_BACKWARDS;
          }
          limit = row - startRow + limit;
          const changed = this.lines.sync(startRow, this.Code.after(startRow), limit, result.before);
          if (changed || this.syncing) {
              const { size } = this.Code;
              startRow = startRow + limit;
              if (startRow < size) {
                  this.syncLines(startRow, size - 1);
              }
          }
      }
      /**
       * Asynchronously syncs lines between the provided range.
       * If the range is wider than the current running process, cancels it and starts a new process.
       *
       * @param startRow - A start row index.
       * @param endRow   - An end row index.
       */
      syncLines(startRow, endRow) {
          this.minStart = min(startRow, this.minStart);
          this.maxEnd = max(endRow, this.maxEnd);
          this.syncing = true;
          const ranges = this.splitRows(this.minStart, this.maxEnd);
          this.syncRanges(ranges, () => {
              this.minStart = Infinity;
              this.maxEnd = 0;
              this.syncing = false;
              this.Chunk.sync();
          });
      }
      /**
       * Syncs provided ranges step by step.
       *
       * @param ranges   - An array with row ranges.
       * @param callback - Optional. A callback fired after the sync is completed.
       */
      syncRanges(ranges, callback) {
          const range = ranges.shift();
          const { startRow, before } = this.find(range[0], ASYNC_SYNC_LINES_BACKWARDS);
          const limit = range[1] - startRow + 1;
          this.lines.asyncSync('syncRanges', startRow, this.Code.after(startRow), limit, before, () => {
              if (ranges.length) {
                  this.syncRanges(ranges, callback);
                  this.emit(EVENT_SYNCED, this, false);
              }
              else {
                  if (callback) {
                      callback();
                  }
                  this.emit(EVENT_SYNCED, this, true);
              }
          });
      }
      /**
       * Splits the provided row range into small fragments.
       *
       * @param startRow - A start row index.
       * @param endRow   - An end row index.
       *
       * @return An array with row ranges.
       */
      splitRows(startRow, endRow) {
          const ranges = [];
          while (startRow <= endRow) {
              ranges.push([startRow, min(startRow + ASYNC_SYNC_LINES - 1, endRow)]);
              startRow += ASYNC_SYNC_LINES;
          }
          return ranges;
      }
      /**
       * Returns an info object to start syncing.
       *
       * @param row   - A row index.
       * @param limit - Limits the number of lines.
       *
       * @return An object with a start row index and code to prepend.
       */
      find(row, limit) {
          if (this.isEmbedded(row)) {
              return this.findStartInLanguageBlock(row, limit);
          }
          const startRow = this.findRoot(row);
          if (row - startRow > limit) {
              if (this.isEmbedded(row - limit)) {
                  return this.findStartInLanguageBlock(row - limit, limit / 2);
              }
              return this.compress(startRow, row, '', limit);
          }
          return { startRow, before: '' };
      }
      /**
       * If the distance from the `row` to `startRow` is greater than the `limit`,
       * attempt to shorten the distance by generating pseudo code.
       *
       * @param startRow - A start row index.
       * @param row      - An original row index.
       * @param before   - A pseudo line to prepend.
       * @param limit    - A limit number of lines.
       *
       * @return An object with a start row index and code to prepend.
       */
      compress(startRow, row, before, limit) {
          if (row - startRow > limit) {
              const start = this.lines.findBlockStart([row - 1, 0]);
              if (start) {
                  const { multiline } = this.getLanguage(start);
                  const info = this.lines.getInfoAt(start);
                  if (info && multiline) {
                      for (let i = 0; i < multiline.length; i++) {
                          const item = multiline[i];
                          if (info.category === item[2] && (!item[3] || info.state === item[3])) {
                              startRow = start[0] + 1;
                              before += item[0];
                              break;
                          }
                      }
                  }
              }
          }
          return { startRow, before };
      }
      /**
       * Finds the likely appropriate index where tokenization should start.
       *
       * @param row   - A row index.
       * @param depth - Optional. Minimum depth of a line that can be a candidate.
       *
       * @return A better index for starting tokenization.
       */
      findRoot(row, depth = 0) {
          const { lines } = this;
          if (between(row, 0, lines.length, true)) {
              for (let i = row - 1; i >= 0; i--) {
                  const line = lines[i];
                  if (line.depth <= depth && line.tokens.length && !line.isEmpty()) {
                      if (line.split) {
                          i -= line.first[2].distance + 1;
                      }
                      else {
                          return i;
                      }
                  }
              }
          }
          return 0;
      }
      /**
       * Finds a sync start info in an embedded language block.
       *
       * @param row   - A row index.
       * @param limit - A limit number of lines.
       *
       * @return An object with a start row index and code to prepend.
       */
      findStartInLanguageBlock(row, limit) {
          const { lines } = this;
          const lang = lines[row].language;
          const config = this.language.use[lang];
          const startRow = this.findRoot(row, config.depth);
          const startLang = lines[startRow].language;
          if (startLang === lang) {
              return this.compress(startRow, row, config.code, limit);
          }
          return { startRow, before: '' };
      }
      /**
       * Checks if the line at the specified row is inside an embedded block or not.
       *
       * @param row - A row index.
       *
       * @return `true` if the row is inside an embedded block, or otherwise `false`.
       */
      isEmbedded(row) {
          const line = this.lines[row];
          if (line) {
              const { language } = line;
              return language && this.language.language.id !== language;
          }
      }
  }

  /**
   * The number of margin lines when jumping to a particular line.
   *
   * @since 0.1.0
   */
  const JUMP_OFFSET = 1;

  /**
   * Event names for the beginning of dragging.
   *
   * @since 0.1.0
   */
  const DRAG_START_EVENTS = 'pointerdown';
  /**
   * Event names for the end of dragging.
   *
   * @since 0.1.0
   */
  const DRAG_END_EVENTS = 'pointerup';
  /**
   * Event names on dragging.
   *
   * @since 0.1.0
   */
  const DRAGGING_EVENTS = 'pointermove';
  /**
   * The conversion map for vertical/horizontal props.
   *
   * @since 0.1.0
   */
  const ORIENTATION_MAP = {
      vertical: 'horizontal',
      scrollHeight: 'scrollWidth',
      clientHeight: 'clientWidth',
      scrollTop: 'scrollLeft',
      minHeight: 'minWidth',
      maxHeight: 'maxWidth',
      height: 'width',
      top: 'left',
      pageY: 'pageX',
      translateY: 'translateX',
  };
  /**
   * The abstract class for creating a draggable bar.
   *
   * @since 0.1.0
   */
  class AbstractDraggableBar {
      /**
       * The AbstractDraggableBar constructor.
       *
       * @param classes  - A class or classes of the bar.
       * @param parent   - A parent element of the bar.
       * @param vertical - Determines whether to create a vertical or horizontal bar.
       */
      constructor(classes, parent, vertical) {
          /**
           * Holds the prop names determined by the bar direction.
           */
          this.names = {};
          this.elm = div(classes, parent);
          this.parent = parent;
          this.vertical = vertical;
          forOwn$1(ORIENTATION_MAP, (prop, key) => {
              this.names[key] = vertical ? key : prop;
          });
          this.bind();
      }
      /**
       * Listens to some events.
       */
      bind() {
          this.onDrag = this.onDrag.bind(this);
          this.onDragging = this.onDragging.bind(this);
          this.onDragged = this.onDragged.bind(this);
          on(this.elm, DRAG_START_EVENTS, this.onDrag);
      }
      /**
       * Called when the element starts being dragged.
       *
       * @param e - A PointerEvent object.
       */
      onDrag(e) {
          on(window, DRAG_END_EVENTS, this.onDragged);
          on(window, DRAGGING_EVENTS, this.onDragging);
          this.startCoord = this.getCoord(e);
          this.lastCoord = this.startCoord;
          this.toggleClass(true);
          prevent(e);
      }
      /**
       * Called while the element is dragged.
       *
       * @param e - A PointerEvent object.
       */
      onDragging(e) {
          prevent(e);
      }
      /**
       * Called when the element is released.
       */
      onDragged() {
          off(window, DRAG_END_EVENTS, this.onDragged);
          off(window, DRAGGING_EVENTS, this.onDragging);
          this.toggleClass(false);
      }
      /**
       * Returns the `pageX` and `pageY` coordinates provided by the event.
       *
       * @param e - A PointerEvent object.
       *
       * @return A pageX or pageY coordinate.
       */
      getCoord(e) {
          return e[this.names.pageY];
      }
      /**
       * Toggles "dragging" classes of the element and parent element.
       *
       * @param add - Determines whether to add or remove classes.
       */
      toggleClass(add) {
          toggleClass(this.elm, CLASS_DRAGGING, add);
          toggleClass(this.parent, [CLASS_DRAGGING, `${CLASS_DRAGGING}--${this.names.vertical}`], add);
      }
      /**
       * Destroys the bar.
       */
      destroy() {
          off(this.elm, DRAG_START_EVENTS, this.onDrag);
          off(window, DRAG_END_EVENTS, this.onDragged);
          off(window, DRAGGING_EVENTS, this.onDragging);
      }
  }

  /**
   * The class for creating a scrollbar.
   *
   * @since 0.1.0
   */
  class Scrollbar extends AbstractDraggableBar {
      /**
       * The Scrollbar constructor.
       *
       * @param Editor   - An EventBus instance.
       * @param parent   - A parent element.
       * @param scroller - A target element to scroll.
       * @param vertical - Determines whether to create a vertical or horizontal scroll bar.
       * @param margin   - Optional. Margins in pixel as `[ top, bottom ]` ( or `[ left, right ]` ).
       */
      constructor(Editor, parent, scroller, vertical, margin = [0, 0]) {
          super([CLASS_SCROLLBAR, `${CLASS_SCROLLBAR}--${vertical ? 'vertical' : 'horizontal'}`], parent, vertical);
          /**
           * The conversion ratio from the scroll offset to the bar offset.
           * - top = scrollTop * ratio
           * - scrollTop = top / ratio
           */
          this.ratio = 1;
          this.Editor = Editor;
          this.scroller = scroller;
          this.margin = isArray(margin) ? () => margin : margin;
          this.init();
          this.listen();
      }
      /**
       * Initializes the instance.
       * Note that `aria-valuemin` and `aria-valuemax` is not necessary because their default values are `0` and `100`.
       *
       * @link https://www.w3.org/TR/wai-aria-1.2/#scrollbar
       */
      init() {
          const { Editor, scroller } = this;
          attr(this.elm, {
              role: 'scrollbar',
              'aria-controls': scroller.id,
              'aria-orientation': this.names.vertical,
              'aria-valuenow': 0,
              'aria-label': Editor.options.i18n.scrollbar,
          });
          this.update = this.update.bind(this);
      }
      /**
       * Listens to some events.
       */
      listen() {
          const update = rafThrottle(this.update);
          on(this.scroller, 'scroll', update, this);
          this.Editor.event.on([EVENT_MOUNTED, EVENT_RESIZE], update);
      }
      /**
       * Called while the bar is dragged.
       *
       * @param e - A PointerEvent object.
       */
      onDragging(e) {
          super.onDragging(e);
          const coord = this.getCoord(e);
          const diff = coord - this.lastCoord;
          this.scroller[this.names.scrollTop] += diff / this.ratio;
          this.lastCoord = coord;
      }
      /**
       * Updates the scrollbar height and offset according to the current scroll offset.
       */
      update() {
          const { scroller, names, elm } = this;
          const { style } = elm;
          const sh = scroller[names.scrollHeight];
          const ch = scroller[names.clientHeight];
          const st = scroller[names.scrollTop];
          const active = sh > ch;
          const margin = this.margin();
          const heightRatio = 1 - ((margin[0] + margin[1]) / ch);
          const height = (ch * ch / sh) * heightRatio;
          if (this.lastHeight !== height) {
              style[names.height] = unit(height);
              this.lastHeight = height;
          }
          if (active) {
              const offsetRatio = (ch * heightRatio - elm[names.clientHeight]) / (sh - ch);
              style.transform = `${names.translateY}(${unit(st * offsetRatio + margin[0])})`;
              attr(elm, { 'aria-valuenow': round(100 * 100 * st / (sh - ch)) / 100 });
              this.ratio = offsetRatio;
          }
          toggleClass(elm, CLASS_ACTIVE, active);
      }
      /**
       * Destroys the instance.
       */
      destroy() {
          off(null, '', this);
          super.destroy();
      }
  }

  /**
   * The class for creating a scrollbar.
   *
   * @since 0.1.0
   */
  class EditorScrollbar extends Scrollbar {
      /**
       * Listens to some events.
       */
      listen() {
          this.Editor.event.on([EVENT_MOUNTED, EVENT_RESIZE, EVENT_SCROLL, EVENT_SCROLL_HEIGHT_CHANGED, EVENT_SCROLL_WIDTH_CHANGED], rafThrottle(this.update));
      }
  }

  /**
   * The class for managing the viewport.
   *
   * @since 0.1.0
   */
  class View extends Component {
      constructor() {
          super(...arguments);
          /**
           * Keeps the previous width of the viewport.
           */
          this.lastWidth = 0;
          /**
           * Holds Scrollbar elements.
           */
          this.scrollbars = [];
      }
      /**
       * Initializes the instance.
       *
       * @param elements - A collection of essential editor elements.
       */
      mount(elements) {
          super.mount(elements);
          this.emitResize = rafThrottle(this.emit.bind(this, 'resize'));
          elements.scroller.scrollTop = 0;
          this.create();
          this.autoHeight();
          this.listen();
      }
      /**
       * Listens to some events.
       */
      listen() {
          this.bind(window, 'resize', this.emitResize);
          this.on([EVENT_MOUNTED, EVENT_RESIZE, EVENT_SCROLLED], this.autoWidth, this);
          this.on(EVENT_RESIZE, this.autoHeight.bind(this, true), null, 2);
          this.on(EVENT_SELECTED, this.onSelected, this);
          this.on(EVENT_SELECTING, this.clipScrollOffset, this);
      }
      /**
       * Called when the selection state is changed.
       *
       * @param e         - An EventBusEvent object.
       * @param Selection - A Selection instance.
       */
      onSelected(e, Selection) {
          if (Selection.is(START, EXTEND) && Selection.state.device === 'keyboard') {
              this.jump(Selection.focus[0]);
          }
          if (Selection.is(CHANGED, SELECTING, SELECTED)) {
              this.clipScrollOffset();
          }
      }
      /**
       * Creates the scrollbar elements.
       */
      create() {
          const { elements, elements: { scroller }, Editor } = this;
          const wrapper = div(CLASS_SCROLLBARS, elements.body);
          if (!isMobile()) {
              this.scrollbars = [
                  new EditorScrollbar(Editor, wrapper, scroller, true),
                  new EditorScrollbar(Editor, wrapper, scroller, false, () => [this.getWidthBeforeContainer(), 0]),
              ];
          }
          const { placeholder } = this.options;
          if (placeholder) {
              const placeholderElm = div(CLASS_PLACEHOLDER, elements.background);
              text(placeholderElm, placeholder);
          }
      }
      /**
       * Clips the caret position by all sides of the editor.
       * Only the left border refers the editor rect so that it includes the width of the fixed gutter.
       */
      clipScrollOffset() {
          const { rect: caretRect } = this.Caret;
          const { focus } = this.Selection;
          if (!caretRect || !this.Chunk.includes(focus[0])) {
              return;
          }
          const { Measure } = this;
          const { scroller } = this.elements;
          const { padding, scrollerRect, lineHeight } = Measure;
          const { top: caretTop, right: caretRight, bottom: caretBottom, left: caretLeft } = caretRect;
          const editorRect = rect(this.elements.editor);
          let { scrollTop, scrollLeft } = scroller;
          const top = scrollerRect.top + lineHeight / 2 + padding.top;
          const bottom = scrollerRect.bottom - lineHeight / 2 - padding.bottom;
          const left = (isIE() ? scrollerRect.left : (editorRect.left + scrollLeft)) + max(padding.left, lineHeight);
          const right = scrollerRect.right - max(padding.right, lineHeight);
          if (caretTop < top) {
              scrollTop -= top - caretTop;
          }
          if (caretBottom > bottom) {
              scrollTop += caretBottom - bottom;
          }
          if (caretLeft < left) {
              scrollLeft -= left - caretLeft;
          }
          if (caretRight > right) {
              scrollLeft += caretRight - right;
          }
          if (!focus[1]) {
              scrollLeft = 0;
          }
          scroller.scrollTop = scrollTop;
          scroller.scrollLeft = scrollLeft;
      }
      /**
       * Returns the width before the container element.
       *
       * @return The width before the container.
       */
      getWidthBeforeContainer() {
          const { Measure } = this;
          return Measure.editorRect.left - Measure.containerRect.left;
      }
      /**
       * Jumps to the specified row if it's not visible in the viewport.
       * If the `middle` is true, always jumps to the middle of the viewport.
       *
       * @param row        - A row index to jump to.
       * @param middle     - Optional. Determines whether to jump to the middle of the viewport.
       * @param lineOffset - Optional. A number of lines to offset top and bottom borders.
       */
      jump(row, middle, lineOffset = JUMP_OFFSET) {
          const { Measure, Chunk, Measure: { scrollerRect } } = this;
          if (middle) {
              Chunk.scroll(Measure.getBottom(row) - scrollerRect.height / 2 + Measure.lineHeight * lineOffset);
              return;
          }
          if (!this.isVisible(row)) {
              const center = Chunk.start + (Chunk.length - 1) / 2;
              let scrollTop;
              if (row > center) {
                  row = min(row + lineOffset, this.lines.length - 1);
                  scrollTop = Measure.getBottom(row) - scrollerRect.height + Measure.padding.top;
              }
              else {
                  scrollTop = Measure.getTop(max(row - lineOffset, 0));
              }
              Chunk.scroll(scrollTop);
          }
      }
      /**
       * Adjusts the width of the lines element.
       */
      autoWidth() {
          const { Measure } = this;
          const { width } = Measure.editorRect;
          if (width > Measure.scrollerRect.width - this.getWidthBeforeContainer() && width > this.lastWidth) {
              styles(this.elements.lines, { minWidth: unit(width) });
              this.lastWidth = width;
              this.emit(EVENT_SCROLL_WIDTH_CHANGED);
          }
      }
      /**
       * Adjusts the height of the container element so that it contains all lines.
       * It won't be smaller than the scroller element when the editor has explicit height.
       *
       * @param skipLengthCheck - Optional. Whether to skip checking the number of lines or not.
       */
      autoHeight(skipLengthCheck) {
          const { elements } = this;
          const { length } = this.lines;
          if (skipLengthCheck || length !== this.lastLength) {
              const { Measure, Measure: { padding } } = this;
              let height = Measure.lineHeight * (length || 1) + padding.top + padding.bottom;
              if (elements.root.style.height || this.options.height) {
                  height = max(height, Measure.scrollerRect.height);
              }
              styles(this.elements.container, { height: unit(height) });
              this.lastLength = length;
              this.emit(EVENT_SCROLL_HEIGHT_CHANGED);
          }
      }
      /**
       * Checks if the provided row is visible on the scroller or not.
       *
       * @param row        - A row index to check.
       * @param lineOffset - Optional. A number of lines to offset top and bottom borders.
       *
       * @return `true` if the row is in the scroller viewport, or otherwise `false`.
       */
      isVisible(row, lineOffset = 0) {
          const { Chunk, Measure } = this;
          if (Chunk.includes(row)) {
              const line = Chunk.getLine(row);
              if (line) {
                  const { scrollerRect } = Measure;
                  const lineRect = rect(line);
                  const offset = Measure.lineHeight * lineOffset;
                  return lineRect.top >= scrollerRect.top + offset && lineRect.bottom <= scrollerRect.bottom - offset;
              }
          }
          return false;
      }
      /**
       * Destroys the component.
       */
      destroy() {
          this.scrollbars.forEach(bar => { bar.destroy(); });
          super.destroy();
      }
  }

  var CoreComponents = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Caret: Caret,
    Chunk: Chunk,
    Code: Code,
    ContextMenu: ContextMenu,
    Edit: Edit,
    Input: Input,
    Keymap: Keymap,
    Measure: Measure,
    Range: Range,
    Scope: Scope,
    Selection: Selection,
    Style: Style,
    Sync: Sync,
    View: View
  });

  /**
   * Common attributes for editable areas.
   *
   * @link https://www.w3.org/TR/wai-aria-1.2/#aria-roledescription
   * @link https://www.w3.org/TR/wai-aria-1.2/#aria-multiline
   *
   * @since 0.1.0
   */
  const ATTRIBUTES_EDITABLE_AREA = {
      autocorrect: 'off',
      autocapitalize: 'off',
      spellcheck: 'false',
      role: 'textbox',
      'aria-multiline': true,
      'aria-roledescription': 'editor',
  };

  /**
   * The class for rendering the editor.
   *
   * @since 0.1.0
   */
  class Renderer {
      /**
       * The Renderer constructor.
       *
       * @param Code    - A Code instance.
       * @param event   - An EventBus instance.
       * @param options - Options.
       */
      constructor(Code, event, options) {
          this.Code = Code;
          this.lines = Code.Lines;
          this.event = event;
          this.options = options;
      }
      /**
       * Render lines until the number reaches the `maxInitialLines`.
       * Rest lines are rendered in the temporary `pre` element.
       *
       * @param append - The function to append a HTML string.
       */
      renderLines(append) {
          const { lines } = this;
          const max = min(lines.length, this.options.maxInitialLines);
          for (let i = 0; i < max; i++) {
              append(tag(CLASS_LINE) + lines[i].html + '</div>');
          }
      }
      /**
       * Builds the HTML for the editor.
       *
       * @param source - Optional. Determines whether to embed the source code as a pre element or not.
       *
       * @return The built HTML string.
       */
      html(source) {
          let html = '';
          const { options, options: { id } } = this;
          const append = (string) => { html += string; };
          const classes = [CLASS_ROOT, CLASS_RENDERED].concat(options.rootClasses);
          const divs = [
              ['root', classes, { id, role: 'code' }],
              ['body', [CLASS_BODY]],
              ['scroller', [CLASS_SCROLLER]],
              ['container', [CLASS_CONTAINER]],
              ['editor', [CLASS_EDITOR]],
          ];
          divs.forEach(settings => {
              this.event.emit(`${settings[0]}:open`, append, settings[1], this.lines);
              const attrs = assign$1({ id: `${id}-${settings[0]}` }, settings[2]);
              html += tag(settings[1], attrs);
          });
          html += tag([CLASS_LINES], ATTRIBUTES_EDITABLE_AREA);
          this.renderLines(append);
          html += '</div>';
          if (source) {
              html += `<pre class="${CLASS_SOURCE}">${this.Code.value}</pre>`;
          }
          return html + repeat('</div>', divs.length);
      }
  }

  /**
   * The debounce duration for evaluating `focusout` of the editor.
   *
   * @since 0.1.0
   */
  const FOCUSOUT_DEBOUNCE_DURATION = 10;
  /**
   * The core class for the editor.
   *
   * @since 0.1.0
   */
  class Editor {
      /**
       * The Editor constructor.
       *
       * @param language   - A Language object.
       * @param options    - Options.
       * @param extensions - An object with additional components.
       */
      constructor(language, options, extensions = {}) {
          /**
           * Holds Component instances.
           */
          this.Components = {};
          /**
           * Holds Extension instances.
           */
          this.Extensions = {};
          this.language = language;
          this.options = options;
          this.event = new EventBus();
          this.options.id = this.options.id || uniqueId(PROJECT_CODE);
          forOwn$1(CoreComponents, (Component, name) => {
              this.Components[name] = new Component(this);
          });
          forOwn$1(extensions, (Extension, name) => {
              const value = this.options[name.charAt(0).toLowerCase() + name.slice(1)];
              if (isUndefined$1(value) || value) {
                  this.Extensions[name] = new Extension(this);
              }
          });
      }
      /**
       * Initializes the editor and components.
       */
      mount() {
          const { options, event, elements } = this;
          this.listen();
          event.emit(EVENT_MOUNT, elements);
          forOwn$1(this.Components, Component => {
              Component.mount(elements);
          });
          forOwn$1(this.Extensions, Extension => {
              Extension.mount(elements);
          });
          event.emit(EVENT_MOUNTED, elements);
          this.readOnly = options.readOnly;
          if (options.autofocus) {
              this.focus();
          }
      }
      /**
       * Collects essential elements that constitute the code editor.
       */
      collect() {
          const { root } = this;
          const editor = query(root, `.${CLASS_EDITOR}`);
          const lines = query(root, `.${CLASS_LINES}`);
          toggleEditable(lines, true);
          attr(lines, { tabindex: 0 });
          this.elements = Object.freeze({
              root,
              editor,
              lines,
              editable: lines,
              body: query(root, `.${CLASS_BODY}`),
              scroller: query(root, `.${CLASS_SCROLLER}`),
              container: query(root, `.${CLASS_CONTAINER}`),
              overlay: div(CLASS_OVERLAY, root),
              background: div({ class: CLASS_BACKGROUND, 'aria-hidden': true }, editor),
          });
      }
      /**
       * Listens to some events.
       */
      listen() {
          const { elements, elements: { root }, event } = this;
          const isFocused = this.isFocused.bind(this);
          let type;
          this.bind(root, 'pointerdown', () => {
              type = 'pointer';
          });
          this.bind(elements.editor, 'click', () => {
              if (!isFocused()) {
                  this.focus(true);
              }
          });
          this.bind(root, 'focusin', () => {
              if (isFocused() && !hasClass(root, CLASS_FOCUSED)) {
                  addClass(root, CLASS_FOCUSED);
                  event.emit(EVENT_FOCUS, type);
              }
          });
          this.bind(root, 'focusout', debounce(() => {
              if (!isFocused() && hasClass(root, CLASS_FOCUSED)) {
                  removeClass(root, CLASS_FOCUSED);
                  event.emit(EVENT_BLUR);
                  type = '';
              }
          }, FOCUSOUT_DEBOUNCE_DURATION));
          event.on([EVENT_MOUNTED, EVENT_CHANGED, EVENT_COMPOSITION_START, EVENT_RESET], () => {
              nextTick(() => {
                  toggleClass(root, CLASS_EMPTY, !this.value && !this.Components.Input.composing);
              });
          });
      }
      /**
       * Listens to native events.
       *
       * @param elm      - A document, a window or an element.
       * @param events   - An event name or names.
       * @param callback - A callback function.
       */
      bind(elm, events, callback) {
          on(elm, events, callback, this);
      }
      /**
       * Applies the editor to the target element.
       *
       * @param target - A selector to find the target element, or a target element itself.
       * @param code   - Optional. The code to overwrite the content of the target element.
       */
      apply(target, code) {
          assert$1(!this.root, 'Already initialized.');
          const elm = isString(target) ? query(document, target) : target;
          if (isHTMLElement(elm)) {
              this.source = elm;
              if (hasClass(elm, CLASS_RENDERED)) {
                  this.root = elm;
                  const pre = query(elm, 'pre');
                  this.Components.Code.init(text(pre) || '');
                  remove(pre);
              }
              else {
                  elm.insertAdjacentHTML('afterend', this.html(isUndefined$1(code) ? text(elm) : code, false));
                  styles(elm, { display: 'none' });
                  this.root = elm.nextElementSibling;
              }
              addClass(this.root, [CLASS_INITIALIZED, isMobile() ? CLASS_MOBILE : '']);
              this.collect();
              this.mount();
          }
          else {
              assert$1(false, `${target} is invalid.`);
          }
      }
      /**
       * Returns HTML of the editor.
       * This may not contain all lines because IE can not render tons of HTML tags at the same time.
       * The number of lines can be specified by options.
       *
       * @param code   - A code string.
       * @param source - Optional. Whether to embed the source code into the editor or not.
       *
       * @return The HTML of the editor.
       */
      html(code, source) {
          const { Code } = this.Components;
          Code.init(code);
          return new Renderer(Code, this.event, this.options).html(source);
      }
      /**
       * Saves the content to the source element.
       */
      save() {
          const { source, value } = this;
          if (source instanceof HTMLTextAreaElement) {
              source.value = value;
          }
          else {
              text(source, escapeHtml(value));
          }
      }
      /**
       * Focuses to the editable area.
       *
       * @param reselect - Determines whether to reselect the last position or not.
       */
      focus(reselect) {
          if (reselect) {
              this.Components.Selection.reselect();
          }
          else {
              focus(this.elements.editable);
          }
      }
      /**
       * Removes the focus from the editor.
       */
      blur() {
          const elm = activeElement();
          if (this.isFocused() && isHTMLElement(elm)) {
              elm.blur();
          }
      }
      /**
       * Attempts to invoke the method of the specified extension.
       *
       * @param name   - A name of the extension.
       * @param method - A method name to invoke.
       * @param args   - Optional. Arguments for the method.
       *
       * @return The return value of the method.
       */
      invoke(name, method, ...args) {
          const extension = this.Extensions[name];
          if (extension && isFunction(extension[method])) {
              return extension[method](...args);
          }
      }
      /**
       * Returns the extension of the specified name.
       *
       * @param name - A name of an extension.
       *
       * @return An extension if found, or otherwise `undefined`.
       */
      require(name) {
          return this.Extensions[name];
      }
      /**
       * Checks if the editor is focused or not.
       *
       * @return `true` if the editor is focused, or otherwise `false`.
       */
      isFocused() {
          return this.root.contains(activeElement());
      }
      /**
       * Destroys the editor.
       */
      destroy() {
          const { event } = this;
          this.save();
          forOwn$1(assign$1(this.Components, this.Extensions), Component => {
              Component.destroy();
          });
          delete this.Components;
          delete this.Extensions;
          styles(this.source, { display: '' });
          remove(this.elements.root);
          event.emit(EVENT_DESTROYED);
          event.destroy();
      }
      /**
       * Sets a new value to the editor.
       *
       * @param value - A value to set.
       */
      set value(value) {
          const { Components, Components: { Code, Selection } } = this;
          Code.value = value;
          Components.View.jump(0);
          Components.Sync.sync(0, Code.size - 1);
          if (this.isFocused()) {
              Selection.set([0, 0]);
          }
          else {
              Selection.update([0, 0], [0, 0], true);
          }
          this.event.emit(EVENT_RESET);
      }
      /**
       * Returns the current value of the editor.
       *
       * @return The current value.
       */
      get value() {
          return this.Components.Code.value;
      }
      /**
       * Sets the width of the root element.
       *
       * @param width - Width to set as pixel or CSS styles.
       */
      set width(width) {
          styles(this.root, { width: unit(width) });
          this.Components.View.emitResize();
      }
      /**
       * Returns the width of the editor in pixel.
       *
       * @return The width of the editor.
       */
      get width() {
          return this.root.clientWidth;
      }
      /**
       * Sets the height of the root element.
       *
       * @param height - Height to set as pixel or CSS styles.
       */
      set height(height) {
          styles(this.root, { height: unit(height) });
          this.Components.View.emitResize();
      }
      /**
       * Returns the height of the editor in pixel.
       *
       * @return The height of the editor.
       */
      get height() {
          return this.root.clientHeight;
      }
      /**
       * Makes the editor mutable or immutable.
       *
       * @param readOnly - Whether to make the editor immutable or mutable.
       */
      set readOnly(readOnly) {
          const { elements } = this;
          toggleClass(elements.root, CLASS_READONLY, readOnly);
          toggleEditable(elements.editable, !readOnly);
          this._readOnly = readOnly;
          this.event.emit(EVENT_READONLY, readOnly);
      }
      /**
       * Indicates whether the editor is disabled or not.
       *
       * @return - `true` if the input is read-only or `false` if not.
       */
      get readOnly() {
          return this._readOnly;
      }
  }

  /**
   * The frontend class for the editor.
   *
   * @since 0.1.0
   */
  class RyuseiCode {
      /**
       * The constructor.
       *
       * @param options - Optional. Options.
       */
      constructor(options) {
          this.mergeOptions(options);
          this.language = RyuseiCode.get(this.options.language);
          this.Editor = new Editor(this.language, this.options, RyuseiCode.Extensions);
      }
      /**
       * Registers a language or languages.
       *
       * @example
       * ```js
       * import { RyuseiCode, javascript, html } from '@ryusei/code';
       *
       * RyuseiLight.register( javascript() );
       *
       * // Or pass an array:
       * RyuseiLight.register( [ javascript(), html() ] );
       * ```
       *
       * If you want to register all languages the `languages` object is helpful:
       *
       * ```js
       * import { RyuseiCode, languages } from '@ryusei/code';
       *
       * RyuseiLight.register( Object.values( languages ).map( lang => lang() ) );
       * ```
       *
       * @param languages - A Language object or an array with objects.
       */
      static register(languages) {
          toArray(languages).forEach(language => {
              const { language: lang, id } = language;
              if (!RyuseiCode.languages[id]) {
                  (lang.alias || []).concat(id).forEach((id) => {
                      RyuseiCode.languages[id] = language;
                  });
              }
          });
      }
      /**
       * Registers extensions.
       *
       * @example
       * ```js
       * import { RyuseiCode, ActiveLine, History } from '@ryusei/code';
       *
       * RyuseiLight.register( { ActiveLine, History } );
       * ```
       *
       * If you want to compose all extensions, the `Extensions` object is helpful:
       *
       * ```js
       * import { RyuseiCode, Extensions } from '@ryusei/code';
       *
       * RyuseiLight.register( Extensions );
       * ```
       *
       * @param extensions - An object literal with extensions.
       */
      static compose(extensions) {
          forOwn$1(extensions, (Extension, name) => {
              RyuseiCode.Extensions[name] = Extension;
          });
      }
      /**
       * Returns a Language object.
       *
       * @param id - The language ID.
       *
       * @return A Language object.
       */
      static get(id) {
          const { languages } = RyuseiCode;
          assert$1(languages[id], `${id} was not found.`);
          return languages[id];
      }
      /**
       * Merges options with default values.
       *
       * @param options - Options to merge.
       */
      mergeOptions(options) {
          this.options = assign$1({}, DEFAULT_OPTIONS$6);
          forOwn$1(options, (value, key) => {
              if (!isUndefined$1(value)) {
                  if (isObject$1(DEFAULT_OPTIONS$6[key])) {
                      if (isObject$1(value)) {
                          this.options[key] = assign$1({}, DEFAULT_OPTIONS$6[key], value);
                      }
                  }
                  else {
                      this.options[key] = value;
                  }
              }
          });
      }
      /**
       * Applies the editor to the specified target element.
       *
       * @example
       * ```js
       * const ryuseiCode = new RyuseiCode();
       * ryuseiCode.apply( 'textarea' );
       *
       * // or
       * const textarea = document.querySelector( 'textarea' );
       * ryuseiCode.apply( textarea )
       * ```
       *
       * <div class="caution">
       * The instance can not have multiple targets.
       * If the <code>apply()</code> method is called twice to the same element, it throws an error.
       * </div>
       *
       * @param target - A selector or an element to apply the editor to.
       * @param code   - Optional. The code to overwrite the content of the target element.
       */
      apply(target, code) {
          this.Editor.apply(target, code);
      }
      /**
       * Builds the HTML of the editor. This works without `document` and `window` objects,
       * but has no functionality.
       *
       * The [`maxInitialLine`](/guides/options#max-initial-lines) option limits the number of lines to generate.
       *
       * @param code - Initial code.
       *
       * @return A HTML string for the editor.
       */
      html(code) {
          return this.Editor.html(code, true);
      }
      /**
       * Attaches an event handler to the editor event or events.
       *
       * ```js
       * // ke is the native KeyboardEvent object
       * ryuseiCode.on( 'keydown', ( e, ke ) => {
       *   console.log( ke.key );
       * } );
       *
       * // With a namespace:
       * ryuseiCode.on( 'keydown.myNamespace', ( e, ke ) => {
       *   console.log( ke.key );
       * } );
       * ```
       *
       * @param events   - An event name or names separated by spaces, or an array with event names.
       *                   Use a dot(.) to add a namespace.
       * @param callback - A callback function.
       */
      on(events, callback) {
          this.Editor.event.on(events, callback);
      }
      /**
       * Detaches an event handler registered by `on()`.
       *
       * ```js
       * // Detach all handlers:
       * ryuseiCode.off( 'keydown' );
       *
       * // Detach handlers only in the namespace:
       * ryuseiCode.off( 'keydown.myNamespace' );
       * ```
       *
       * @param events - An event name or names separated by spaces, or or an array with event names.
       *                 Use a dot(.) to add a namespace.
       */
      off(events) {
          this.Editor.event.off(events);
      }
      /**
       * Saves the content to the source element if available.
       *
       * For example, if you apply the editor to the empty `textarea` element,
       * it remains empty even after you edit the code by the editor.
       *
       * This method applies back the change to the `textarea` element.
       */
      save() {
          this.Editor.save();
      }
      /**
       * Focuses to the editable area.
       *
       * @param reselect - Determines whether to reselect the last position or not.
       */
      focus(reselect) {
          this.Editor.focus(reselect);
      }
      /**
       * Sets the caret position or selection range.
       *
       * @param start - A start position as `[ row, col ]`.
       * @param end   - Optional. An end position. If omitted, the selection will be collapsed to the start.
       */
      setRange(start, end) {
          this.Editor.Components.Selection.set(start, end);
      }
      /**
       * The alias of the `value` property that returns the current code as a string.
       *
       * @return The current code as a string.
       */
      toString() {
          return this.value;
      }
      /**
       * Saves the final value to the source element and destroys the editor for releasing the memory.
       */
      destroy() {
          this.Editor.destroy();
          delete this.Editor;
      }
      /**
       * Sets a new value to the editor and refreshes it.
       *
       * @param value - A new value.
       */
      set value(value) {
          this.Editor.value = value;
      }
      /**
       * Returns the current value as a string.
       *
       * @return The current value.
       */
      get value() {
          return this.Editor.value;
      }
  }
  /**
   * Stores all language objects.
   */
  RyuseiCode.languages = {};
  /**
   * Stores all Component classes.
   */
  RyuseiCode.Extensions = {};

  /**
   * The class name for the active line element.
   *
   * @since 0.1.0
   */
  const CLASS_ACTIVE_LINE = `${PROJECT_CODE}__active-line`;
  /**
   * The component for activating/deactivating lines according to the current selection.
   *
   * @since 0.1.0
   */
  class ActiveLine extends Component {
      /**
       * The ActiveLine constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(Editor);
          this.on(EVENT_INIT_STYLE, (e, add) => {
              add(`.${CLASS_ACTIVE_LINE}`, 'height', this.options.lineHeight);
          });
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          super.mount(elements);
          this.line = div({ class: CLASS_ACTIVE_LINE }, elements.background);
          this.on([EVENT_FOCUS, EVENT_FOCUS_LINE_CHANGED, EVENT_READONLY], (e, readOnly) => {
              if (e.type !== EVENT_READONLY || !readOnly) {
                  this.activate();
                  this.offset();
              }
              else {
                  this.deactivate();
              }
          });
          this.on(EVENT_BLUR, this.deactivate, this);
          this.on(EVENT_RESIZE, this.offset, this);
      }
      /**
       * Activates the element.
       */
      activate() {
          const { Editor } = this;
          if (Editor.isFocused() && !Editor.readOnly) {
              if (!this.isActive()) {
                  addClass(this.line, CLASS_ACTIVE);
                  this.emit('activeLine:activated');
              }
          }
      }
      /**
       * Offsets the active line element to the current focus node.
       */
      offset() {
          if (this.isActive()) {
              const { Measure } = this;
              const top = Measure.getTop(this.Selection.focus[0]) + Measure.padding.top;
              if (this.top !== top) {
                  styles(this.line, { top: unit((this.top = top)) });
                  this.emit('activeLine:updated');
              }
          }
      }
      /**
       * Deactivates the element.
       */
      deactivate() {
          removeClass(this.line, CLASS_ACTIVE);
          this.top = -1;
          this.emit('activeLine:deactivated');
      }
      /**
       * Checks if the element is active or not.
       *
       * @return `true` if the element is active, or otherwise `false`.
       */
      isActive() {
          return hasClass(this.line, CLASS_ACTIVE);
      }
  }

  /**
   * The component for auto closing brackets.
   *
   * @since 0.1.0
   */
  class AutoClose extends Component {
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          super.mount(elements);
          this.on(EVENT_KEYDOWN, (e, ke) => {
              this.skip(ke);
              this.remove(ke);
          });
          this.on(EVENT_CHANGED, (e, type) => {
              if (type === 'input') {
                  this.close();
              }
          });
      }
      /**
       * Closes the entered opening character.
       */
      close() {
          const { Input } = this;
          if (!Input.composing) {
              const index = this.getChars(false).indexOf(Input.get().key);
              if (index > -1 && this.validate(index, 'close')) {
                  Input.apply({
                      type: 'autoClose',
                      insertion: this.getClosingString(index),
                      offset: this.getOffset(index),
                  });
              }
          }
      }
      /**
       * Skips the entered close character if the next character is already the closing character.
       *
       * @param e - A KeyboardEvent object.
       */
      skip(e) {
          const { Input } = this;
          if (!Input.composing) {
              const closingChars = this.getChars(true);
              const index = closingChars.indexOf(normalizeKey(e.key));
              if (index > -1 && this.validate(index, 'skip')) {
                  if (closingChars[index] === Input.char()) {
                      const { Selection, Selection: { focus } } = this;
                      Selection.set([focus[0], focus[1] + 1]);
                      prevent(e);
                  }
              }
          }
      }
      /**
       * Automatically removes the paired characters when the backspace key is pressed.
       *
       * @param e - A KeyboardEvent object.
       */
      remove(e) {
          const { Input } = this;
          if (e.key === 'Backspace') {
              const index = this.getChars(false).indexOf(Input.char(Input.col - 1));
              if (index > -1 && this.validate(index, 'remove')) {
                  if (this.getChars(true)[index] === Input.char()) {
                      const { Selection, Selection: { focus } } = this;
                      Input.value = Input.before + Input.after.slice(1);
                      Selection.set(focus);
                  }
              }
          }
      }
      /**
       * Returns an array with opening/closing characters.
       *
       * @param closing - Determines whether to get closing or opening characters.
       *
       * @return An array with characters.
       */
      getChars(closing) {
          return this.getConfig().map(chars => {
              const value = chars[closing ? 1 : 0];
              return isString(value) ? value : '';
          });
      }
      /**
       * Returns a closing string.
       *
       * @param index - A config index.
       *
       * @return A closing string. This may be empty.
       */
      getClosingString(index) {
          const config = this.getConfig()[index];
          const closer = config && config[1];
          return isFunction(closer) ? closer(this.Editor) : closer || '';
      }
      /**
       * Returns a number of characters to offset.
       *
       * @param index - A config index.
       *
       * @return The number of characters to offset.
       */
      getOffset(index) {
          const config = this.getConfig()[index];
          const data = config && config[2];
          return data ? data.offset || 0 : 0;
      }
      /**
       * Executes the validator defined by the language data.
       *
       * @param index - A config index.
       * @param key   - A key of the validator.
       *
       * @return `true` if the input satisfies the validator, or otherwise `false`.
       */
      validate(index, key) {
          const { Scope } = this;
          const config = this.getConfig()[index];
          const data = config[2];
          if (!data) {
              return true;
          }
          const validator = data[key];
          if (isFunction(validator)) {
              return validator(this.Editor, config);
          }
          if (isString(validator)) {
              if (validator === '@quotes') {
                  return this.validateQuote(key);
              }
              return false;
          }
          if (isArray(validator)) {
              return Scope.isIn(validator);
          }
          return validator;
      }
      /**
       * Determines whether to proceed completion of quotes or not.
       * - RegExp: checks the string after the input quote.
       *
       * @param key - The key of the validator.
       *
       * @return `true` if the completion process should be proceeded, or otherwise `false`.
       */
      validateQuote(key) {
          const { start } = this.Selection.get();
          const { Input } = this;
          const currInfo = this.lines.getInfoAt(start);
          const prevInfo = Input.info;
          if (currInfo) {
              if (currInfo.category === CATEGORY_STRING || prevInfo && prevInfo.category === CATEGORY_STRING) {
                  if (key === 'skip' || key === 'remove') {
                      return compare(start, [start[0], currInfo.to - 1]) === 0;
                  }
                  return false;
              }
          }
          const { after } = Input;
          return !this.Scope.isIn('comment') && (!after || /^\s/.test(after));
      }
      /**
       * Returns the config array.
       *
       * @return A config array.
       */
      getConfig() {
          return this.getLanguage().autoClose || [];
      }
  }

  /**
   * The default options for the BracketMatching component.
   *
   * @since 0.1.0
   */
  const DEFAULT_OPTIONS$5 = {
      brackets: [
          ['(', '[', '{', '<'],
          [')', ']', '}', '>'],
      ],
      maxScanLines: 1000,
  };

  /**
   * The group ID for markers.
   *
   * @since 0.1.0
   */
  const MARKER_ID$2 = 'brackets';
  /**
   * The debounce duration for the clear method.
   *
   * @since 0.1.0
   */
  const CLEAR_DEBOUNCE_DURATION = 50;
  /**
   * The component for highlighting matched brackets.
   *
   * @since 0.1.0
   */
  class BracketMatching extends Component {
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          const options = this.getOptions('bracketMatching', DEFAULT_OPTIONS$5);
          this.brackets = options.brackets;
          this.maxScanLines = options.maxScanLines;
          super.mount(elements);
          this.clear = debounce(() => { this.Range.clear(MARKER_ID$2); }, CLEAR_DEBOUNCE_DURATION);
          this.update = rafThrottle(this.update.bind(this));
          this.on(EVENT_SELECTED, this.onSelected, this);
          this.on(EVENT_READONLY, (e, readOnly) => {
              if (readOnly) {
                  this.clear();
              }
          });
      }
      /**
       * Called when the selection state is changed.
       *
       * @param e         - An EventBusEvent object.
       * @param Selection - A Selection instance.
       */
      onSelected(e, Selection) {
          if (Selection.is(START, SELECTING, EXTEND)) {
              this.clear();
          }
          else if (Selection.is(CHANGED)) {
              if (!this.Editor.readOnly && Selection.isCollapsed()) {
                  this.update();
              }
          }
      }
      /**
       * Checks the current location and renders markers.
       */
      update() {
          const { focus } = this.Selection;
          const before = focus[1] > 0 ? [focus[0], focus[1] - 1] : null;
          this.clear.invoke();
          [before, focus].some(position => {
              if (position && this.Scope.inCategory(CATEGORY_BRACKET, position)) {
                  this.draw(position[0], this.lines.getInfoAt(position));
                  return true;
              }
          });
      }
      /**
       * Draws the provided bracket token and its counterpart.
       *
       * @param row  - A row index.
       * @param info - A TokenInfo object.
       */
      draw(row, info) {
          const match = this.find(false, row, info) || this.find(true, row, info);
          if (match) {
              const { Range } = this;
              Range.clear(MARKER_ID$2);
              Range.register(MARKER_ID$2, [this.infoToRange(row, info), this.infoToRange(match.row, match.info)]);
          }
      }
      /**
       * Finds the counterpart of the provided token.
       *
       * @param findClosing - Determines whether to find closing part or not.
       * @param row         - A row index.
       * @param info        - A TokenInfo object.
       *
       * @return A counter token of the passed info if found, or otherwise `undefined`.
       */
      find(findClosing, row, info) {
          const { brackets } = this;
          const index = brackets[Number(!findClosing)].indexOf(info.code);
          if (index > -1) {
              const counterpart = brackets[Number(findClosing)][index];
              return this.lines[`scan${findClosing ? 'Down' : 'Up'}`]([row, info.from], [CATEGORY_BRACKET, new RegExp(escapeRegExp(counterpart))], [CATEGORY_BRACKET, new RegExp(escapeRegExp(info.code))], 1, this.maxScanLines);
          }
      }
      /**
       * Converts the provided TokeInfo object to the range.
       *
       * @param row  - A row index.
       * @param info - A TokenInfo object to convert.
       *
       * @return A Range object.
       */
      infoToRange(row, info) {
          return { start: [row, info.from], end: [row, info.to] };
      }
  }

  /**
   * The collection of shortcuts for the Comment extension.
   *
   * @since 0.1.0
   */
  const KEYMAP$5 = {
      lineComment: ['/', true],
      blockComment: ['?', true, true],
  };

  /**
   * The input type for comment or uncomment changes.
   *
   * @since 0.1.0
   */
  const COMMENT_INPUT_TYPE = 'comment';
  /**
   * The class for commenting out or uncommenting code.
   *
   * @since 0.1.0
   */
  class Comment extends Component {
      /**
       * The Comment constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(Editor);
          this.addKeyBindings(KEYMAP$5);
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          super.mount(elements);
          const { language } = this;
          if (language.blockComment) {
              this.on(`${EVENT_KEYMAP}:blockComment`, this.toggleBlock, this);
          }
          if (language.lineComment) {
              this.on(`${EVENT_KEYMAP}:lineComment`, this.toggleLine, this);
          }
      }
      /**
       * Toggles block comments.
       * If the `start` or `end` position of the selection is inside a comment, unwraps the comment.
       * Otherwise, comments out the selection.
       */
      toggleBlock() {
          let { start, end } = this.Selection.get();
          const range = this.detectBlockComment(start) || this.detectBlockComment(end);
          this.emit(EVENT_CHANGE, COMMENT_INPUT_TYPE);
          if (range) {
              start = range.start;
              end = range.end;
              this.uncomment(start, end, false);
          }
          else {
              this.commentOut(start, end, false);
          }
          this.sync(start, end, !!range, false);
          this.emit(EVENT_CHANGED, COMMENT_INPUT_TYPE);
      }
      /**
       * Toggles line comments.
       */
      toggleLine() {
          const { start, end } = this.Selection.get();
          const { lines } = this;
          this.emit(EVENT_CHANGE, COMMENT_INPUT_TYPE);
          let endPosition;
          let uncommented;
          for (let i = start[0]; i <= end[0]; i++) {
              const range = this.detectLineComment([i, lines[i].text.length]);
              if (range) {
                  this.uncomment(range.start, range.end, true);
                  endPosition = end;
                  uncommented = true;
              }
          }
          if (!uncommented) {
              const minIndent = lines.findMinIndent(start[0], end[0]);
              for (let i = start[0]; i <= end[0]; i++) {
                  this.commentOut([i, minIndent.length], [i, lines[i].text.length], true);
              }
          }
          this.sync(start, endPosition || end, uncommented, true);
          this.emit(EVENT_CHANGED, COMMENT_INPUT_TYPE);
      }
      /**
       * Comments out code between the start and end positions.
       *
       * @param start - A start position.
       * @param end   - An end position.
       * @param line  - Whether to use a line comment or not.
       */
      commentOut(start, end, line) {
          const { Code } = this;
          const comment = this.getConfig(line ? [start[0], 0] : start, line);
          if (comment) {
              const commentStart = comment[0] + (comment[1] ? '' : ' ');
              Code.replaceRange(start, end, `${commentStart}${Code.sliceRange(start, end)}${comment[1] || ''}`);
          }
      }
      /**
       * Converts back the commented out code into the source code.
       *
       * @param start - A start position.
       * @param end   - An end position.
       * @param line  - Whether to use a line comment or not.
       */
      uncomment(start, end, line) {
          const { Code } = this;
          const comment = this.getConfig(start, line);
          if (comment) {
              const replacement = Code.sliceRange(start, end);
              const source = `^${escapeRegExp(comment[0])}[ ]?|[ ]?${escapeRegExp(comment[1])}$`;
              Code.replaceRange(start, end, replacement.replace(new RegExp(source, 'g'), ''));
          }
      }
      /**
       * Syncs the code to the viewport.
       *
       * @param start       - A start position
       * @param end         - An end position.
       * @param uncommented - Determines whether to sync code for uncommented or commented out lines.
       * @param line        - Determines whether to sync code for line or block comments.
       */
      sync(start, end, uncommented, line) {
          const { lines } = this;
          const range = this.Selection.get();
          const comment = this.getConfig(start, line);
          if (!comment) {
              return;
          }
          let row = uncommented && !line ? range.start[0] : end[0];
          let col = range.end[1];
          if (line) {
              row = min(row + 1, lines.length - 1);
          }
          else {
              const length = comment[0].length;
              if (uncommented) {
                  if (row === start[0]) {
                      col -= length;
                  }
              }
              else {
                  if (row === start[0]) {
                      col += length;
                  }
              }
          }
          this.View.jump(row);
          this.Sync.sync(start[0], end[0]);
          col = clamp(col, 0, this.lines[row].text.length);
          this.Selection.set([row, col]);
      }
      /**
       * Returns the comment config object at the position.
       *
       * @param position - A position.
       * @param line     - Determines whether to get a line comment configuration or not.
       *
       * @return An object with `start` and `end` that represent a comment syntax.
       */
      getConfig(position, line) {
          return this.getLanguage(position)[`${line ? 'line' : 'block'}Comment`];
      }
      /**
       * Detects the range of a block comment around the provided position.
       *
       * @param position - A position that may be inside a block comment.
       *
       * @return A Range object if the passed position is inside a block comment.
       *         Otherwise, `null`.
       */
      detectBlockComment(position) {
          const { lines } = this;
          const info = lines.getInfoAt(position);
          if (info && info.category === CATEGORY_COMMENT) {
              const start = lines.findBlockStart(position);
              const end = lines.findBlockEnd(position);
              if (start && end) {
                  return { start, end };
              }
          }
          return null;
      }
      /**
       * Detects the range of a line comment at the provided position.
       * This method does not care that the code is actually categorized as a comment,
       * but only care about the representation of the line comment.
       *
       * @param position - A position that may be on the line containing a line comment.
       *
       * @return A Range object if the row contains a line comment. Otherwise, `null`.
       */
      detectLineComment(position) {
          const [head, tail] = this.getConfig(position, true);
          const [row] = position;
          const line = this.lines[row].text;
          if (line) {
              const trimmed = line.trim();
              if (startsWith$1(trimmed, head) && (!tail || endsWith(trimmed, tail))) {
                  const endCol = tail ? line.lastIndexOf(tail) : line.length;
                  return {
                      start: [row, line.indexOf(head)],
                      end: [row, endCol],
                  };
              }
          }
          return null;
      }
  }

  /**
   * A collection of settings for general UI buttons.
   *
   * @since 0.1.0
   */
  const GENERAL_UI_BUTTONS = {
      confirm: {
          id: 'confirm',
          click: 'confirm',
      },
      cancel: {
          id: 'cancel',
          click: 'hide',
          tabindex: 0,
      },
  };

  /**
   * Classes for dialog components.
   *
   * @since 0.1.0
   */
  const CLASS_DIALOG = `${PROJECT_CODE}__dialog`;
  const CLASS_DIALOG_GROUP = `${CLASS_DIALOG}__group`;
  const CLASS_DIALOG_HEADER = `${CLASS_DIALOG}__header`;
  const CLASS_DIALOG_TITLE = `${CLASS_DIALOG}__title`;
  const CLASS_DIALOG_BODY = `${CLASS_DIALOG}__body`;
  const CLASS_DIALOG_FOOTER = `${CLASS_DIALOG}__footer`;

  /**
   * The group ID of the common dialog.
   *
   * @since 0.1.0
   */
  const COMMON_DIALOG_GROUP = `${PROJECT_CODE}-common`;
  /**
   * The component for displaying a dialog.
   *
   * @since 0.1.0
   */
  class Dialog extends UIComponent {
      /**
       * Initializes the component.
       *
       * @param elements - A collection of editor elements.
       */
      mount(elements) {
          super.mount(elements);
          this.register(COMMON_DIALOG_GROUP, div(), '');
      }
      /**
       * Listens to some events.
       */
      listen() {
          this.bind(window, 'click', e => {
              if (!this.wrapper.contains(e.target)) {
                  this.hide();
              }
          });
          this.on(EVENT_INIT_STYLE, (e, add) => {
              add(`.${CLASS_DIALOG} code`, 'fontFamily', this.options.monospaceFont);
          });
      }
      /**
       * Creates dialog elements.
       * Note that the dialog element must/should have:
       * - an accessible name by `aria-label` or `aria-labelledby`.
       * - at least one focusable descendant element.
       *
       * @link https://www.w3.org/TR/wai-aria-1.2/#dialog
       */
      create() {
          const { elements } = this;
          const id = `${elements.root.id}-dialog`;
          this.wrapper = div({
              id,
              class: CLASS_DIALOG,
              role: 'dialog',
              'aria-labelledby': `${id}-title`,
              'aria-describedby': `${id}-body`,
          }, elements.overlay);
      }
      /**
       * Called when the general confirm button is clicked.
       *
       * @internal
       */
      confirm() {
          this.emit(`dialog:${this.group}:confirmed`, this);
          this.hide();
      }
      /**
       * Registers a new dialog.
       * Use `message()` instead just for showing a message.
       *
       * @example
       * ```ts
       * const ryuseiCode = new RyuseiCode();
       * const Dialog     = ryuseiCode.Editor.require( 'Dialog' );
       *
       * // The Dialog extension may not exist.
       * if ( Dialog ) {
       *   const body = document.createElement( 'p' );
       *   body.textContent = 'Hello!';
       *   Dialog.register( 'sample', body, 'Sample Dialog', [ 'confirm' ] );
       *   Dialog.show( 'sample' );
       * }
       * ```
       *
       * If you want to add custom buttons, pass an array with button settings to the `buttons`.
       *
       * ```ts
       * const settings = [
       *   {
       *     id: 'myButton',
       *     html: 'Click Me',
       *     click() {
       *       console.log( 'Clicked!' );
       *     },
       *   }
       * ];
       *
       * Dialog.register( 'sample', body, 'Sample Dialog', settings );
       * ```
       *
       * @param group   - A group ID.
       * @param elm     - An element to display as a dialog body.
       * @param title   - A title of a dialog.
       * @param buttons - Optional. General button names, `'confirm'`, `'cancel'`, or objects with button settings.
       */
      register(group, elm, title, buttons) {
          const settings = (buttons || ['confirm'])
              .map(settings => isString(settings) ? GENERAL_UI_BUTTONS[settings] : settings)
              .filter(Boolean);
          assert$1(settings.length);
          const { id } = this.wrapper;
          const groupElm = div(CLASS_DIALOG_GROUP);
          const headerElm = create('header', CLASS_DIALOG_HEADER);
          const titleElm = create('h3', { id: `${id}-title`, class: CLASS_DIALOG_TITLE }, headerElm);
          const footerElm = create('footer', CLASS_DIALOG_FOOTER);
          const button = this.createCloseButton({ 'aria-controls': id });
          attr(elm, { id: `${id}-body`, class: CLASS_DIALOG_BODY });
          text(titleElm, title);
          addClass(button, `${CLASS_DIALOG}__close`);
          append(groupElm, [headerElm, elm, footerElm, button]);
          this.groups[group] = {
              elm: groupElm,
              title: titleElm,
              body: elm,
              buttons: this.createButtons(settings, footerElm, this),
          };
      }
      /**
       * Opens the specified dialog. The dialog must be registered by `register()` before opening it.
       *
       * @param group - A dialog ID to open.
       */
      show(group) {
          this.hide();
          super.show(group);
          this.Editor.readOnly = true;
          addClass(this.elements.overlay, CLASS_ACTIVE);
          this.autoFocus(group);
          this.emit('dialog:opened', this, group);
      }
      /**
       * Closes the dialog which is visible now. Nothing will happen when there is no shown dialog.
       */
      hide() {
          if (this.isActive()) {
              this.Editor.readOnly = false;
              super.hide();
              removeClass(this.elements.overlay, CLASS_ACTIVE);
              this.Selection.reselect();
              this.emit('dialog:closed', this, this.group);
          }
      }
      /**
       * Displays a message with a common dialog. No registration required.
       *
       * @param message - A message to display.
       * @param title   - Optional. A title of a dialog. If omitted, uses the `notice` in the `i18n` collection.
       */
      message(message, title) {
          const data = this.groups[COMMON_DIALOG_GROUP];
          text(data.title, title || this.i18n.notice);
          text(data.body, message);
          this.show(COMMON_DIALOG_GROUP);
      }
  }

  /**
   * The class for rendering the indent guide.
   *
   * @since 0.1.0
   */
  class IndentMarker extends Marker {
      /**
       * Calculates boundaries for drawing the marker.
       * Because every indent size is same, this method uses the cache of the width for the better performance.
       *
       * @param anchor - An anchor position.
       *
       * @return An object with start and end boundaries.
       */
      calcBoundaries(anchor) {
          const { indent } = this.Editor.options;
          const { Measure, Measure: { padding } } = this.Editor.Components;
          const width = Measure.measureWidth(indent, true);
          const top = Measure.getTop(anchor[0]) + padding.top;
          const left = floor(anchor[1] / indent.length) * width + padding.left;
          return {
              start: { top, left },
              end: { top, left: left + width },
          };
      }
  }

  /**
   * The group ID for markers of indent guides.
   *
   * @since 0.1.0
   */
  const MARKER_ID$1 = 'indent';
  /**
   * The component for drawing guide lines.
   *
   * @since 0.1.0
   */
  class Guide extends Component {
      /**
       * Initializes the component.
       *
       * @param elements - A collection of editor elements.
       */
      mount(elements) {
          super.mount(elements);
          this.listen();
      }
      /**
       * Listens some events.
       */
      listen() {
          const draw = this.draw.bind(this);
          this.on(EVENT_CHANGED, rafThrottle(draw));
          this.on([EVENT_MOUNTED, EVENT_CHUNK_MOVED], draw);
      }
      /**
       * Clears current guides and draw new ranges for guides.
       */
      draw() {
          const { Range } = this;
          const ranges = this.parse();
          Range.clearRanges(MARKER_ID$1);
          Range.register(MARKER_ID$1, ranges, false, IndentMarker);
      }
      /**
       * Parses chunk lines and returns ranges for guides.
       *
       * @return An array with ranges.
       */
      parse() {
          const { start, end } = this.Chunk;
          const ranges = [];
          let prev = 0;
          for (let i = max(start, 0); i <= end; i++) {
              const line = this.lines[i];
              if (!line) {
                  break;
              }
              let depth = line.indentDepth - 1;
              if (line.isEmpty() && prev > 0) {
                  depth = prev;
              }
              if (depth > 0) {
                  for (let j = 0; j < depth; j++) {
                      const { length } = this.options.indent;
                      ranges.push({ start: [i, j * length], end: [i, (j + 1) * length] });
                  }
                  prev = depth;
              }
              else {
                  prev = 0;
              }
          }
          return ranges;
      }
  }

  /**
   * The class name for the gutter.
   *
   * @since 0.1.0
   */
  const CLASS_GUTTER = `${PROJECT_CODE}__gutter`;
  /**
   * The class name for the inner element.
   *
   * @since 0.1.0
   */
  const CLASS_GUTTER_FLOAT = `${CLASS_GUTTER}__float`;
  /**
   * The class name for each row element.
   *
   * @since 0.1.0
   */
  const CLASS_GUTTER_ROW = `${CLASS_GUTTER}__row`;
  /**
   * The class name for each line number element.
   *
   * @since 0.1.0
   */
  const CLASS_LINE_NUMBER = `${CLASS_GUTTER}__number`;
  /**
   * The modifier class to apply `sticky`.
   *
   * @since 0.1.0
   */
  const CLASS_STICKY = `${CLASS_GUTTER}--sticky`;
  /**
   * The status class for the root element.
   *
   * @since 0.1.0
   */
  const CLASS_HAS_GUTTER = 'has-gutter';

  /**
   * The default options for the Gutter component.
   *
   * @since 0.1.0
   */
  const DEFAULT_OPTIONS$4 = {
      selectLine: true,
      start: 1,
      sticky: true,
  };

  /**
   * The class for a gutter.
   *
   * @since 0.1.0
   */
  class Gutter extends Component {
      /**
       * The Gutter constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(Editor);
          this.opts = this.getOptions('gutter', DEFAULT_OPTIONS$4);
          this.start = this.opts.start;
          this.on(EVENT_INIT_STYLE, (e, add) => {
              add(`.${CLASS_GUTTER}`, 'fontFamily', this.options.monospaceFont);
          });
          this.render();
      }
      /**
       * Renders a gutter element and rows.
       */
      render() {
          this.on('root:open', (e, append, classes) => {
              classes.push(CLASS_HAS_GUTTER);
          });
          this.on('editor:open', (e, append, classes, lines) => {
              append(tag([CLASS_GUTTER, this.opts.sticky ? CLASS_STICKY : ''], { 'aria-hidden': true }));
              append(tag(CLASS_GUTTER_FLOAT));
              append(this.renderRows(lines, append));
              append(repeat('</div>', 2)); // float and gutter
          });
          this.on(EVENT_INIT_STYLE, (e, add) => {
              const { lineHeight } = this.options;
              add(`.${CLASS_GUTTER_ROW}`, { height: lineHeight ? `${lineHeight}em` : undefined, lineHeight });
          });
      }
      /**
       * Renders rows of a gutter.
       * `+1` creates an extra row for measurement of the gutter width.
       *
       * @param lines  - An array containing lines.
       * @param append - The function that appends a HTML string.
       */
      renderRows(lines, append) {
          const html = [];
          const max = min(lines.length, this.options.maxInitialLines) + 1;
          for (let i = 0; i < max; i++) {
              const number = (i === max - 1 ? lines.length - 1 : i) + this.start;
              append(tag(CLASS_GUTTER_ROW));
              append(`<span class="${CLASS_LINE_NUMBER}">${number}</span>`);
              this.emit('gutter:row', html, i, number);
              append(`</div>`);
          }
          return html.join('');
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          super.mount(elements);
          this.gutter = query(elements.root, `.${CLASS_GUTTER}`);
          this.float = query(this.gutter, `.${CLASS_GUTTER_FLOAT}`);
          if (this.gutter) {
              const { children } = this.float;
              const diff = this.Chunk.length - children.length;
              if (diff > 0) {
                  this.supply(diff);
              }
              else if (diff < 0) {
                  remove(slice(children, diff));
              }
              this.listen();
              this.update();
          }
      }
      /**
       * Supplies the specified number of row and line number elements.
       *
       * @param length - The number of elements to create.
       */
      supply(length) {
          for (let i = 0; i < length; i++) {
              create('span', CLASS_LINE_NUMBER, div(CLASS_GUTTER_ROW, this.float));
          }
      }
      /**
       * Listens to some events.
       */
      listen() {
          this.on(EVENT_CHUNK_SUPPLIED, (e, chunk, diff) => { this.supply(diff); });
          this.on([EVENT_CHUNK_MOVED, EVENT_SCROLL_HEIGHT_CHANGED, EVENT_RESIZE], this.update, this);
          this.on('activeLine:updated', this.activate, this);
          this.on('activeLine:deactivated', this.deactivate, this);
          if (this.opts.selectLine) {
              this.bind(this.gutter, 'pointerdown', this.onPointerDown, this);
          }
      }
      /**
       * Called when the gutter emits the `pointerdown` event.
       *
       * @param e - A PointerEvent object.
       */
      onPointerDown(e) {
          const { target } = e;
          if (isHTMLElement(target) && hasClass(target, CLASS_LINE_NUMBER)) {
              const number = +text(target);
              if (!isNaN(number)) {
                  this.Selection.selectLine(number - this.start, true, true);
                  prevent(e);
              }
          }
      }
      /**
       * Updates line numbers and offsets the float element to the Chunk position.
       */
      update() {
          const { Chunk: { start: chunkStart }, start } = this;
          const { length } = this.lines;
          const { children: rows } = this.float;
          for (let i = 0; i < rows.length; i++) {
              const elm = rows[i];
              const number = (i === rows.length - 1 ? length - 1 : chunkStart + i) + start;
              text(elm.firstChild, between(number, start, length + start - 1) ? `${number}` : '');
          }
          this.offset();
          this.activate();
      }
      /**
       * Offsets the float element to the current Chunk position.
       */
      offset() {
          const { Chunk, Chunk: { start } } = this;
          const offset = Chunk.offsetY + (start < 0 ? start * this.Measure.lineHeight : 0);
          styles(this.float, { top: unit(offset) });
      }
      /**
       * Activates the specified row.
       */
      activate() {
          const row = this.Selection.focus[0];
          const elm = this.getElm(row);
          this.deactivate();
          if (elm) {
              addClass(elm, CLASS_ACTIVE);
              this.activeElm = elm;
              this.emit('gutter:activated', elm);
          }
      }
      /**
       * Deactivates the active row if there is.
       */
      deactivate() {
          const { activeElm } = this;
          if (activeElm) {
              toggleClass(activeElm, CLASS_ACTIVE, false);
              this.emit('gutter:deactivated', activeElm);
              this.activeElm = null;
          }
      }
      /**
       * Returns the element at the row index.
       *
       * @param row - A row index.
       *
       * @return A row element if available, or otherwise `undefined`.
       */
      getElm(row) {
          return row > -1 ? this.float.children[row - this.Chunk.start] : undefined;
      }
  }

  /**
   * The default options for the History component.
   *
   * @since 0.1.0
   */
  const DEFAULT_OPTIONS$3 = {
      limit: 100,
      debounce: 300,
  };

  /**
   * The collection of shortcuts for the History extension.
   *
   * @since 0.1.0
   */
  const KEYMAP$4 = {
      undo: ['Z', true, false],
      redo: ['Z', true, true],
  };

  /**
   * The input type of the history.
   *
   * @since 0.1.0
   */
  const RESTORATION_INPUT_TYPE = 'history';
  /**
   * The component for managing history.
   * This component requires the Keymap component.
   *
   * @since 0.1.0
   */
  class History extends Component {
      /**
       * The Comment constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(Editor);
          /**
           * Holds history records.
           */
          this.history = [];
          /**
           * Indicates the current history index.
           */
          this.index = 0;
          this.addKeyBindings(KEYMAP$4);
      }
      /**
       * Initialized the instance.
       */
      mount(elements) {
          super.mount(elements);
          this.opts = this.getOptions('history', DEFAULT_OPTIONS$3);
          this.debouncedPush = debounce(this.push.bind(this), this.opts.debounce);
          this.listen();
      }
      /**
       * Listens to some internal events.
       */
      listen() {
          this.on(EVENT_CHANGE, this.onChange, this);
          this.on(EVENT_CHANGED, this.onChanged, this);
          this.on(`${EVENT_KEYMAP}:undo ${EVENT_KEYMAP}:redo`, (e, ke, action) => {
              ke.preventDefault();
              if (!this.Editor.readOnly) {
                  this[action]();
              }
          });
          this.on(EVENT_RESET, () => {
              this.history.length = 0;
          });
      }
      /**
       * Creates a history record object.
       *
       * @return A created HistoryRecord object.
       */
      record() {
          return {
              range: this.Selection.get(),
              value: this.Code.value,
              length: this.lines.length,
          };
      }
      /**
       * Restores the provided record.
       * Needs to apply the latest code to the input before sync.
       *
       * @param record - A record to restore.
       */
      restore(record) {
          const { range, length } = record;
          const { start, end } = range;
          this.emit(EVENT_CHANGE, RESTORATION_INPUT_TYPE);
          this.Code.value = record.value;
          this.Sync.sync(0, length - 1, start[0]);
          this.Selection.set(start, end);
          this.emit(EVENT_CHANGED, RESTORATION_INPUT_TYPE);
          this.emit('history:restored', record);
      }
      /**
       * Pushes a record to the history and resets the index.
       * If the `record` is not provided, a new record will be generated via the current editor status.
       *
       * @param record - Optional. A record to push.
       */
      push(record) {
          const current = this.history[this.index];
          if (current && this.isSame(current, record)) {
              return;
          }
          this.history.push(record);
          if (this.length > this.opts.limit) {
              this.history.shift();
          }
          this.index = this.length - 1;
          this.emit('history:pushed', record);
          this.debouncedPush.cancel();
      }
      /**
       * Checks if the provided 2 records are same or not.
       *
       * @param record1 - A record to check.
       * @param record2 - Another record to check.
       *
       * @return `true` if the records are same, or otherwise `false`.
       */
      isSame(record1, record2) {
          return record1.value === record2.value
              && !compare(record1.range.start, record2.range.start)
              && !compare(record1.range.end, record2.range.end);
      }
      /**
       * Checks if an old record is now active or not.
       *
       * @return `true` if an old record is active, or `false` otherwise.
       */
      isUndoing() {
          return this.index !== this.length - 1;
      }
      /**
       * Called when the code is being changed.
       *
       * @param e    - A EventBusEvent object.
       * @param type - An input type. This may be empty.
       */
      onChange(e, type) {
          if (type !== RESTORATION_INPUT_TYPE) {
              const { history } = this;
              if (this.isUndoing()) {
                  history.splice(this.index + 1, history.length);
              }
              if (!this.Selection.isCollapsed() || !this.length || type === 'replace') {
                  this.push(this.record());
              }
          }
      }
      /**
       * Called just after the code is changed.
       *
       * @param e    - A EventBusEvent object.
       * @param type - An input type. This may be empty.
       */
      onChanged(e, type) {
          if (!this.Input.composing && type !== RESTORATION_INPUT_TYPE) {
              if (type === 'input') {
                  this.debouncedPush(this.record());
              }
              else {
                  this.push(this.record());
              }
          }
      }
      /**
       * Performs undo.
       */
      undo() {
          this.debouncedPush.invoke();
          if (0 < this.index && this.index < this.length) {
              this.restore(this.history[--this.index]);
          }
      }
      /**
       * Performs redo only if previously undo() is operated.
       */
      redo() {
          if (this.index < this.length - 1) {
              this.restore(this.history[++this.index]);
          }
      }
      /**
       * Returns the current history length.
       *
       * @return The number of records.
       */
      get length() {
          return this.history.length;
      }
  }

  /**
   * The default options for the Tab component.
   *
   * @since 0.1.0
   */
  const DEFAULT_OPTIONS$2 = {
      help: true,
      deepIndent: true,
  };

  /**
   * The collection of i18n strings.
   *
   * @since 0.1.0
   */
  const I18N$3 = {
      indentNotice: 'Indent/Move Focus',
      indentDisabled: 'Inserting indents by the Tab is currently disabled. You can toggle it by %s.',
  };

  /**
   * The collection of shortcuts for the Indentation extension.
   *
   * @since 0.1.0
   */
  const KEYMAP$3 = {
      indent: ['Tab'],
      unindent: ['Tab', false, true],
      toggleTabMode: ['M', true],
  };

  /**
   * The dialog ID for the indent notice.
   *
   * @since 0.1.0
   */
  const DIALOG_ID = 'tab-notice';
  /**
   * The component for handing the Tab key to insert/remove indents.
   * Just overriding the default behavior of the Tab key can not satisfy the "No Keyboard Trap" criterion.
   * Therefore as default, the Tab indentation is initially disabled, and it will be enabled when:
   * - the editor is focused by pointer devices, such as a mouse
   * - users explicitly enable it via CTRL+M
   *
   * @link https://www.w3.org/TR/WCAG21/#no-keyboard-trap
   *
   * @since 0.1.0
   */
  class Indentation extends Component {
      /**
       * The Indentation constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(Editor);
          this.addI18n(I18N$3);
          this.addKeyBindings(KEYMAP$3);
      }
      /**
       * Initializes the component.
       * This component requires the Dialog component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          if (!(this.Dialog = this.require('Dialog'))) {
              return;
          }
          super.mount(elements);
          this.space = this.options.indent;
          this.opts = this.getOptions('indentation', DEFAULT_OPTIONS$2);
          this.disabled = this.opts.activation !== 'load';
          this.register();
          this.listen();
      }
      /**
       * Explicitly enables or disables the component.
       *
       * @param disabled - Determines whether to disable the component or not.
       */
      setDisabled(disabled) {
          this.disabled = disabled;
          Indentation.noticed = true;
      }
      /**
       * Listens to some events.
       */
      listen() {
          let focused;
          this.on(EVENT_FOCUS, (e, type) => {
              if (type === 'pointer' && !focused) {
                  this.setDisabled(false);
              }
              focused = true;
          });
          this.on(`${EVENT_KEYMAP}:indent ${EVENT_KEYMAP}:unindent`, (e, ke, action) => {
              if (!this.disabled) {
                  if (action === 'indent') {
                      this.indent();
                  }
                  else {
                      this.unindent();
                  }
                  prevent(ke);
              }
          });
          this.on(`${EVENT_KEYMAP}:toggleTabMode`, (e, ke) => {
              this.setDisabled(!this.disabled);
              prevent(ke);
          });
          this.on(EVENT_NEWLINE, () => {
              this.indentNewline();
              if (this.opts.deepIndent) {
                  this.indentDeep();
              }
          });
          this.on(EVENT_KEYDOWN, this.onKeydown, this);
      }
      /**
       * Called when any key is pressed on the editor.
       *
       * @param e     - An EventBusEvent object.
       * @param ke    - A KeyboardEvent object.
       */
      onKeydown(e, ke) {
          if (this.opts.help && !Indentation.noticed && ke.key === 'Tab') {
              this.Dialog.show(DIALOG_ID);
              Indentation.noticed = true;
              prevent(ke);
              return;
          }
          this.remove(ke);
      }
      /**
       * Registers the dialog for the indentation notice.
       */
      register() {
          const { i18n } = this;
          const body = div();
          html$2(body, format(`<p>${i18n.indentDisabled}</p>`, `<strong>${this.Keymap.getShortcut('toggleTabMode')}</strong>`));
          this.Dialog.register(DIALOG_ID, body, i18n.indentNotice, [
              {
                  id: 'activate',
                  click: () => {
                      this.setDisabled(false);
                      this.Dialog.hide();
                  },
              },
              'confirm',
          ]);
      }
      /**
       * Prepends indents to all selected lines.
       */
      indent() {
          const { Input, Selection, space, space: { length: size } } = this;
          if (Selection.isCollapsed()) {
              Input.apply({ type: 'indent', insertion: space, offset: size });
          }
          else {
              this.emit(EVENT_CHANGE);
              const { start, end } = Selection.get();
              this.Code.replaceLinesBy(start[0], end[0], line => space + line);
              this.Sync.sync(start[0], end[0]);
              Selection.set([start[0], start[1] + size], [end[0], end[1] + size]);
              this.emit(EVENT_CHANGED);
          }
      }
      /**
       * Removes indents from all selected lines.
       */
      unindent() {
          const { space } = this;
          const { start, end } = this.Selection.get();
          let startOffset = 0;
          let endOffset = 0;
          let changed;
          this.Code.replaceLinesBy(start[0], end[0], (line, index, array) => {
              const match = line.match(new RegExp(`^(${space}| {0,${space.length}})`));
              if (match) {
                  const [indent] = match;
                  line = line.replace(indent, '');
                  if (index === 0) {
                      this.emit(EVENT_CHANGE);
                      startOffset -= indent.length;
                  }
                  if (index === array.length - 1) {
                      endOffset -= indent.length;
                  }
                  changed = true;
              }
              return line;
          });
          if (changed) {
              const startCol = max(start[1] + startOffset, 0);
              const endCol = max(end[1] + endOffset, 0);
              this.Sync.sync(start[0], end[0]);
              this.Selection.set([start[0], startCol], [end[0], endCol]);
              this.emit(EVENT_CHANGED);
          }
      }
      /**
       * Adds an indent to the newline when the enter key is pressed.
       */
      indentNewline() {
          const { Input } = this;
          const indent = this.lines[Input.row].getIndent();
          if (indent) {
              Input.set('newline', {
                  value: Input.before + LINE_BREAK$1 + indent + Input.after.replace(/^[ \t]+/, ''),
                  position: [Input.row + 1, indent.length],
              });
          }
      }
      /**
       * Adds an indent after specific patterns.
       */
      indentDeep() {
          const index = this.findConfigIndex();
          if (index > -1 && this.shouldIndentDeep(index)) {
              const { Input, space } = this;
              const indent = this.lines[Input.row].getIndent();
              const string = LINE_BREAK$1 + indent + space + (this.isClosed(index) ? LINE_BREAK$1 + indent : '');
              Input.set('indentDeep', {
                  key: 'Enter',
                  insertion: string,
                  position: [Input.row + 1, indent.length + space.length],
              });
          }
      }
      /**
       * Returns an indent config index.
       *
       * @return A config index if found, or -1 if not.
       */
      findConfigIndex() {
          const config = this.getConfig();
          for (let i = 0; i < config.length; i++) {
              const settings = config[i];
              if (isFunction(settings[0])) {
                  return settings[0](this.Editor) ? i : -1;
              }
              const { Input } = this;
              if (settings[0].test(Input.before.trim())) {
                  return i;
              }
          }
          return -1;
      }
      /**
       * Determines whether to increase the indent level or not.
       *
       * @param index - A config index.
       *
       * @return `true` if the level should be increased, or otherwise `false`.
       */
      shouldIndentDeep(index) {
          const config = this.getConfig()[index];
          const condition = config && config[2];
          if (isFunction(condition)) {
              return condition(this.Editor);
          }
          return !condition || this.Scope.isIn(condition);
      }
      /**
       * Checks if the position where the indentation is being added is enclosed by paired characters or not.
       *
       * @param index - A config index.
       *
       * @return `true` if the closing representation is found, or otherwise `false`.
       */
      isClosed(index) {
          const config = this.getConfig()[index];
          const condition = config && config[1];
          if (!condition) {
              return false;
          }
          if (isFunction(condition)) {
              return condition(this.Editor);
          }
          const { Input } = this;
          return condition.test(Input.after.trim());
      }
      /**
       * When the backspace key is pressed,
       * removes indents of a line if they are same with the previous one's.
       *
       * @param e - A KeyboardEvent object.
       */
      remove(e) {
          const { Selection } = this;
          if (e.key === 'Backspace' && Selection.isCollapsed()) {
              const { lines } = this;
              const { start } = Selection.get();
              const prevRow = start[0] - 1;
              const prevLine = lines[prevRow];
              if (!prevLine) {
                  return;
              }
              const prevIndent = prevLine.getIndent();
              const curIndent = lines[start[0]].getIndent();
              if (prevIndent && prevIndent === curIndent && start[1] === curIndent.length) {
                  this.emit(EVENT_CHANGE);
                  const position = [prevRow, prevLine.text.length];
                  this.Code.replaceRange(position, start, '');
                  this.Sync.sync(prevRow, start[0]);
                  Selection.set(position);
                  this.emit(EVENT_CHANGED);
                  prevent(e);
              }
          }
      }
      /**
       * Returns a config for indentation.
       *
       * @return A config array.
       */
      getConfig() {
          return this.getLanguage().indent || [];
      }
  }

  /**
   * The collection of i18n strings.
   *
   * @since 0.1.0
   */
  const I18N$2 = {
      jumpToLine: 'Jump to Line',
      jumpToolbar: 'Jump Toolbar',
  };

  /**
   * The collection of shortcuts for the Jump extension.
   *
   * @since 0.1.0
   */
  const KEYMAP$2 = {
      jumpToLine: ['G', true],
  };

  /**
   * The ID for the "Jump to the Line" toolbar.
   *
   * @since 0.1.0
   */
  const TOOLBAR_ID$1 = 'jump-to-line';
  /**
   * The throttle duration for applying the input result to the range.
   *
   * @since 0.1.0
   */
  const JUMP_DEBOUNCE_DURATION = 10;
  /**
   * The class for jumping to the specific line.
   *
   * @since 0.1.0
   */
  class Jump extends Component {
      /**
       * The Indentation constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(Editor);
          this.addI18n(I18N$2);
          this.addKeyBindings(KEYMAP$2);
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          if (!(this.Toolbar = this.require('Toolbar'))) {
              return;
          }
          super.mount(elements);
          this.create();
          this.listen();
      }
      /**
       * Creates elements for the jump interface and registers the wrapper to the toolbar.
       */
      create() {
          const wrapper = div();
          this.field = this.Toolbar.createField({ id: 'jumpToLine', tabindex: 1 }, wrapper);
          if (!this.getOptions('jump').hideLocation) {
              this.location = create('span', null, wrapper);
          }
          this.Toolbar.register(TOOLBAR_ID$1, wrapper, this.i18n.jumpToolbar);
      }
      /**
       * Listens to some events.
       */
      listen() {
          this.on(`${EVENT_KEYMAP}:jumpToLine`, (e, ke) => {
              this.update();
              this.Toolbar.show(TOOLBAR_ID$1);
              prevent(ke);
          });
          this.bind(this.field, 'input', debounce(this.jump.bind(this), JUMP_DEBOUNCE_DURATION));
          this.bind(this.field, 'keydown', (e) => {
              if (matchesKey(e, this.options.keymap.jumpToLine)) {
                  prevent(e);
              }
          });
      }
      /**
       * Jumps to the line specified by the input.
       */
      jump() {
          const row = parseInt(this.field.value) - 1;
          if (!isNaN(row) && between(row, 0, this.lines.length - 1)) {
              this.View.jump(row, true);
              this.Selection.set([row, 0]);
              this.field.focus();
              this.update();
              this.emit('jump:jumped');
          }
      }
      /**
       * Updates the location.
       */
      update() {
          if (this.location) {
              text(this.location, this.Selection.getLocation());
          }
      }
  }

  /**
   * The default options for the Resize component.
   *
   * @since 0.1.0
   */
  const DEFAULT_OPTIONS$1 = {
      horizontal: true,
      vertical: true,
  };

  /**
   * The collection of i18n strings.
   *
   * @since 0.1.0
   */
  const I18N$1 = {
      resizeBar: 'Drag to Resize/Double Click to Reset',
  };

  /**
   * The class name for the resize bar.
   *
   * @since 0.1.0
   */
  const CLASS_SIZER_BAR = `${PROJECT_CODE}__sizer__bar`;
  /**
   * The class for creating a resize bar.
   *
   * @since 0.1.0
   */
  class ResizeBar extends AbstractDraggableBar {
      /**
       * The ResizeBar constructor.
       *
       * @param Editor   - An Editor instance.
       * @param parent   - A parent element where the bar will be appended.
       * @param vertical - Determines whether to create a vertical or horizontal sizer.
       */
      constructor(Editor, parent, vertical) {
          super([CLASS_SIZER_BAR, `${CLASS_SIZER_BAR}--${vertical ? 'vertical' : 'horizontal'}`], parent, vertical);
          this.Editor = Editor;
          this.init();
      }
      /**
       * Initializes the instance.
       * Note that `aria-valuemin` and `aria-valuemax` is not necessary because their default values are `0` and `100`.
       *
       * @link https://www.w3.org/TR/wai-aria-1.2/#separator
       */
      init() {
          const { Editor } = this;
          const { resizeBar } = Editor.options.i18n;
          attr(this.elm, {
              role: 'separator',
              'aria-controls': Editor.elements.root.id,
              'aria-orientation': this.vertical ? 'horizontal' : 'vertical',
              'aria-valuenow': 0,
              'aria-label': resizeBar,
              title: resizeBar,
          });
          Editor.event.on(EVENT_RESIZE, this.updateAria.bind(this));
          on(this.elm, 'dblclick', () => {
              Editor[this.names.height] = '';
          });
      }
      /**
       * Called when the bar starts being dragged.
       *
       * @param e - A PointerEvent object.
       */
      onDrag(e) {
          super.onDrag(e);
          this.startSize = this.Editor[this.names.height];
      }
      /**
       * Called while the bar is dragged.
       *
       * @param e - A PointerEvent object.
       */
      onDragging(e) {
          super.onDragging(e);
          const diff = this.getCoord(e) - this.startCoord;
          this.Editor[this.names.height] = unit(this.startSize + diff);
      }
      /**
       * Updates aria attributes related with the separator role.
       * This method will be called through the event bus.
       */
      updateAria() {
          const { names } = this;
          const min = this.convertValueToPixel(names.minHeight) || 0;
          const max = this.convertValueToPixel(names.maxHeight);
          const now = this.Editor[names.height] - min;
          if (max > min) {
              attr(this.elm, { 'aria-valuenow': round(100 * 100 * now / (max - min)) / 100 });
          }
      }
      /**
       * Converts the CSS value to pixel.
       *
       * @param prop - A CSS prop name.
       *
       * @return A value in pixel.
       */
      convertValueToPixel(prop) {
          const { names } = this;
          const { root } = this.Editor.elements;
          const value = styles(root, prop);
          if (endsWith(value, '%')) {
              return parseFloat(value) * root.parentElement[names.scrollHeight] / 100;
          }
          return parseFloat(value);
      }
      /**
       * Destroys the instance.
       */
      destroy() {
          off(null, '', this);
          super.destroy();
      }
  }

  /**
   * The class name for the wrapper element that contains resize bars.
   *
   * @since 0.1.0
   */
  const CLASS_SIZER = `${PROJECT_CODE}__sizer`;
  /**
   * The component for resizing the editor by drag bars.
   *
   * @since 0.1.0
   */
  class Resize extends Component {
      constructor() {
          super(...arguments);
          /**
           * Stores ResizeBar instances.
           */
          this.bars = [];
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          super.mount(elements);
          const { Editor, bars } = this;
          const wrapper = div(CLASS_SIZER, elements.overlay);
          const options = this.getOptions('resize', DEFAULT_OPTIONS$1);
          this.addI18n(I18N$1);
          if (options.horizontal) {
              bars.push(new ResizeBar(Editor, wrapper, false));
          }
          if (options.vertical) {
              bars.push(new ResizeBar(Editor, wrapper, true));
          }
      }
      /**
       * Destroys the component.
       */
      destroy() {
          this.bars.forEach(bar => { bar.destroy(); });
          super.destroy();
      }
  }

  /**
   * Buttons settings for the search interface.
   */
  const SEARCH_BUTTONS = [
      {
          id: 'matchCase',
          icon: 'matchCase',
          click: 'toggleMatchCase',
          checkbox: true,
      },
      {
          id: 'wholeWord',
          icon: 'word',
          click: 'toggleWholeWord',
          checkbox: true,
      },
      {
          id: 'regexp',
          icon: 'regexp',
          click: 'toggleRegExp',
          checkbox: true,
      },
      {
          id: 'prevMatch',
          icon: 'arrowUp',
          click: 'prev',
      },
      {
          id: 'nextMatch',
          icon: 'arrowDown',
          click: 'next',
      },
  ];
  /**
   * Buttons settings for the replace interface.
   */
  const REPLACE_BUTTONS = [
      {
          id: 'replace',
          click: 'replace',
      },
      {
          id: 'replaceAll',
          click: 'replaceAll',
      },
  ];

  /**
   * The class for the search interface.
   */
  const CLASS_SEARCH = `${PROJECT_CODE}__search`;
  /**
   * The class for the replace interface.
   */
  const CLASS_REPLACE = `${PROJECT_CODE}__replace`;
  /**
   * The class for controls in the search interface.
   */
  const CLASS_SEARCH_CONTROLS = `${CLASS_SEARCH}__controls`;
  /**
   * The class for controls in the replace interface.
   */
  const CLASS_REPLACE_CONTROLS = `${CLASS_REPLACE}__controls`;
  /**
   * The class for displaying matches count.
   */
  const CLASS_MATCHES_COUNT = `${CLASS_SEARCH}__matches`;

  /**
   * The ID for the search toolbar.
   *
   * @since 0.1.0
   */
  const TOOLBAR_ID = 'search';
  /**
   * The group ID for markers.
   *
   * @since 0.1.0
   */
  const MARKER_ID = 'match';
  /**
   * The group ID for an active marker.
   *
   * @since 0.1.0
   */
  const ACTIVE_MARKER_ID = 'active-match';
  /**
   * The throttle duration for applying the input result to the range.
   *
   * @since 0.1.0
   */
  const SEARCH_THROTTLE_DURATION = 10;
  /**
   * The delay time until jumping to the next match after replace.
   *
   * @since 0.1.0
   */
  const JUMP_DELAY_AFTER_REPLACE = 20;

  /**
   * The default options for the Search component.
   *
   * @since 0.1.0
   */
  const DEFAULT_OPTIONS = {
      hideButtons: [],
  };

  /**
   * The collection of i18n strings.
   *
   * @since 0.1.0
   */
  const I18N = {
      search: 'Search',
      searchToolbar: 'Search/Replace Toolbar',
      wholeWord: 'Match Whole Word',
      prevMatch: 'Previous Match',
      nextMatch: 'Next Match',
      replace: 'Replace',
      replaceAll: 'Replace All',
      matchCase: 'Match Case',
      regexp: 'Regex',
      noResults: 'No results',
  };

  /**
   * Icons for the Search component.
   *
   * @since 0.1.0
   */
  const ICONS = {
      regexp: [
          'm15 2a1.5 1.5 0 0 0-1.5 1.5v3.4l-3.1-1.7a1.5 1.5 0 0 0-2 0.57 1.5 1.5 0 0 0 0.58 2l3 1.7-3 1.7a1.5 1.5 0 0 0-0.58 2 1.5 1.5 0 0 0 2 0.58l3.1-1.7v3.4a1.5 1.5 0 0 0 1.5 1.5 1.5 1.5 0 0 0 1.5-1.5v-3.4l3.1 1.7a1.5 1.5 0 0 0 2-0.58 1.5 1.5 0 0 0-0.58-2l-3-1.7 3-1.7a1.5 1.5 0 0 0 0.58-2 1.5 1.5 0 0 0-2-0.57l-3.1 1.7v-3.4a1.5 1.5 0 0 0-1.5-1.5zm-9.7 13c-1.8 0-3.3 1.5-3.3 3.3s1.5 3.3 3.3 3.3c1.8 0 3.3-1.5 3.3-3.3s-1.5-3.3-3.3-3.3z',
      ],
      word: [
          'm22 4h-2.95l-2.37 11.3-2.56-11.3h-3.94l-2.44 11.3-2.51-11.3h-3.16l4.11 16h2.87l3.02-11.8 3.04 11.8h2.9z',
      ],
      matchCase: [
          'm6.9 4.2c-3.7 0-5.6 2-5.6 6v3.5c0 4 1.8 6 5.5 6 1.7 0 3-0.42 4-1.3 0.97-0.88 1.5-2.1 1.5-3.8v-0.15h-2.8v0.18c0 0.77-0.22 1.4-0.66 1.8s-1.1 0.66-1.9 0.66c-0.92 0-1.6-0.26-2-0.84-0.44-0.55-0.64-1.5-0.64-2.7v-3.3c0-1.3 0.2-2.2 0.62-2.8s1.1-0.86 2-0.86c0.81 0 1.5 0.24 1.9 0.68 0.44 0.46 0.68 1.1 0.68 1.8v0.13h2.9v-0.15c0-1.6-0.51-2.8-1.5-3.7-0.99-0.88-2.3-1.3-4-1.3zm11 3.8c-1.5 0-2.6 0.4-3.4 1.2-0.84 0.79-1.2 2-1.2 3.6v2.1c0 1.6 0.4 2.9 1.2 3.6 0.84 0.79 2 1.2 3.4 1.2 1.4 0 2.5-0.35 3.3-1.1 0.79-0.73 1.2-1.7 1.2-3v-0.15h-2.6v0.13c0 0.53-0.18 0.95-0.51 1.2-0.33 0.31-0.77 0.44-1.3 0.44-0.64 0-1.1-0.18-1.5-0.55-0.35-0.35-0.51-0.97-0.51-1.8v-2.1c0-1.6 0.66-2.4 2-2.4 0.57 0 1 0.15 1.3 0.46 0.33 0.31 0.51 0.75 0.51 1.3v0.13h2.6v-0.22c0-1.3-0.4-2.3-1.2-3-0.79-0.7-1.9-1.1-3.3-1.1z',
      ],
  };

  /**
   * The collection of shortcuts for the Search extension.
   *
   * @since 0.1.0
   */
  const KEYMAP$1 = {
      search: ['F', true],
      searchNext: ['F3'],
      searchPrev: ['F3', false, true],
      replace: ['F', true, true],
  };

  /**
   * The class for searching texts in the code.
   *
   * @since 0.1.0
   */
  class Search extends Component {
      /**
       * The Search constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(Editor);
          /**
           * Holds matched ranges.
           */
          this.ranges = [];
          /**
           * The current range index.
           */
          this.index = -1;
          this.addIcons(ICONS);
          this.addI18n(I18N);
          this.addKeyBindings(KEYMAP$1);
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          if (!(this.Toolbar = this.require('Toolbar'))) {
              return;
          }
          super.mount(elements);
          this.opts = this.getOptions('search', DEFAULT_OPTIONS);
          this.throttledSearch = throttle(this.search.bind(this), SEARCH_THROTTLE_DURATION);
          this.create();
          this.Toolbar.register(TOOLBAR_ID, this.wrapper, this.i18n.searchToolbar);
          this.listen();
      }
      /**
       * Creates elements for the search interface.
       */
      create() {
          const { Toolbar } = this;
          const wrapper = div();
          const searchBar = div(CLASS_SEARCH, wrapper);
          const replaceBar = div(CLASS_REPLACE, wrapper);
          this.searchField = Toolbar.createField({ id: 'search', tabindex: 1 }, searchBar);
          this.replaceField = Toolbar.createField({ id: 'replace', tabindex: 1 }, replaceBar);
          const searchControls = div(CLASS_SEARCH_CONTROLS, searchBar);
          const replaceControls = div(CLASS_REPLACE_CONTROLS, replaceBar);
          const searchButtons = SEARCH_BUTTONS.filter(settings => !includes(this.opts.hideButtons, settings.id));
          const replaceButtons = REPLACE_BUTTONS.filter(settings => !includes(this.opts.hideButtons, settings.id));
          this.buttons = assign$1(Toolbar.createButtons(searchButtons, searchControls, this), Toolbar.createButtons(replaceButtons, replaceControls, this));
          if (!this.opts.hideMatchCount) {
              this.counter = create('span', CLASS_MATCHES_COUNT, searchControls);
          }
          this.wrapper = wrapper;
          this.searchBar = searchBar;
          this.replaceBar = replaceBar;
      }
      /**
       * Listens to some events.
       */
      listen() {
          const { searchField } = this;
          this.on(`${EVENT_KEYMAP}:search`, (e, ke) => {
              this.show(!this.options.keymap.replace);
              prevent(ke);
          });
          this.on(`${EVENT_KEYMAP}:replace`, (e, ke) => {
              this.show(true);
              prevent(ke);
          });
          this.bind(searchField, 'input', this.onInput, this);
          this.bind(searchField, 'keydown', this.onSearchFieldKeydown, this);
          this.bind(this.replaceField, 'keydown', this.onReplaceFieldKeydown, this);
          this.on('toolbar:opened', (e, toolbar, id) => {
              if (id !== TOOLBAR_ID) {
                  this.clear();
              }
          });
          this.on('toolbar:closed', this.clear, this);
          this.on([EVENT_CHANGED, EVENT_SYNCED], () => {
              const { value } = searchField;
              if (this.isActive() && value) {
                  this.throttledSearch(value, this.index);
              }
          });
          this.on(EVENT_READONLY, (e, readOnly) => {
              if (this.isActive()) {
                  this.toggleReplace(!readOnly);
              }
          });
      }
      /**
       * Called when any key is pressed on the search field.
       *
       * @param e - A KeyboardEvent object.
       */
      onSearchFieldKeydown(e) {
          if (e.key === 'Enter') {
              this.next();
              prevent(e);
              return;
          }
          this.onKeydown(e);
      }
      /**
       * Called when any key is pressed on the replace field.
       *
       * @param e - A KeyboardEvent object.
       */
      onReplaceFieldKeydown(e) {
          if (e.key === 'Enter') {
              this.replace();
              prevent(e);
              return;
          }
          this.onKeydown(e);
      }
      /**
       * Called when any key is pressed on both the search and input fields.
       *
       * @param e - A KeyboardEvent object.
       */
      onKeydown(e) {
          const key = e.key.toUpperCase();
          const { Keymap } = this;
          const matches = Keymap.matches.bind(Keymap, e);
          const next = matches('searchNext');
          const prev = matches('searchPrev');
          if (next || prev) {
              this[prev ? 'prev' : 'next']();
              prevent(e);
          }
          else if (matches('search')) {
              this.show(false);
              prevent(e);
          }
          else if (matches('replace')) {
              this.show(true);
              prevent(e);
          }
          else if (e.ctrlKey) {
              if (key !== 'A' && key !== 'X' && key === 'C') {
                  prevent(e);
              }
          }
          else if (e.altKey) {
              prevent(e);
          }
      }
      /**
       * Called when the field receives input.
       */
      onInput() {
          const { value } = this.searchField;
          if (value) {
              this.throttledSearch(value);
          }
          else {
              this.clear();
              this.toggleDisabled();
          }
      }
      /**
       * Searches the provided string with current settings.
       *
       * @param search - Optional. A string to search.
       * @param index  - Optional. An index to activate.
       *
       * @return An array with tuples that contains `[ index, length ]`.
       */
      search(search = this.searchField.value, index) {
          const { Range } = this;
          let source;
          try {
              source = this.regexp && search ? new RegExp(search) : search;
          }
          catch (e) {
              return;
          }
          const ranges = this.Code.search(source, !this.matchCase, this.wholeWord, MAX_RANGES);
          this.clear();
          Range.register(MARKER_ID, ranges);
          this.ranges = ranges;
          if (isUndefined$1(index) || index < 0) {
              this.index = -1;
              this.next();
          }
          else {
              this.index = clamp(index, 0, ranges.length - 1);
              this.activate(this.index);
          }
          this.updateMatchesCount();
          this.toggleDisabled();
      }
      /**
       * Search again without changing the current index.
       *
       * @param index - Optional. An index to activate.
       */
      rematch(index) {
          this.search(undefined, index);
      }
      /**
       * Updates matches counter.
       */
      updateMatchesCount() {
          if (this.counter) {
              const { length } = this.ranges;
              let string;
              if (!length) {
                  string = this.i18n.noResults;
              }
              else if (length > MAX_RANGES) {
                  string = `${MAX_RANGES}+`;
              }
              else {
                  string = `${this.index + 1}/${length}`;
              }
              text(this.counter, string);
          }
      }
      /**
       * Toggles `disabled` property of some buttons.
       */
      toggleDisabled() {
          ['prevMatch', 'nextMatch', 'replace', 'replaceAll'].forEach(name => {
              const button = this.buttons[name];
              if (button) {
                  button.disabled = !this.ranges.length;
              }
          });
      }
      /**
       * Jumps to the start position of the range specified by the index.
       *
       * @param index - An index of the range to jump to.
       */
      jump(index) {
          const range = this.ranges[index];
          if (range) {
              this.View.jump(range.start[0], true);
          }
      }
      /**
       * Highlights the prev or next matched text and jumps there.
       *
       * @param prev - Whether to highlight the previous or next match.
       */
      move(prev) {
          const { length } = this.ranges;
          let index = this.index + (prev ? -1 : 1);
          if (index >= length) {
              index = 0;
          }
          else if (index < 0) {
              index = length - 1;
          }
          this.activate(index);
          this.jump(index);
          this.index = index;
          this.updateMatchesCount();
      }
      /**
       * Toggles the active class and the `aria-checked` attribute.
       *
       * @param button  - A target button element.
       * @param checked - Determines whether to check or uncheck them.
       */
      toggleChecked(button, checked) {
          toggleClass(button, CLASS_ACTIVE, checked);
          attr(button, { 'aria-checked': checked });
      }
      /**
       * Toggles the replace UI.
       *
       * @param show - Determines whether to show the replace UI or not.
       */
      toggleReplace(show) {
          toggleClass(this.replaceBar, CLASS_ACTIVE, show && !this.Editor.readOnly && !this.opts.hideReplace);
      }
      /**
       * Checks if the search toolbar is active or not.
       *
       * @return `true` if the search toolbar is active, or otherwise `false`.
       */
      isActive() {
          return this.Toolbar.isActive(TOOLBAR_ID);
      }
      /**
       * Toggles the "Match Case" mode.
       *
       * @param activate - Optional. Whether to activate the "Match Case" mode or not.
       */
      toggleMatchCase(activate = !this.matchCase) {
          this.toggleChecked(this.buttons.matchCase, (this.matchCase = activate));
          this.search();
      }
      /**
       * Toggles the "RegExp" mode.
       *
       * @param activate - Optional. Whether to activate the "RegExp" mode or not.
       */
      toggleRegExp(activate = !this.regexp) {
          this.toggleChecked(this.buttons.regexp, (this.regexp = activate));
          this.search();
      }
      /**
       * Toggles the "Match Whole Word" mode.
       *
       * @param wholeWord - Optional. Whether to activate the "Match Whole Word" mode or not.
       */
      toggleWholeWord(wholeWord = !this.wholeWord) {
          this.toggleChecked(this.buttons.wholeWord, (this.wholeWord = wholeWord));
          this.search();
      }
      /**
       * Highlights the matched text at the index.
       *
       * @param index - An index of the range to highlight.
       */
      activate(index) {
          const activeRange = this.ranges[index];
          if (activeRange) {
              const { Range } = this;
              Range.clear(ACTIVE_MARKER_ID);
              Range.register(ACTIVE_MARKER_ID, [activeRange]);
          }
      }
      /**
       * Highlights the next matched text and jumps there.
       */
      next() {
          this.move(false);
      }
      /**
       * Highlights the previous matched text and jumps there.
       */
      prev() {
          this.move(true);
      }
      /**
       * Replaces the search result with the provided replacement string.
       * If the length of ranges does not change after replacing,
       * that means the replacement includes the original word itself.
       *
       * @param replacement - Optional. A replacement string.
       * @param index       - Optional. An index to replace.
       */
      replace(replacement = this.replaceField.value, index = this.index) {
          const { ranges } = this;
          const activeRange = ranges[index];
          if (activeRange) {
              const { Selection } = this;
              const { start, end } = activeRange;
              const nextRange = ranges[index + 1];
              Selection.update(start, start, true);
              this.emit(EVENT_CHANGE, 'replace');
              this.jump(index);
              this.Code.replaceRange(start, end, replacement);
              this.Sync.sync(start[0], end[0]);
              this.emit(EVENT_CHANGED, 'replace');
              this.rematch(index);
              if (nextRange) {
                  this.index = this.toIndex(nextRange);
                  this.activate(this.index);
              }
              this.jumpTimerAfterReplace = setTimeout(() => {
                  this.jump(this.index);
              }, JUMP_DELAY_AFTER_REPLACE);
          }
      }
      /**
       * Converts the provided range to the range index.
       *
       * @param range - A range to convert into a range index.
       *
       * @return A range index if available, or otherwise `-1`.
       */
      toIndex(range) {
          const { ranges } = this;
          for (let i = 0; i < ranges.length; i++) {
              if (!compare(ranges[i].start, range.start) && !compare(ranges[i].end, range.end)) {
                  return i;
              }
          }
          return -1;
      }
      /**
       * Replaces all matched strings with the replacement.
       *
       * @param replacement - Optional. A replacement string.
       */
      replaceAll(replacement = this.replaceField.value) {
          const { ranges } = this;
          if (ranges.length) {
              this.emit(EVENT_CHANGE);
              ranges.forEach(range => {
                  this.Code.replaceRange(range.start, range.end, replacement);
              });
              const endRow = ranges[ranges.length - 1].end[0];
              this.View.jump(endRow);
              this.Sync.sync(ranges[0].start[0], endRow);
              this.clear();
              this.emit(EVENT_CHANGED);
          }
      }
      /**
       * Shows the toolbar.
       *
       * @param replace - Whether to display the replace interface or not.
       */
      show(replace) {
          const { Selection, searchField } = this;
          this.toggleReplace(replace);
          if (!Selection.isCollapsed()) {
              if (!Selection.isMultiline()) {
                  searchField.value = Selection.toString();
              }
          }
          this.Toolbar.show(TOOLBAR_ID);
          this.rematch();
      }
      /**
       * Clears all markers.
       */
      clear() {
          const { Range } = this;
          Range.clear(MARKER_ID);
          Range.clear(ACTIVE_MARKER_ID);
          this.ranges = [];
          this.updateMatchesCount();
          this.throttledSearch.cancel();
          clearTimeout(this.jumpTimerAfterReplace);
      }
  }

  /**
   * The collection of shortcuts for the Shortcut extension.
   *
   * @since 0.1.0
   */
  const KEYMAP = {
      cutLine: ['X', true],
      copyLine: ['C', true],
      moveUp: ['ArrowUp', true],
      moveDown: ['ArrowDown', true],
  };

  /**
   * The class for handling some shortcuts.
   *
   * @since 0.1.0
   */
  class Shortcut extends Component {
      /**
       * The Search constructor.
       *
       * @param Editor - An Editor instance.
       */
      constructor(Editor) {
          super(Editor);
          this.addKeyBindings(KEYMAP);
      }
      /**
       * Initializes the component.
       *
       * @param elements - A collection of essential elements.
       */
      mount(elements) {
          super.mount(elements);
          const { Selection, Measure, Edit } = this;
          this.on(`${EVENT_KEYMAP}:copyLine`, (e, ke) => {
              if (Selection.isCollapsed() && !isPrevented(ke)) {
                  Selection.selectLine(undefined, true, true);
                  Edit.copy();
                  prevent(ke);
              }
          });
          this.on(`${EVENT_KEYMAP}:cutLine`, (e, ke) => {
              if (Selection.isCollapsed() && !isPrevented(ke)) {
                  Edit.cutLine();
                  prevent(ke);
              }
          });
          this.on(`${EVENT_KEYMAP}:moveUp ${EVENT_KEYMAP}:moveDown`, (e, ke) => {
              const { scroller } = elements;
              scroller.scrollTop += (endsWith(e.type, 'n') ? 1 : -1) * Measure.lineHeight;
              prevent(ke);
          });
      }
  }

  /**
   * Classes for the toolbar components.
   *
   * @since 0.1.0
   */
  const CLASS_TOOLBAR = `${PROJECT_CODE}__toolbar`;
  const CLASS_TOOLBAR_BODY = `${CLASS_TOOLBAR}__body`;
  const CLASS_TOOLBAR_UI = `${CLASS_TOOLBAR}__ui`;
  const CLASS_TOOLBAR_GROUP = `${CLASS_TOOLBAR}__group`;

  /**
   * The class for creating a toolbar.
   *
   * @since 0.1.0
   */
  class Toolbar extends UIComponent {
      /**
       * Listens to some events and receives requests from other components.
       */
      listen() {
          super.listen();
          this.on(EVENT_RESIZE, this.resize, this);
      }
      /**
       * Creates toolbar elements.
       *
       * @link https://www.w3.org/TR/wai-aria-1.2/#toolbar
       */
      create() {
          const { elements } = this;
          const id = `${elements.root.id}-toolbar`;
          const wrapper = div({ id, role: 'toolbar', class: CLASS_TOOLBAR });
          const close = this.createCloseButton({ 'aria-controls': id });
          this.body = div(CLASS_TOOLBAR_BODY, wrapper);
          append(div(CLASS_TOOLBAR_UI, wrapper), close);
          prepend(elements.root, wrapper);
          this.wrapper = wrapper;
      }
      /**
       * Appends the group element to the body element instead of the wrapper element.
       *
       * @param group - A group ID.
       */
      append(group) {
          append(this.body, this.groups[group].elm);
      }
      /**
       * Resizes the scroller according to the toolbar height.
       */
      resize() {
          if (isIE() && this.isActive()) {
              const maxHeight = styles(this.elements.root, 'maxHeight');
              styles(this.elements.body, { maxHeight: `calc(${maxHeight} - ${unit(height(this.wrapper))})` });
          }
      }
      /**
       * Registers a group to the toolbar.
       *
       * @param group - A group ID.
       * @param elm   - An element to register.
       * @param label - A label of the toolbar.
       */
      register(group, elm, label) {
          addClass(elm, CLASS_TOOLBAR_GROUP);
          this.groups[group] = { elm, label };
      }
      /**
       * Displays the toolbar.
       *
       * @param group - A group ID to display.
       */
      show(group) {
          const { pageXOffset, pageYOffset } = window;
          const { wrapper } = this;
          super.show(group);
          this.resize();
          if (this.group) {
              removeClass(wrapper, `${CLASS_TOOLBAR}--${this.group}`);
          }
          addClass(wrapper, `${CLASS_TOOLBAR}--${group}`);
          attr(wrapper, { 'aria-label': this.groups[group].label });
          this.autoFocus(group);
          window.scrollTo(pageXOffset, pageYOffset);
          this.View.emitResize();
          this.emit('toolbar:opened', this, group);
      }
      /**
       * Hides the toolbar.
       */
      hide() {
          const { pageXOffset, pageYOffset } = window;
          super.hide();
          removeClass(this.wrapper, `${CLASS_TOOLBAR}--${this.group}`);
          styles(this.elements.body, { maxHeight: '' });
          this.Selection.reselect();
          window.scrollTo(pageXOffset, pageYOffset);
          this.View.emitResize();
          this.emit('toolbar:closed', this, this.group);
      }
  }

  var Extensions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActiveLine: ActiveLine,
    AutoClose: AutoClose,
    BracketMatching: BracketMatching,
    Comment: Comment,
    Dialog: Dialog,
    Guide: Guide,
    Gutter: Gutter,
    History: History,
    Indentation: Indentation,
    Jump: Jump,
    Resize: Resize,
    Search: Search,
    Shortcut: Shortcut,
    Toolbar: Toolbar
  });

  /**
   * Extends the original Lexer class to add custom data to the 3rd parameter of each token.
   *
   * @since 0.1.0
   */
  class Lexer extends Lexer$1 {
      /**
       * Runs the tokenization and adds custom data to each token.
       *
       * @param text  - A text to tokenize.
       * @param limit - Optional. Limits the number of lines.
       *
       * @return An array with arrays of tokens.
       */
      run(text, limit) {
          const lines = this.tokenize(text, limit);
          for (let i = 0; i < lines.length; i++) {
              const tokens = lines[i];
              let offset = 0;
              for (let j = 0; j < tokens.length; j++) {
                  const token = tokens[j];
                  const length = token[1].length;
                  const info = token[2];
                  const classes = `${CLASS_TOKEN} ${PROJECT_CODE_SHORT}__${token[0].split('.')[0]}`;
                  const escaped = token[1].replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                  const html = `<code class="${classes}">${escaped}</code>`;
                  token[2] = {
                      category: token[0],
                      code: token[1],
                      html,
                      from: offset,
                      to: offset + length,
                      index: j,
                      state: info.state,
                      depth: info.depth,
                      head: info.head,
                      tail: info.tail,
                      distance: info.distance,
                      language: info.language,
                      split: info.split,
                  };
                  offset += length;
              }
          }
          return lines;
      }
  }

  /**
   * Returns a CSS Language object.
   *
   * @since 0.1.0
   *
   * @return A Language object.
   */
  function css() {
      const language = css$1();
      return assign$1({ id: language.id, language, lexer: new Lexer(language) }, cssConfig());
  }
  /**
   * Returns a CSS LanguageConfig object.
   *
   * @private
   * @since 0.1.0
   *
   * @return A LanguageConfig object.
   */
  function cssConfig() {
      const scope = ['!comment', '!string'];
      const bracketsCompletionData = {
          close: scope,
          skip: scope,
          remove: scope,
      };
      const quotesCompletionData = {
          close: '@quotes',
          skip: '@quotes',
          remove: '@quotes',
      };
      return {
          lineComment: ['/*', '*/'],
          blockComment: ['/*', '*/'],
          multiline: [
              ['/*', '*/', CATEGORY_COMMENT],
          ],
          indent: [
              [/{$/, /^}/, scope],
          ],
          autoClose: [
              ['(', ')', bracketsCompletionData],
              ['[', ']', bracketsCompletionData],
              ['{', '}', bracketsCompletionData],
              ["'", "'", quotesCompletionData],
              ['"', '"', quotesCompletionData],
          ],
      };
  }

  /**
   * Returns a JavaScript Language object.
   *
   * @since 0.1.0
   *
   * @return A Language object.
   */
  function javascript() {
      const language = javascript$1();
      return assign$1({ id: language.id, language, lexer: new Lexer(language) }, javascriptConfig());
  }
  /**
   * Returns a JavaScript LanguageConfig object.
   *
   * @private
   * @since 0.1.0
   *
   * @return A LanguageConfig object.
   */
  function javascriptConfig() {
      const scope = ['!comment', '!string'];
      const bracketsCompletionData = {
          close: scope,
          skip: scope,
          remove: scope,
      };
      const quotesCompletionData = {
          close: '@quotes',
          skip: '@quotes',
          remove: '@quotes',
      };
      return {
          lineComment: ['//', ''],
          blockComment: ['/*', '*/'],
          multiline: [
              ['`', '`', CATEGORY_STRING, '#backtick'],
              ['/*', '*/', CATEGORY_COMMENT],
          ],
          indent: [
              [/\($/, /^\)/, scope],
              [/\[$/, /^]/, scope],
              [/{$/, /^}/, scope],
          ],
          autoClose: [
              ['(', ')', bracketsCompletionData],
              ['[', ']', bracketsCompletionData],
              ['{', '}', bracketsCompletionData],
              ["'", "'", quotesCompletionData],
              ['"', '"', quotesCompletionData],
              [
                  '`',
                  '`',
                  {
                      close: shouldCloseBacktick,
                      skip: shouldSkipOrRemoveBacktick,
                      remove: shouldSkipOrRemoveBacktick,
                  },
              ],
          ],
      };
  }
  /**
   * Determines whether to close the backtick or not.
   * A backtick should not be completed when:
   * - the entered backtick is closing a string (`aaa[`]).
   * - the next character of the entered backtick is not empty ([`]aaa).
   *
   * @param Editor - An editor instance.
   *
   * @return `true` if the backtick should be closed.
   */
  function shouldCloseBacktick(Editor) {
      const { Components } = Editor;
      const { Input } = Components;
      const prevInfo = Input.info;
      if (prevInfo && prevInfo.category === CATEGORY_STRING) {
          return false;
      }
      const { after } = Input;
      return !Components.Scope.isIn('comment') && (!after || /^\s/.test(after));
  }
  /**
   * Determines whether to skip/remove the backtick or not.
   *
   * @param Editor - An editor instance.
   *
   * @return `true` if the backtick should be skipped or removed.
   */
  function shouldSkipOrRemoveBacktick(Editor) {
      const { Components } = Editor;
      const { start } = Components.Selection.get();
      const info = Components.Code.lines.getInfoAt(start);
      if (info && info.category === CATEGORY_STRING) {
          return compare(start, [start[0], info.to - 1]) === 0;
      }
      return false;
  }

  /**
   * A collection of self-closing tags.
   *
   * @link https://developer.mozilla.org/en-US/docs/Glossary/Empty_element
   *
   * @since 0.1.0
   */
  const SELF_CLOSING_TAGS = [
      'area',
      'base',
      'br',
      'col',
      'embed',
      'hr',
      'img',
      'input',
      'keygen',
      'link',
      'meta',
      'param',
      'source',
      'track',
      'wbr',
  ];

  /**
   * The max number of lines to scan up for an opening/closing tag.
   */
  const SCAN_UP_LIMIT = 500;
  /**
   * Returns a HTML Language object.
   *
   * @since 0.1.0
   *
   * @param options - Optional. Options.
   *
   * @return A Language object.
   */
  function html(options = {}) {
      const script = options.script || {
          language: javascript(),
          use: {
              config: javascript(),
              code: '<script>',
              depth: 2,
          },
      };
      const style = options.style || {
          language: css(),
          use: {
              config: css(),
              code: '<style>',
              depth: 2,
          },
      };
      const language = html$1({ script: () => script.language.language, style: () => style.language.language });
      return assign$1({
          id: language.id,
          language,
          lexer: new Lexer(language),
          use: {
              [script.language.id]: script.use,
              [style.language.id]: style.use,
          },
      }, htmlConfig());
  }
  /**
   * Returns a HTML LanguageConfig object.
   *
   * @since 0.1.0
   *
   * @return A LanguageConfig object.
   */
  function htmlConfig() {
      const quotesCompletionData = {
          close: shouldClose,
          skip: shouldSkipOrRemove,
          remove: shouldSkipOrRemove,
      };
      return {
          lineComment: ['<!--', '-->'],
          blockComment: ['<!--', '-->'],
          multiline: [
              ['<!--', '-->', CATEGORY_COMMENT],
          ],
          indent: [
              [shouldIndent, /^<\/\w+/],
          ],
          autoClose: [
              ["'", "'", quotesCompletionData],
              ['"', '"', quotesCompletionData],
              ['>', closeCurrentTag],
              ['/', closeTag],
              ['=', '""', {
                      close: shouldAppendQuotes,
                      offset: 1,
                  }],
          ],
      };
  }
  /**
   * Determines whether to append `""` after `=` in a tag.
   *
   * @param Editor - An editor instance.
   *
   * @return `true` if quotes should be appended, or otherwise `false`.
   */
  function shouldAppendQuotes(Editor) {
      const { Components } = Editor;
      return Components.Scope.isIn(['#attr', '#tag', '#openTag', '!value'])
          && /(^|[ \t])[^\s/<>"'=]+=$/.test(Components.Input.before);
  }
  /**
   * Determines whether to indent deep or not.
   *
   * @param editor - An editor instance.
   *
   * @return `true` if the indent levent should be increased.
   */
  function shouldIndent(editor) {
      return !!getOpeningTagName(editor);
  }
  /**
   * Determines whether to proceed close, skip and remove process.
   *
   * @param Editor       - An Editor instance.
   * @param config       - A target config.
   * @param skipOrRemove - Set `true` when checking a `skip` or `remove` process.
   *
   * @return `true` if the completion process should be proceeded, or otherwise `false`.
   */
  function validateQuotes(Editor, config, skipOrRemove) {
      const { Components } = Editor;
      if (Components.Scope.isIn(['#attr'])) {
          if (skipOrRemove) {
              return true;
          }
          const { Input } = Components;
          return new RegExp(`=\\s*?${config[0]}$`).test(Input.before);
      }
  }
  /**
   * Determines whether to close quotes or not.
   *
   * @param Editor - An Editor instance.
   * @param config - A target config.
   *
   * @return `true` if the quote should be completed.
   */
  function shouldClose(Editor, config) {
      return validateQuotes(Editor, config, false);
  }
  /**
   * Determines whether to skip/remove quotes or not.
   *
   * @param Editor - An Editor instance.
   * @param config - A target config.
   *
   * @return `true` if inputting a quote should be skipped.
   */
  function shouldSkipOrRemove(Editor, config) {
      return validateQuotes(Editor, config, true);
  }
  /**
   * Returns an opening tag name at the current position.
   *
   * @param Editor - An Editor instance.
   *
   * @return A tag name if found, or an empty string if not.
   */
  function getOpeningTagName(Editor) {
      const { Components } = Editor;
      const range = Components.Selection.get();
      const col = range.start[1] - 1;
      if (col >= 0) {
          const { Code, Code: { lines } } = Components;
          const [tailRow] = range.start;
          const tailInfo = lines.getInfoAt([tailRow, col]);
          if (tailInfo && tailInfo.category === CATEGORY_BRACKET && tailInfo.code === '>') {
              const { row: headRow, info: headInfo } = lines.scanUp([tailRow, tailInfo.from], [CATEGORY_BRACKET, /</]);
              const code = Code.sliceRange([headRow, headInfo.from], [tailRow, tailInfo.to]);
              const matches = /<([^\s/<>"'=]+)/.exec(code);
              if (matches && !includes(SELF_CLOSING_TAGS, matches[1])) {
                  return matches[1];
              }
          }
      }
  }
  /**
   * Closes the HTML tag if it is not a self-closed tag.
   *
   * @param editor - An Editor instance.
   *
   * @return A closing tag.
   */
  function closeCurrentTag(editor) {
      const tag = getOpeningTagName(editor);
      return tag ? `</${tag}>` : '';
  }
  /**
   * Attempts to close the tag when the `/` is entered.
   * This function is not strict for nested tags.
   *
   * @param Editor - An Editor instance.
   *
   * @return A closing tag.
   */
  function closeTag(Editor) {
      const { Components } = Editor;
      const { start } = Components.Selection.get();
      const { lines } = Components.Code;
      const closingInfo = lines.scanUp(start, [CATEGORY_TAG_CLOSE, /./], null, 0, SCAN_UP_LIMIT);
      const openingInfo = lines.scanUp(start, [CATEGORY_TAG, /./], null, 0, SCAN_UP_LIMIT);
      if (openingInfo) {
          if (closingInfo) {
              if ((openingInfo.row - closingInfo.row || openingInfo.info.from - closingInfo.info.from) < 0) {
                  return '>';
              }
          }
      }
      const tag = openingInfo.info.code;
      if (includes(SELF_CLOSING_TAGS, tag)) {
          return '>';
      }
      return `${tag}>`;
  }

  /**
   * Returns a JSON Language object.
   *
   * @since 0.1.0
   *
   * @return A Language object.
   */
  function json() {
      const language = json$1();
      return assign$1({ id: language.id, language, lexer: new Lexer(language) }, jsonConfig());
  }
  /**
   * Returns a JSON LanguageConfig object.
   *
   * @private
   * @since 0.1.0
   *
   * @return A LanguageConfig object.
   */
  function jsonConfig() {
      const scope = ['!string'];
      const bracketsCompletionData = {
          close: scope,
          skip: scope,
          remove: scope,
      };
      const quotesCompletionData = {
          close: '@quotes',
          skip: '@quotes',
          remove: '@quotes',
      };
      return {
          indent: [
              [/{$/, /^}/, scope],
              [/\[$/, /^]/, scope],
          ],
          autoClose: [
              ['[', ']', bracketsCompletionData],
              ['{', '}', bracketsCompletionData],
              ['"', '"', quotesCompletionData],
          ],
      };
  }

  /**
   * Returns a JSX Language object.
   *
   * @since 0.1.0
   *
   * @return A Language object.
   */
  function jsx() {
      const language = jsx$1();
      return assign$1({ id: language.id, language, lexer: new Lexer(language) }, jsxConfig());
  }
  /**
   * Returns a JSX LanguageConfig object.
   *
   * @private
   * @since 0.1.0
   *
   * @return A LanguageConfig object.
   */
  function jsxConfig() {
      const js = javascriptConfig();
      const html = htmlConfig();
      js.indent.push(...html.indent);
      const { autoClose } = html;
      const config = autoClose.filter(config => config[0] === '=')[0];
      if (config) {
          config[1] = '{}';
      }
      js.autoClose.push(...html.autoClose);
      return js;
  }

  /**
   * Returns a `none` Language object.
   *
   * @since 0.1.0
   *
   * @return A Language object.
   */
  function none() {
      const language = none$1();
      return { id: language.id, language, lexer: new Lexer(language) };
  }

  /**
   * Returns a SCSS Language object.
   *
   * @since 0.1.0
   *
   * @return A Language object.
   */
  function scss() {
      const language = scss$1();
      return assign$1({ id: language.id, language, lexer: new Lexer(language) }, scssConfig());
  }
  /**
   * Returns a SCSS LanguageConfig object.
   *
   * @private
   * @since 0.1.0
   *
   * @return A LanguageConfig object.
   */
  function scssConfig() {
      return assign$1(cssConfig(), {
          lineComment: ['//', ''],
      });
  }

  /**
   * Returns a TypeScript Language object.
   *
   * @since 0.1.0
   *
   * @return A Language object.
   */
  function typescript() {
      const language = typescript$1();
      return assign$1({ id: language.id, language, lexer: new Lexer(language) }, javascriptConfig());
  }

  /**
   * Returns a Vue Language object.
   *
   * @since 0.1.0
   *
   * @return A Language object.
   */
  function vue(options = {}) {
      const script = options.script || {
          language: javascript(),
          use: {
              config: javascript(),
              code: '<script>',
              depth: 2,
          },
      };
      const style = options.style || {
          language: css(),
          use: {
              config: css(),
              code: '<style>',
              depth: 2,
          },
      };
      const language = vue$1({ script: () => script.language.language, style: () => style.language.language });
      return assign$1({
          id: language.id,
          language,
          lexer: new Lexer(language),
          use: {
              [script.language.id]: script.use,
              [style.language.id]: style.use,
          },
      }, vueConfig());
  }
  /**
   * Returns a Vue LanguageConfig object.
   *
   * @private
   * @since 0.1.0
   *
   * @return A LanguageConfig object.
   */
  function vueConfig() {
      return htmlConfig();
  }

  /**
   * Returns a XML Language object.
   *
   * @since 0.1.0
   *
   * @return A Language object.
   */
  function xml() {
      const language = xml$1();
      return assign$1({ id: language.id, language, lexer: new Lexer(language) }, xmlConfig());
  }
  /**
   * Returns a XML LanguageConfig object.
   *
   * @private
   * @since 0.1.0
   *
   * @return A LanguageConfig object.
   */
  function xmlConfig() {
      return htmlConfig();
  }

  var languages = /*#__PURE__*/Object.freeze({
    __proto__: null,
    css: css,
    html: html,
    javascript: javascript,
    json: json,
    jsx: jsx,
    none: none,
    scss: scss,
    typescript: typescript,
    vue: vue,
    xml: xml
  });

  forOwn$1(languages, language => {
      RyuseiCode.register(language());
  });
  RyuseiCode.compose(Extensions);

  return RyuseiCode;

})));
//# sourceMappingURL=ryuseicode-complete.min.js.map
